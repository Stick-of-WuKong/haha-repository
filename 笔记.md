# 笔记


Linux学习：
### 远程连接

连接Linux系统用SHH方式

连接Windows系统无法使用SSH，需要RDP方式

从控制的办公虚拟机切换回hp的系统   ctrl+alt+end

## 网关和路由

1.概念不同：网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连；路由器是连接因特网中各局域网、广域网的设备， 它会根据信道的情况自动选择和设定路由，以最佳路径， 按前后顺序发送信号。 网关只是一个统称，是连接两个不同网络的这么一个设备——就像是连接两个不同房间之间的那个门。可以是防火墙，可以是路由器，也可以是三层交换机。只要具有3层以及以上层次的设备，都可以转化为网关这个角色。

网关和路由器的相似之处在于，它们都可用于调节两个或多个独立网络之间的流量。但是，路由器用于连接两个相似类型的网络，而网关用于连接两个不同类型的网络。不同类型的网络指的是使用不同主要协议的网络。网关是计算机网络中的一个节点（路由器），它是往返于其他网络的数据的关键停靠点。多亏有了网关，我们才能够来回通信和发送数据。没有网关（以及许多其他硬件和软件），互联网对我们来说将毫无用处。

在工作场所中，网关是将流量从工作站路由到服务网页的外部网络的计算机。对于家庭中的基本Internet连接，网关是Internet服务提供商，可让您访问整个Internet。由于这种逻辑，路由器可能被视为网关，但是网关并不总是被视为路由器。路由器是最常见的网关，用于将家庭或企业网络连接到Internet。

按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们通常所讲的“网关”均指TCP/IP协议下的网关。

那么网关到底是什么呢？网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。

所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。

网关的分类
1)协议网关：协议网关通常在使用不同协议的网络区域间做协议转换。

2)应用网关：应用网关是在使用不同数据格式间翻译数据的系统。

3)安全网关：安全网关是各种技术的融合，具有重要且独特的保护作用，其范围从协议级过滤到十分复杂的应用级过滤。

2.作用功能不同：网关分为传输型网关和应用型网关两类， 主要作用是充当转换（指的是协议、数据等转换）重任，实质上是一个网络通向其他网络的IP地址；路由器（不能转换协议数据等）的作用主要是连通不同的网络和信息传输作用。路由器（Router）利用不同网络的ID号（IP地址，又称为网络地址、协议地址）来确定数据转发的目的地址。路由器通过IP地址将连接到其端口的设备划分为不同的网络（子网），每个端口下连接的网络即为一个广播域，广播数据不会扩散到该端口以外，因此我们说路由器隔离了广播域。路由器 ，一边连接外部局域网，一边做总共头，分配本地局域网的 ip地址分配，基本全能，路由器在广域网的连接，通过 OSPF路由协议。

#### 集线器和交换机

集线器（Hub）设备不能识别MAC地址和IP地址，对接收到的数据以广播的形式发送，它的所有端口为一个冲突域同时也为一个广播域，HUB，也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。
交换机(Switch) 通过查找MAC地址表将接收到的数据传送到目的端口，可以分割冲突域，它的每一个端口相应的称为一个冲突域。
交换机虽然能够分割冲突域，但是交换机下连接的设备依然在一个广播域中，当交换机收到广播数据包时，会在所有的设备中进行传播，在一些情况下会导致网络拥塞以及安全隐患，而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的是共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径 ，可以说一般情况下个人用户需求不大。

路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，并不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。

不同网段在没有VLAN隔离情况下的互相干扰，一方面干扰大，资源浪费；另一方面也不安全，完全可以用ARP Spoofing欺骗另一个网段的主机，实现流量黑洞。
将一台物理交换机逻辑分割成多个虚拟交换机vSwitch（对应一个VLAN），然后将客户PC的MAC地址放在一个容器内，这个容器就是VLAN，可以理解为划分成多个互不关联的虚拟的交换机。
VLAN划分是基于数据链路层进行划分，子网划分是基于网络层进行划分，技术层面而言这两种划分之间没有什么“联系”可言。

### ifconfig命令

```
ifconfig=interfaces config

命令格式：

ifconfig [网络设备][参数]

功能
查看和配置网络设备，当网络环境发生改变的时候可以通过该命令对网络进行相应的配置。

命令参数

up 启动相应的网络设备/网卡
down 关闭指定的网络设备/网卡
arp 设置指定网卡是都支持ARP协议
-promisc 设置是否支持网卡的promiscuous模式
-allmulti 设置是否支持多播模式，如果选择该参数，网卡将接受网络中所有的多播数据包
-a 显示全部接口信息
-s 显示摘要信息
add 给指定网卡配置ipv6地址
del 删除指定网卡的ipv6地址
mtu<字节数> 设置网卡的最大传输单元
netmask<子网掩码> 设置网卡的子网掩码
tunel 建立隧道
dsaddr 设定一个远端地址，建立点对点通信
-broadcst<地址> 为指定网卡设置广播协议
-pointtopoint<地址> 为网卡设置点对点通讯协议
multicast 为网卡设置组播标识
address 为网卡设置IPV4地址
使用实例
查看设备信息


第一行：连接类型：以太网 硬件地址即MAC地址：…
第二行：inet 地址表示网卡的IP地址：10.211.55.5
广播地址：10.211.55.255
子网掩码：255.255.255.0
第六行：网卡的状态 UP:网卡处于开启状态 RUNNING：网卡的网线被插上 MULTICAST：允许组播 MTU=1500：最大传输单元1500字节
关闭开启网卡

sudo ifconfig eth1 down



sudo ifconfig eth1 down



删除/添加ipv6地址

sudo ifconfig eth1 del/add ipv6-addr

before

after

修改MAC地址

sudo ifconfig eth1 hw ether MAC_ADDR


修改IP地址

sudo ifconfig eth1 IP_ADDR netmask ADDR broadcasr ADDR


其他操作

关闭或启动arp协议

ifconfig eth1 arp
ifconfig eth1 -arp

设置最大传输单元

ifconfig eth1 mtu 1500

Note:用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了

```



```
直接执行：#setup 
然后会弹出选项窗口，设置一下就可以了

或者修改配置文件

/etc/sysconfig/network-scripts/ 下有配置文件  （不是ubuntu的）

比如文件：ifcfg-eth0  代表是以太网实际网卡0的配置文件

比如文件：ifcfg-eth0:1  代表是以太网实际网卡0的配置文件

域名服务器配置文件：/etc/ resolv.conf

修改ip地址
即时生效:
# ifconfig eth0 192.168.0.20 netmask 255.255.255.0
启动生效:
修改/etc/sysconfig/network-scripts/ifcfg-eth0

修改default gateway
即时生效:
# route add default gw 192.168.0.254
启动生效:
修改/etc/sysconfig/network-scripts/ifcfg-eth0

修改dns
修改/etc/resolv.conf
修改后可即时生效，启动同样有效

修改host name
即时生效:
# hostname fc2
启动生效:
修改/etc/sysconfig/network

无论是Linux 自动安装还是我们手工安装，Linux 都会向你询问有关网络的问题并配置相关的软件。这个用于配置网卡的基本命令就是ifconfig。
在执行ifconfig 命令后，系统将在内核表中设置必要的参数，这样Linux 就知道如何与网络上的网卡通
信。ifconfig 命令有以下两种格式：
※ifconfig [interface]
※ifconfig interface [aftype] option | address …
ifconfig 的第一种格式（或使用不带任何参数的ifconfig 命令）可以用来查看当前系统的网络配置情况。
在刚刚安装完系统之后，实际上是在没有网卡或者网络连接的情况下使用Linux，但通过ifconfig 可以使用回绕方式工作，使计算机认为自己工作在网络上。
现在我们运行一下ifconfig 命令，不带参数的ifconfig 命令可以显示当前启动的网络接口，其输出结果
为：
-----------------------------------------------------------
[root@machine1 /sbin]#ifconfig
eth0 Link encap:Ethernet Hwaddr 52:54:AB:DD:6F:61
inet addr:210.34.6.89 Bcast:210.34.6.127 Mask:255.255.255.128
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:46299 errors:0 dropped:0 overruns:0 frame:189
TX packets:3057 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:100
Interrupt:5 Base address:0xece0
lo Link encap:Local Loopback
inet addr:127.0.0.1 Mask:255.0.0.0
UP LOOPBACK RUNNING MTU:3924 Metric:1
RX packets:44 errors:0 dropped:0 overruns:0 frame:0
TX packets:44 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
--------------------------------------------------------------------
其中以eth0 为首的部分是本机的以太网卡配置参数，这里显示了网卡在下的设备名/dev/eth0 和硬件的MAC 地址52:54:AB:DD:6F:61，MAC 地址是生产厂家定的，每个网卡拥有的唯一地址。
不过我们可以手工改动网卡的MAC 地址，只要我们在/etc/rc.d/init.d/中的network 中加入：
ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx
然后重启，此时再用ifconfig 命令查看一下，我们就会发现网卡的MAC 地址已经变成xx:xx:xx:xx:xx:xx
了。
下一行显示本机的IP 地址信息，分别是本机的IP 地址，网络广播地址和子网掩码。必须确认这些信息都是正确无误的，否则Linux 服务器无法与其它网络设备建立连接。我们也可以手工实现IP 与Mac 地址的
捆绑，命令是
arp -i eth0 -s xxx.xxx.xxx.xxx(IP) xx.xx.xx.xx.xx(MAC)
接下来显示的是设备的网络状态。MTU（最大传输单元）和Metric（度量值）字段显示的是该接口当前的
M T U 和度量值的值。按照惯例，度量值供某些操作系统所用，用于计算一条路由的成本。
再下来显示接口通信的网络统计值。RX 和TX 分别表示接收和传送的数据包。如果你的网卡已经完成配置却还是无法与其它设备通信，那么从RX 和TX 的显示数据上可以简单地分析一下故障原因。在这种情况下，如果你看到接收和传送的包的计数(packets)增加，那有可能是系统的IP 地址出现了混乱；如果你看到大量的错误(errors)和冲突(Collisions)，那么这很有可能是网络的传输介质出了问题，例如网线不通或hub损坏。
再下面的Interrupt:5 Base address:0xece0 显示的是网卡的中断调用号和端口号，这是两个非常重要的硬件配置信息。如果您的网卡是PCI 的，那么Linux 在引导时有可能会自动配置这些信息（也很有可能会让您手工配置）但目前绝大多数网卡都是PnP 的，这就需要我们进行手工配置了。如果您的网卡还没有
配置好，那么运行：
[root@machine1 /sbin]#ifconfig
系统只会输出以lo 为首的部分。lo 是look-back 网络接口，从IP 地址127.0.0.1 就可以看出，它代表"本机"。无论系统是否接入网络，这个设备总是存在的，除非你在内核编译的时候禁止了网络支持，这是一个称为回送设备的特殊设备，它自动由Linux 配置以提供网络的自身连接。IP 地址127.0.0.1 是一个特殊的回送地址（即默认的本机地址），您可以在自己的系统上用telnet 对IP 地址127.0.0.1 进行测试。如果有inetd进程在运行的话您会从自己的机器上获得登录提示符。Linux 可以利用这个特征在进程与仿真网络之间进行通信。（您有兴趣的话还可以试试本机的实际IP 地址，如这里的机器就是210.34.6.89，或者试试"localhost"，或者"127.0.0.1"，同样可以模拟网络通信。这可是Linux 一个非常突出的优点！）
如果你只是关心某个设备是否正常，可以在ifconfig 后面加上接口名字：
[root@machine1 /sbin]# ifconfig eth0
eth0 Link encap:Ethernet HWaddr 52:54:AB:DD:6F:61
inet addr:210.34.6.89 Bcast:210.34.6.127 Mask:255.255.255.128
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:50568 errors:0 dropped:0 overruns:0 frame:198
TX packets:3200 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:100
Interrupt:5 Base address:0xece0
表示eth0 设备已经正常工作。
有时需要为某个设备接口配置多个IP 地址，办法是使用设备别名，例如，eth0 设备可以有eth0，eth0:0，
eth0:1....多个别名，每个都可以有一个独立的IP 地址：
ifconfig eth0 210.34.6.89 netmask 255.255.255.128 broadcast 210.34.6.127
ifconfig eth0:0 210.34.6.88 netmask 255.255.255.128 broadcast 210.34.6.127
这样，210.34.6.89 和210.34.6.88 都会被绑定在eth0 设备上，使用同样的网络设备，不同的IP 地址。
如果你要暂停某个网络接口的工作，使用down 参数：
ifconfig eth0 down
将取消eth0 网络接口。与之对应的是有一个参数up，不过由于是缺省值，所以从来不用。
如果我们使用了带有参数的ifconfig 命令，那就可以手动设置网卡的配置参数了。有效的ifconfig 命令参数及其意义为(选项对应的特性可以打开也可以取消，只在选项名前加一个破折号（-）即可)：
Interface 网络设备名，如eth0 就表示本机的第一块网卡。
up 标志接口处于" up"状态，也就是说， IP 层可以对其进行访问。这个选项用于命令行上给出一个地址之时。如果这个接口已被" down"选项临时性取消的话（与该选项对应的标记是UP RUNNING），还可以用于重新启用一个接口。down 标标志接口处于" down"状态，也就是说， IP 层不能对其进行访问。这个选项有效地禁止了IP 通信流通这个接口。注意，它并没有自动删除利用该接口的所有路由信息。如果永久性地取消了一个接口，就应该删除这些路由条目，并在可能的情况下，提供备用路由。
netmask 标分配子网掩码，供接口所用。要么给一个前面是0x 的32 位十六进制号码，要么采用只适用于两台主机所用的点分四段式号码。对SLIP 和PLIP 接口来说，这个选项是必须配置的。
address 设置指定接口设备的IP 地址。
dstaddr adderss 为PPP 设置远程IP 地址，此关键字可用pointopoint 代替。
irqaddress 设置指定接口设备使用的中断行。
pointtopoint address 该选项用于只涉及两台主机的点到点链接。对SLIP 和PLIP 接口来说，这个选项是必须配置的（如果已经设置了一个点到点地址，ifconfig 就会显示出POINTTPOINT 标记）。
broadcast address 广播地址通常源于网络编号，通过设置主机部分的所有位得来。有的I P 采用的方案有所不同：这个选项可适用于某些奇怪的环境（如果已经设置了广播地址， ifconfig 就会显示出一个BROADCAST 标记）。hw class addr 设置指定接口设备的MAC 地址，关键字的后面必须跟硬件名或者与之等价的ASCII码。目前支持的硬件类有ether, ax25, ARCnet 和netrom。
metric number 该选项可用于为接口创建的路由表分配度量值。路由信息协议（ RIP）利用度量值来构建
网络路由表。ifconfig 所用的默认度量值是0。如果不运行RIP 程序，就没必要采用这个选项。如果要运行RIP 程序，就尽量不要改变这个默认的度量值。
mtu bytes 该选项用于设置最大传输单元，也就是接口一次能处理的最大字节数。对以太网接口来说， MTU的默认设置是1500 个字节；对SLIP 接口来说，则是296 个字节。
arp 标这个选项专用于以太网或包广播之类的广播网络。它启用ARP（地址解析协议）来保护网络上各台
主机的物理地址。对广播网来说，默认设置是" on"（开）。
promisc 将接口置入promiscuous（混乱）模式。广播网中，这样将导致该接口接收所有的数据包，不管其目标是不是另一台主机。该选项允许利用包过滤器和所谓的以太网窥视技术，对网络通信进行分析。通常情况下，这对揪出网络故障的元凶来说，是相当有用的。但另一方面，如果有人蓄意攻击你的网络，也可浏览到s 通信数据，进而获得密码，破坏你的网络。一项重要的保证措施是杜绝任何人将他们的计算机接入你的以太网。另一个选项用于保护某些身份验证协议的安全，比如Kerberos 或SRA 登录套件（该选项对应的标记是PROMISC）。
traIlers 开或关闭跟踪器。目前在某些Linux 系统中还无法实现此功能。
allmulti 多播地址即是向不在同一个子网上的一组主机广播数据。多播地址尚未获得内核支持（该选项对应的标记是ALLMULTI）txqueuelen len 设置指定接口设备的发送队列长度。
由此可以看出有大量的参数可用于配置网卡，下面是在这台计算机上使用ifconfig 命令的实例：
------------------------------------------------------------------------------
ifconfig eth0 210.34.6.89 netmask 255.255.255.128 broadcast 210.34.6.127
------------------------------------------------------------------------------
该命令的作用是设置网卡eth0 的IP 地址，网络掩码和网络的本地广播地址。同样的方式可以用来配置eth1，eth2 等等，通常netmask 和broadcast 只要设置一个就可以了。

路由器配置命令
计算机命令
~~~~~~~~~~ 
PCA login: root                                     ；使用root用户
password: linux                                    ；口令是linux
# shutdown -h now                                   ；关机
# init 0                                            ；关机
# logout
# login
# ifconfig                                          ；显示IP地址
# ifconfig eth0 netmask       ；设置IP地址
# ifconfig eht0 netmask down ; 删除IP地址
# route add 0.0.0.0 gw 
# route del 0.0.0.0 gw 
# route add default gw                          ；设置网关
# route del default gw                          ；删除网关
# route                                             ；显示网关
# ping 
# telnet                                        ；建议telnet之前先ping一下

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
交换机命令
~~~~~~~~~~
[Quidway]super password                             修改特权用户密码
[Quidway]sysname                             交换机命名 
[Quidway]interface ethernet 0/1                     进入接口视图
[Quidway]interface vlan x                     进入接口视图
[Quidway-Vlan-interfacex]ip address 10.65.1.1 255.255.0.0
[Quidway]ip route-static 0.0.0.0 0.0.0.0 10.65.1.2  静态路由＝网关

[Quidway]user-interface vty 0 4
[S3026-ui-vty0-4]authentication-mode password
[S3026-ui-vty0-4]set authentication-mode password simple 222
[S3026-ui-vty0-4]user privilege level 3

[Quidway-Ethernet0/1]duplex {half|full|auto}        配置端口双工工作状态
[Quidway-Ethernet0/1]speed {10|100|auto}        配置端口工作速率
[Quidway-Ethernet0/1]flow-control              配置端口流控
[Quidway-Ethernet0/1]mdi {across|auto|normal}       配置端口MDI/MDIX状态平接或扭接
[Quidway-Ethernet0/1]port link-type {trunk|access|hybrid} 设置接口工作模式
[Quidway-Ethernet0/1]shutdown             关闭/重起接口
[Quidway-Ethernet0/2]quit                     退出系统视图

[Quidway]vlan 3                             创建/删除一个VLAN/进入VLAN模式
[Quidway-vlan3]port ethernet 0/1 to ethernet 0/4    在当前VLAN增加/删除以太网接口
[Quidway-Ethernet0/2]port access vlan 3             将当前接口加入到指定VLAN
[Quidway-Ethernet0/2]port trunk permit vlan {ID|All}      设trunk允许的VLAN
[Quidway-Ethernet0/2]port trunk pvid vlan 3     设置trunk端口的PVID

[Quidway]monitor-port         指定和清除镜像端口
[Quidway]port mirror        指定和清除被镜像端口
[Quidway]port mirror int_list observing-port int_type int_num 指定镜像和被镜像

[Quidway]description string                         指定VLAN描述字符
[Quidway]description                           删除VLAN描述字符
[Quidway]display vlan [vlan_id]                     查看VLAN设置

[Quidway]stp {enable|disable}                       开启/关闭生成树,默认关闭
[Quidway]stp priority 4096                          设置交换机的优先级
[Quidway]stp root {primary|secondary}               设置交换机为根或根的备份
[Quidway-Ethernet0/1]stp cost 200                   设置交换机端口的花费

[SwitchA-vlanx]isolate-user-vlan enable             设置主vlan
[SwitchA]Isolate-user-vlan secondary      设置主vlan包括的子vlan
[Quidway-Ethernet0/2]port hybrid pvid vlan      设置vlan的pvid
[Quidway-Ethernet0/2]port hybrid pvid               删除vlan的pvid
[Quidway-Ethernet0/2]port hybrid vlan vlan_id_list untagged 设置无标识的vlan  
如果包的vlan id与PVId一致，则去掉vlan信息. 默认PVID=1。
所以设置PVID为所属vlan id, 设置可以互通的vlan为untagged.
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
路由器命令
~~~~~~~~~~
[Quidway]display version                          显示版本信息
[Quidway]display current-configuration            显示当前配置
[Quidway]display interfaces                       显示接口信息
[Quidway]display ip route                         显示路由信息

[Quidway]sysname aabbcc                           更改主机名
[Quidway]super passwrod 123456                    设置口令  
[Quidway]interface serial0                        进入接口
[Quidway-serial0]ip address 
[Quidway-serial0]undo shutdown                    激活端口
[Quidway]link-protocol hdlc                       绑定hdlc协议
[Quidway]user-interface vty 0 4
[Quidway-ui-vty0-4]authentication-mode password
[Quidway-ui-vty0-4]set authentication-mode password simple 222
[Quidway-ui-vty0-4]user privilege level 3
[Quidway-ui-vty0-4]quit

[Quidway]debugging hdlc all serial0               显示所有信息
[Quidway]debugging hdlc event serial0             调试事件信息
[Quidway]debugging hdlc packet serial0            显示包的信息

静态路由：
[Quidway]ip route-static {interface number|nexthop}[value][reject|blackhole] 
例如：
[Quidway]ip route-static 129.1.0.0 16 10.0.0.2
[Quidway]ip route-static 129.1.0.0 255.255.0.0 10.0.0.2
[Quidway]ip route-static 129.1.0.0 16 Serial 2
[Quidway]ip route-static 0.0.0.0 0.0.0.0  10.0.0.2


动态路由：
[Quidway]rip
[Quidway]rip work
[Quidway]rip input
[Quidway]rip output
[Quidway-rip]network 1.0.0.0                       ;可以all
[Quidway-rip]network 2.0.0.0
[Quidway-rip]peer ip-address 
[Quidway-rip]summary 
[Quidway]rip version 1
[Quidway]rip version 2 multicast
[Quidway-Ethernet0]rip split-horizon             ;水平分隔

[Quidway]router id A.B.C.D                       配置路由器的ID
[Quidway]ospf enable                             启动OSPF协议
[Quidway-ospf]import-route direct                引入直联路由
[Quidway-Serial0]ospf enable area       配置OSPF区域


标准访问列表命令格式如下：
acl [match-order config|auto]       默认前者顺序匹配。
rule [normal|special]{permit|deny} [source source-addr source-wildcard|any]
例：
[Quidway]acl 10
[Quidway-acl-10]rule normal permit source 10.0.0.0 0.0.0.255
[Quidway-acl-10]rule normal deny source any


扩展访问控制列表配置命令

配置TCP/UDP协议的扩展访问列表：
rule {normal|special}{permit|deny}{tcp|udp}source {|any}destination |any}
[operate]

配置ICMP协议的扩展访问列表：
rule {normal|special}{permit|deny}icmp source {|any]destination {|any]
[icmp-code] [logging]

扩展访问控制列表操作符的含义
equal portnumber       等于
greater-than portnumber       大于
less-than portnumber       小于
not-equal portnumber       不等
range portnumber1 portnumber2 区间

扩展访问控制列表举例
[Quidway]acl 101
[Quidway-acl-101]rule deny souce any destination any
[Quidway-acl-101]rule permit icmp source any destination any icmp-type echo
[Quidway-acl-101]rule permit icmp source any destination any icmp-type echo-reply

[Quidway]acl 102
[Quidway-acl-102]rule permit ip source 10.0.0.1 0.0.0.0 destination 202.0.0.1 0.0.0.0
[Quidway-acl-102]rule deny ip source any destination any

[Quidway]acl 103
[Quidway-acl-103]rule permit tcp source any destination 10.0.0.1 0.0.0.0 destination-port equal ftp
[Quidway-acl-103]rule permit tcp source any destination 10.0.0.2 0.0.0.0 destination-port equal www


[Quidway]firewall enable
[Quidway]firewall default permit|deny
[Quidway]int e0
[Quidway-Ethernet0]firewall packet-filter 101 inbound|outbound


地址转换配置举例
[Quidway]firewall enable
[Quidway]firewall default permit 
[Quidway]acl 101
[Quidway-acl-101]rule deny ip source any destination any 
[Quidway-acl-101]rule permit ip source 129.38.1.4 0 destination any
[Quidway-acl-101]rule permit ip source 129.38.1.1 0 destination any
[Quidway-acl-101]rule permit ip source 129.38.1.2 0 destination any
[Quidway-acl-101]rule permit ip source 129.38.1.3 0 destination any
[Quidway]acl 102
[Quidway-acl-102]rule permit tcp source 202.39.2.3 0 destination 202.38.160.1 0
[Quidway-acl-102]rule permit tcp source any destination 202.38.160.1 0 destination-port great-than 
1024

[Quidway-Ethernet0]firewall packet-filter 101 inbound 
[Quidway-Serial0]firewall packet-filter 102 inbound

[Quidway]nat address-group 202.38.160.101 202.38.160.103 pool1
[Quidway]acl 1 
[Quidway-acl-1]rule permit source 10.110.10.0 0.0.0.255
[Quidway-acl-1]rule deny source any 
[Quidway-acl-1]int serial 0
[Quidway-Serial0]nat outbound 1 address-group pool1

[Quidway-Serial0]nat server global 202.38.160.101 inside 10.110.10.1 ftp tcp
[Quidway-Serial0]nat server global 202.38.160.102 inside 10.110.10.2 www tcp
[Quidway-Serial0]nat server global 202.38.160.102 8080 inside 10.110.10.3 www tcp
[Quidway-Serial0]nat server global 202.38.160.103 inside 10.110.10.4 smtp udp


PPP验证：
主验方：pap|chap
[Quidway]local-user u2 password {simple|cipher} aaa
[Quidway]interface serial 0
[Quidway-serial0]ppp authentication-mode {pap|chap}
[Quidway-serial0]ppp chap user u1        file://pap时，不用此句

pap被验方：
[Quidway]interface serial 0 
[Quidway-serial0]ppp pap local-user u2 password {simple|cipher} aaa

chap被验方：
[Quidway]interface serial 0 
[Quidway-serial0]ppp chap user u1        
[Quidway-serial0]local-user u2 password {simple|cipher} aaa


```



学习网站https://www.cnblogs.com/dotnetcrazy/p/9160514.html  

右键菜单https://blog.csdn.net/qq_25166683/article/details/81352868

## 参考手册网站https://www.php.cn/xiazai/shouce

eclipse:   java文件写在src目录下 （包 文件等） 编译生成的class文件在bin目录下    根目录下有.settings文件夹  .classpath 		 .project文件									 lib目录下放依赖的jar包

myeclipse:   java文件写在src目录下 （包 文件等）以及一些关于配置的文件比如struts.xml   src同目录WebRoot文件夹下放 META-INF文件夹 和网页文件以及WEB-INF文件夹（里面放classes(放编译后的class文件结构和src文件一样也包括配置文件)  src同目录下lib文件夹（放相关的依赖jar文件)以及web.xml）src同目录下JRE System Library放引入的项目的依赖库

例如：

<img src="笔记.assets/1604365285801.png" alt="1604365285801" style="zoom:67%;" />

IDEA :    java文件写在src目录下 （包 文件等）以及一些关于配置的文件比如struts.xml   编译生成的class文件在out目录下production下项目名目录下（自己设置的）    根目录下有.idea文件夹  项目名.imi文件  --也是依据自己设置的   用项目生成时默认的

例如：

<img src="笔记.assets/1604363734226.png" alt="1604363734226" style="zoom:50%;" />



 默认情况下，IDEA的 Modules 和 Artifacts 的 output目录已经设置好了，不需要更改，打成war包的时候会自动在 WEB-INF目录下生成classes，然后把编译后的文件放进去。     External Libraries里放依赖包  相当于Eclipse下的lib文件夹

win+r    wt进入windows terminal

cmd  wsl进入虚拟机 ubuntu 或者bash也可以进入

cmd code.打开vscode

cmd mstsc连接远程主机

cmd  cd 改变工作路径

1. 停掉mysql服务。

```
net stop mysql
```

2. **mysql -u root -p** 登录mysql数据库

DOS下【win+r】 ->  cmd  进入dos环境下采用命令行

netstat  -aon  |  findstr  8080   --查找占用端口的服务的pid（进程号）

taskkill -pid  进程号 -f         --通过taskkill 杀死占用端口的服务

tasklist | findstr 进程号    　　　-- 这样一般会出现 xxx.exe 的服务信息 

 netstat  -ano 或netstat -an | grep 8080 命令，可以查看哪个进程占用了8080和8009端口，找到占用端口软件的PID，然后在任务管理器找到对应PID的软件，关闭结束该进程即可。如果任务管理器中没有显示PID列，需要设置，查看---》选择列---》勾选“PID（进程标识符）” 

修改Tomcat的配置文件。
例如：C:/tomcat5.5.25/conf/server.xml
 <Connector port="8080" maxHttpHeaderSize="8192"
        maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
        enableLookups="false" redirectPort="8443" acceptCount="100"
        connectionTimeout="20000" disableUploadTimeout="true" />

Connector 节点，将port="8080"中的端口改为一个没有被占用的端口。

您可以下载bandizip便携版并在命令提示符中输入“more < BANDIZIP-PORTABLE-GL-64BIT.ZIP:Zone.Identifier”。 在文件名后面添加字符串“:Zone.Identifier”，让您可以在下面找到有关文件下载位置的信息。



![img](笔记.assets/more.png)

## Mysql

SQLServer:

https://jingyan.baidu.com/article/09ea3ede21258cc0afde3943.html  导入mdf文件

```
EXEC  sp_attach_db  @dbname  =  '你的数据库名',     

@filename1  =  'mdf文件路径（包缀名）',     

@filename2  =  'Ldf文件路径（包缀名）'
```

   如果没有安装mysql命令行的话，我们可以通过找到 mysqld所在的路径（复制mysqld.exe所在路径） 

软件连接时设置：Database Driver

Driver template:   要连接的数据库类型（Microsoft server 2005       mysql）

Driver name :  自定义的驱动名称  代码中连接数据库时使用

Connection Url(对应的数据库协议://。。。)：jdbc:sqlserver(/mysql)://localhost:<port>[;databaseName=<dbname>]   

User Name:

Password:

Driver JARS:  选择连接对应数据库的驱动

其中一般sqlserver端口为1433（管理员sa  在sqlserver软件连接时要选择本机的数据库sqlserver2008服务管理使用的账户：NT AUTHORITY\SYSTEM）  mysql端口为3306

配置文件中配置时写：

jdbc:sqlserver(/mysql)://localhost:<port>[;databaseName=<dbname>]   (?characterEncoding=UTF-8)

<img src="笔记.assets/1604366215022.png" alt="1604366215022" style="zoom:50%;" />

1. 使用cd切换到msyqld.exe路径下，然后输入mysql连接命令如下图

    

   **格式是：**

   **Mysql -P 端口号 -h mysql主机名\ip -u root （用户） -p**

   

   ![如何登录mysql？ cmd怎么连接mysql数据库](笔记.assets/3c42a5ea3e863048075e8b67c33104ebf7a752b0.png)

2. 5

   如果是命令行是mysql所在的本机

   而且用默认的端口 3306 直接输入 **mysql -u root -p** 即可

   

   ![如何登录mysql？ cmd怎么连接mysql数据库](笔记.assets/75af02324b18512cfdec8414ad334884cce349b0.png)

## IDEA

### 更换JDK后Java报错

——启动问题（Application Server was not connected before run configuration stop, reason: javax.manage）https://blog.csdn.net/whm18322394724/article/details/80290187

使用：https://blog.csdn.net/qq_36698956/article/details/86571425

### 关于Tomcat上部署struts错误：

一个或者多个筛选器启动出错      jar包可能有冲突  查找有冲突的jar包或者直接更改libs

显示log4j-core等文件不在classpath中 导入相关包到libs下 或者可以忽略 不影响项目部署

或者ERROR StatusLogger No Log4j 2 configuration file found.   要配置log4j相关文件  .xml .properties文件

Unable to find taglib [s] for URI: [/struts-tags]  如果用了struts2,必须导入一下5个包

freemarker-2.3.8.jar;     struts2-core-2.0.14.jar;    xwork-2.0.7.jar;     commons-logging-1.0.4.jar;   ognl-2.6.11.jar;       jar版本不一定非要这些，但必须要这2个jar     我的是少了freemarker和ognl    添加进去就好了或者可以 在WEB-INFO目录下，新建文件夹jstl_tld（也可以不建）； (2)将struts2-core-2.5.20.jar(或类似版本)中的struts-tags.tld用winrar解压出来，放于此目录。

如果问题没有解决，配置web.xml

```html
<jsp-config>    
    <taglib>        
    	<taglib-uri>/struts-tags</taglib-uri>        
    	<taglib-location>/WEB-INF/struts-tags.tld</taglib-location>    
    </taglib>
</jsp-config> 
```

 

 <%@ taglib prefix="s" uri="/struts-tags" %>就是从地址/struts-tags下面寻找标签库，它定义在Struts 2库文件struts2-core-2.0.11.jar里面的文件WEB-INF/lib/struts-tags.tld里面。

### 如何在局域网内访问Tomcat项目

Step 1，在开始菜单搜索框中输入“防火墙”，在出现的结果中选中“高级windows防火墙”；

　　![img](笔记.assets/20180616103411391.png)

　　Step 2，双击“入站规则”选项卡，右击之，选中“新建规则”；

　　![img](笔记.assets/20180616103406403.png)

　　Step 3，选中“端口”按钮，点选“下一步”；

　　Step 4，选择“TCP”按钮，在“特定本地端口”输入tomcat的端口，如8080，然后按“下一步”；

　　![img](笔记.assets/20180616103402331.png)

　　Step 5，接下来都是不断的按“下一步”，最后可以为你的规则取个名字，如下所示，点击“完成”；

　　![img](笔记.assets/20180616103358506.png)

　　Step 6，在浏览器输入"<hostname>:<port>"敲回车看看能否访问到tomcat项目，如：192.168.0.126:8080，访问成功，如下所示。

　　![img](笔记.assets/2018061610335423.png)

　　补充：如何看到你的本机IP（hostname要填的其实就是你的本机IP），在cmd下输入"ipconfig/all"即可：

　　![img](笔记.assets/20180616103331887.png)

 题外话

　　通过上面的设置之后，我们可以在局域网上共享tomcat项目了，只需输入"<hostname>:<port>/URI"即可，如192.168.0.126:8080/DSPMSU，但你是否感觉到每次都要输入资源名是不是非常的不方便？题外话中要说的是如何去掉资源名，直接通过<hostname>:<port>就可以共享tomcat项目。

　　方法有两种，但是都会带来同一个坏处，就是原先的tomcat主页访问不了，因为这两种方式的原理都是取代主页项目的位置。

　　1 文件夹替换法

　　Step 1，先把原先的ROOT文件夹更名，比如ROOT1；

　　Step 2，再把你的项目更名为ROOT，如"DSPMSU_For_Display"更名为"ROOT"；

　　Step 3，重启tomcat就行了。

　　![img](笔记.assets/20180616103326655.png)

　　2 修改conf/server.xml文件

　　打开你的tomcat/conf/server.xml文件，拉至文件底部，我们一般可以看到下面的信息，你只需把红框部分的"/DSPMSU"去掉即可通过<hostname>:<port>访问tomcat项目了，不需要在后面加资源名。

　　![img](笔记.assets/20180616103322705.png)

　　假如你的server.xml文件没有这一部分内容，那你可以在红框"</Host>"之前添加语句如下。

```html
　　<Context docBase="你的项目的绝对路径" path="" reloadable="[true|false，true表示一有改动自动republish]" source="[模仿上面的语句，表示你的项目在Eclipse中，可不填]" />
```

　　修改完server.xml文件后，别忘了重启你的tomcat。

### [IDEA中项目配置和部署](https://www.cnblogs.com/cmyBlog/p/10892898.html)

转自：https://www.cnblogs.com/deng-cc/p/6416332.html

https://blog.csdn.net/zyjustin9/article/details/84694361

控制台输出

日志信息一般分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。日志等级依次递增，即DEBUG（调试） < INFO（信息） < WARN（警告） < ERROR（错误） < FATAL（严重）

#### 1、项目配置的理解

IDEA 中最重要的各种设置项，就是这个 Project Structre 了，关乎你的项目运行，缺胳膊少腿都不行。最近公司正好也是用之前自己比较熟悉的IDEA而不是Eclipse，为了更深入理解和使用，就找来各种资料再研究一下，这里整理后来个输出。

![img](笔记.assets/1007017-20180608112951825-523459303.png)

##### 1.1 Project

![img](笔记.assets/1007017-20180608112952354-353366734.png)

1. **Project name**：定义项目的名称；
2. **Project SDK**：设置该项目使用的JDK，也可以在此处新添加其他版本的JDK；
3. **Project language level**：这个和JDK的类似，区别在于，假如你设置了JDK1.8，却只用到1.6的特性，那么这里可以设置语言等级为1.6，这个是限定项目编译检查时最低要求的JDK特性；
4. **Project compiler output**：项目中的默认编译输出总目录，如图黄色部分，实际上每个模块可以自己设置特殊的输出目录（Modules - (project) - Paths - Use module compile output path），所以这个设置有点鸡肋。

##### 1.2 Modules

![img](笔记.assets/1007017-20180608112953353-1760596858.png)

###### 1.2.1 增删子项目

![img](笔记.assets/1007017-20180608112954536-1174911571.png)

一个项目中可以有多个子项目，每个子项目相当于一个模块。一般我们项目只是单独的一个，IntelliJ IDEA 默认也是单子项目的形式，所以只需要配置一个模块。

（此处的两个项目引入仅作示例参考）

 ![img](笔记.assets/2059687-20201009180357306-1319694882.png) 

###### 1.2.2 子项目配置

每个子项目都对应了Sources、Paths、Dependencies 三大配置选项：

- **Sources**：显示项目的目录资源，那些是项目部署的时候需要的目录，不同颜色代表不同的类型；
- **Paths**：可以指定项目的编译输出目录，即项目类和测试类的编译输出地址（替换掉了Project的默认输出地址）
- **Dependencies**：项目的依赖

![img](笔记.assets/1007017-20180608112955842-1288884758.png)

![img](笔记.assets/1007017-20180608112957001-279554549.png)

![img](笔记.assets/1007017-20180608112957637-1700253389.png)

 

###### 1.2.3 增删框架（Web部署-1）

每个子项目之下都可以定义它所使用的框架，这里重点说明一下Web部分的设置。

![img](笔记.assets/1007017-20180608112959258-23352219.png)

##### 1.3 Libraries

这里可以显示所添加的jar包，同时也可以添加jar包，并且可以把多个jar放在一个组里面，类似于jar包整理。

这里默认将每个jar包做为了一个单独的组 https://blog.csdn.net/zyjustin9/article/details/84694197?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param 

##### 1.4 Facets

官方的解释是：

When you select a framework (a facet) in the element selector pane, the settings for the framework are shown in the right-hand part of the dialog.

（当你在左边选择面板点击某个技术框架，右边将会显示这个框架的一些设置）

说实话，并没有感觉到有什么作用。

##### 1.5 Artifacts（Web部署-2）

项目的打包部署设置，这个是项目配置里面比较关键的地方，重点说一下。

先理解下它的含义，来看看官方定义的artifacts：

An artifact is an assembly of your project assets that you put together to test, deploy or distribute your software solution or its part. Examples are a collection of compiled Java classes or a Java application packaged in a Java archive, a Web application as a directory structure or a Web application archive, etc.

即编译后的Java类，Web资源等的整合，用以测试、部署等工作。再白话一点，就是说某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式。某个module有了 Artifacts 就可以部署到应用服务器中了。

*（*

***jar**：Java ARchive，通常用于聚合大量的Java类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发Java平台应用软件或库；
*

***war**：Web application ARchive，一种JAR文件，其中包含用来分发的JSP、Java Servlet、Java类、XML文件、标签库、静态网页（HTML和相关文件），以及构成Web应用程序的其他资源；*

***exploded**：在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。*

*）*

默认情况下，IDEA的 Modules 和 Artifacts 的 output目录已经设置好了，不需要更改，打成war包的时候会自动在 WEB-INF目录下生成classes，然后把编译后的文件放进去。

![img](笔记.assets/1007017-20180608112959845-212548643.png)

你可能对这里的输出目录不太理解，之前不是配置过了文件编译的输出目录了吗？为什么这里还有一个整合这些资源的目录呢？它又做了哪些事呢？ 

其实，实际上，当你点击运行tomcat时，默认就开始做以下事情：

- 编译，IDEA在保存/自动保存后不会做编译，不像Eclipse的保存即编译，因此在运行server前会做一次编译。编译后class文件存放在指定的项目编译输出目录下（见1.2.2）；
- 根据artifact中的设定对目录结构进行创建；
- 拷贝web资源的根目录下的所有文件到artifact的目录下（见1.2.3）；
- 拷贝编译输出目录下的classes目录到artifact下的WEB-INF下（见1.2.2）；
- 拷贝lib目录下所需的jar包到artifact下的WEB_INF下；
- 运行server，运行成功后，如有需要，会自动打开浏览器访问指定url。

在这里还要注意的是，配置完成的artifact，需要在tomcat中进行添加：

![img](笔记.assets/1007017-20180608113001088-1619262130.png)

#### 2、参考链接

- [IntelliJ IDEA 项目相关的几个重要概念介绍](http://whudoc.qiniudn.com/2016/IntelliJ-IDEA-Tutorial/project-composition-introduce.html)
- [Dependencies Tab](https://www.jetbrains.com/help/idea/2016.3/dependencies-tab.html?search=project structure)
- [Facet Page](https://www.jetbrains.com/help/idea/2016.3/facet-page.html?search=project structure)
- [Working with Artifacts](https://www.jetbrains.com/help/idea/2016.3/working-with-artifacts.html#artifact_def)
- [Intellij IDEA 14.x 中的Facets和Artifacts的区别](http://www.cnblogs.com/52php/p/5677661.html)
- [IntelliJ使用指南—— 深入理解IntelliJ的Web部署逻辑](http://white-crucifix.iteye.com/blog/2070830)
- [IntelliJ IDEA WEB项目的部署配置](https://my.oschina.net/lujianing/blog/186737)



这里涉及到 IntelliJ Idea 的一个概念，Facet。如果注意观察的话，应该发现了，它就在 Project Structure 栏目里 Project、Modules、Libraries下面那一个，它的作用就是配置项目框架类支持。

比如我们现在要开发的是一个 web 项目，那就需要 web 相关的 Facet，事实上，如果没有这个配置支持，编译器也不知道这个项目是个 web 项目，也就不会去读取 web.xml 的配置，更无法被 tomcat 这种容器支持。

Facet 是和 Module 紧密结合的，你如果是在 Module 里配置了，那么 Facet 里边也会出现，而如果你先在 Facet 里配置，它会要求你选择 Module，所以结果是一致的。

再就是解释下 Artifacts，它的作用是整合编译后的 java 文件，资源文件等，有不同的整合方式，比如war、jar、war exploded 等，对于 Module 而言，有了 Artifact 就可以部署到 web 容器中了。其中 war 和 war exploded 区别就是后者不压缩，开发时选后者便于看到修改文件后的效果。

谈到 Artifacts，就得说一下几个输出目录的问题，，Project 选项里有一个 Project compilerc output 目录，这个是整个 Project 的编译输出目录；Modules 的具体单个 Module 的 Path 选项里有个 Compiler output，可以选择继承 Project 或者自定义输出目录，如下图所示：

 

![img](笔记.assets/1310641-20180709162714967-1666040305.png)

 

 

然后就是 Artifacts 也有一个 Output Directory，这几个的关系是怎样的呢？

 

![img](笔记.assets/1310641-20180709162759661-206749442.png)

 

 

**前两者的关系好理解，就是一个总体和个体配置的关系。而 Artifacts 里的输出目录是跟容器有关系的，在容器运行的时候，会把前两者中起作用的那个（个体配置优先）的 classes 文件复制到 Artifacts 配置的目录的 WEB-INF下边，然后把 Module 的 Facet 里的资源文件目录复制到 Artifacts 目录里，再就是复制 lib 下的 jar 包到 WEB-INF 下，之后项目就可以启动了。**

## 编译

![img](笔记.assets/CM_[[[00`BZJK]{}ZCTMYY1.jpg) 

## 端口

![1609223140982](笔记.assets/1609223140982.png)

![1609223165975](笔记.assets/1609223165975.png)

![1609223322853](笔记.assets/1609223322853.png)![1609223339688](笔记.assets/1609223339688.png)

 <img src="笔记.assets/1609238605951.png" alt="1609238605951" style="zoom: 33%;" /><img src="笔记.assets/1609240806153.png" alt="1609240806153" style="zoom:40%;" />

1.进入dos界面 输入：netstat -aon|findstr “8080” 得到占用这个端口的PID 
2.使用taskkill /pid .这时候就可以结束这个进程，即释放了这个端口就不会冲突了。（这个注意使用，可以先看看是什么进程在占用。不要结束了自己重要的进程） 

cmd:    ipconfig/all查看网络相关

![1608455951519](笔记.assets/1608455951519.png)

## Mysql

 mysql启动时发生系统错误  5  拒绝访问是因为权限不够，所以需要用管理员权限
方法：
在win10搜索框输入cmd有命令提示符，不直接点进去，鼠标右击以管理员权限打开dos命令黑窗口，然后输入命令：net start mysql2(mysql2是自己起的mysql的名字)，接着输入:mysql -uroot -p    回车，输入自己设置的数据库密码就可以进入数据库，链接自己的Navicate操作数据库了！ 

-------否则cmd管理员运行

net start mysql  启动Mysql服务

net  stop mysql 关闭Mysql服务

## 字符编码

http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

https://blog.csdn.net/zhanghuaichao/article/details/77862037

## JAVAEE

### foreach标签

### [forEach标签的常用属性](https://www.cnblogs.com/wjn563/p/4359633.html)

 今天总结了一下forEach标签里面的常用属性

<c:forEach items="${wekList}" var="list" varStatus="t" step="1">

      <a>${list.title}</a>

</c:forEach>

获取<c:forEach的长度： var len+ = parseInt('${fn:length(wekList)}');

<c:forEach>标签具有以下一些属性：     

var：迭代参数的名称。在迭代体中可以使用的变量的名称，用来表示每一个迭代变量。类型为String。  

items：要进行迭代的集合。对于它所支持的类型将在下面进行讲解。   

varStatus：迭代变量的名称，用来表示迭代的状态，可以访问到迭代自身的信息。   

begin：如果指定了items，那么迭代就从items[begin]开始进行迭代；如果没有指定items，那么就从begin开始迭代。它的类型为整数。   

end：如果指定了items，那么就在items[end]结束迭代；如果没有指定items，那么就在end结束迭代。它的类型也为整数。   

step：迭代的步长。

current：当前这次迭代的（集合中的）项。   

index：当前这次迭代从0开始的迭代索引。   

count：当前这次迭代从1开始的迭代计数。   

first：用来表明当前这轮迭代是否为第一次迭代，该属性为boolean类型。   

last：用来表明当前这轮迭代是否为最后一次迭代，该属性为boolean类型。   

begin：begin属性的值。   

end：end属性的值   

step：step属性的值 

#### [jstl的if标签和forEach标签的解析](https://www.cnblogs.com/yangxiao-/p/12005046.html)



### 接口反射机制

https://www.cnblogs.com/whgk/p/6122036.html

![1607001398834](笔记.assets/1607001398834.png)

下面是转自[c语言中文网](http://c.biancheng.net/cpp/html/1427.html)的正则表达式元字符及其使用方法一览表:

| 字符          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| \             | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 后向引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(“。 |
| ^             | 匹配输入字符串的开始位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 |
| $             | 匹配输入字符串的结束位置。如果设置了**RegExp** 对象的 **Multiline** 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 |
| *             | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。 * 等价于{0,}。 |
| +             | 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 |
| ?             | 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 |
| {*n*}         | *n* 是一个非负整数。匹配确定的 *n* 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 |
| {*n*,}        | *n* 是一个非负整数。至少匹配*n* 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 |
| {*n*,*m*}     | *m* 和 *n* 均为非负整数，其中*n* <= *m*。最少匹配 *n* 次且最多匹配 *m* 次。刘， “o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 |
| ?             | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {*n*}, {*n*,}, {*n*,*m*}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 |
| .             | 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 |
| (*pattern*)   | 匹配*pattern* 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 **SubMatches** 集合，在Visual Basic Scripting Edition 中则使用 **0…0…9** 属性。要匹配圆括号字符，请使用 ‘′或‘′或‘’。 |
| (?:*pattern*) | 匹配 *pattern* 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\|ies) 就是一个比 ‘industry\|industries’ 更简略的表达式。 |
| (?=*pattern*) | 正向预查，在任何匹配 *pattern* 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， ‘Windows (?=95\|98\|NT\|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!*pattern*) | 负向预查，在任何不匹配Negative lookahead matches the search string at any point where a string not matching *pattern* 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95\|98\|NT\|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
| *x*\|*y*      | 匹配 *x* 或 *y*。例如，’z\|food’ 能匹配 “z” 或 “food”。’(z\|f)ood’ 则匹配 “zood” 或 “food”。 |
| [*xyz*]       | 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 |
| [^*xyz*]      | 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。 |
| [*a-z*]       | 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 |
| [^*a-z*]      | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 |
| \b            | 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 |
| \B            | 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 |
| \c*x*         | 匹配由*x*指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。 *x* 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 |
| \d            | 匹配一个数字字符。等价于 [0-9]。                             |
| \D            | 匹配一个非数字字符。等价于 [^0-9]。                          |
| \f            | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n            | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r            | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s            | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S            | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t            | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v            | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |
| \w            | 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。         |
| \W            | 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。                 |
| \x*n*         | 匹配 *n*，其中 *n* 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， ‘\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ & “1”。正则表达式中可以使用 ASCII 编码。. |
| \num          | 匹配 *num*，其中 *num* 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 |
| \n            | 标识一个八进制转义值或一个后向引用。如果 \*n* 之前至少 *n* 个获取的子表达式，则 *n* 为后向引用。否则，如果 *n* 为八进制数字 (0-7)，则 *n* 为一个八进制转义值。 |
| \nm           | 标识一个八进制转义值或一个后向引用。如果 \*nm* 之前至少有is preceded by at least *nm* 个获取得子表达式，则 *nm* 为后向引用。如果 \*nm* 之前至少有 *n* 个获取，则 *n* 为一个后跟文字 *m* 的后向引用。如果前面的条件都不满足，若 *n* 和 *m* 均为八进制数字 (0-7)，则 \*nm* 将匹配八进制转义值 *nm*。 |
| \nml          | 如果 *n* 为八进制数字 (0-3)，且 *m* 和 *l* 均为八进制数字 (0-7)，则匹配八进制转义值 *nml。* |
| \u*n*         | 匹配 *n*，其中 *n* 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |

###  java向文件中读写内容

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package shi;

import java.io.*;

public class wenjianIO {
    public static void main(String agrs[]){
        FileInputStream fis=null;
        FileOutputStream fos=null;
        File f=new File("F:/test/javakc.txt");
        
        try {
//            向文件中写内容
            fos=new FileOutputStream(f);
            String s="你的小EZ,有走歪了";
            byte[]b=s.getBytes();
            fos.write(b);
            
//            向文件中读取内容
            fis=new FileInputStream(f);
            byte[]b2=new byte[(int) f.length()];
            fis.read(b2);
            String str=new String (b2);
            System.out.println(str);
            
            
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        finally{
            if(fis!=null){
                try{
                    fos.close();
                    fis.close();
                    
                }
                catch(IOException e){
                    e.printStackTrace();
                }
            }
        } 
    }
}


int lineDel=4;
BufferedReader br=new BufferedReader(new FileReader( "c:/a.txt "));
StringBuffer sb=new StringBuffer(4096);
String temp=null;
int line=0;
while((temp=br.readLine())!=null){
line++;
if(line==lineDel) continue;
sb.append(temp).append( "\r\n ");
}
br.close();
BufferedWriter bw=new BufferedWriter(new FileWriter( "c:/a.txt "));
bw.write(sb.toString());
bw.close();
```

### [ 从文件路径中获取文件名的各种方法](https://www.cnblogs.com/bear-sky/articles/2478450.html)

sendRedirect()是在用户的浏览器端工作，同时它可以重定向至不同的主机上，sendRedirect()可以重定向有frame的jsp文件。
假设转发代码包含于注册的servlet－url为/ggg/tt；jsp为/ggg/tt.jsp。
绝对路径：response.sendRedirect("http://www.brainysoftware.com")发送至http://www.brainysoftware.com
根路径：response.sendRedirect("/ooo")发送至http://localhost:8080/ooo
相对路径：response.sendRedirect("ooo")发送至http://localhost:8080/Test/ggg/ooo。 



 forward()无法重定向至有frame的jsp文件,可以重定向至有frame的html文件,
只有在客户端没有输出时才可以调用forward方法。如果当前页面的缓冲区（buffer）不是空的，那么你在调用forward方法前必须先清空缓冲区。
"/"代表相对与web应用路径 
RequestDispatcher rd = request.getRequestDispatcher("/ooo");
rd.forward(request, response);提交至http://localhost:8080/Test/ooo

RequestDispatcher rd = getServletContext().getRequestDispatcher("/ooo");
rd.forward(request, response);提交至http://localhost:8080/Test/ooo

RequestDispatcher rd =getServletContext().getNamedDispatcher("TestServlet");（TestServlet为一个<servlet-name>）
rd.forward(request, response);提交至名为TestServlet的servlet 

#### js获取文件文件名  带扩展

```
function getFileName(path){
var pos1 = path.lastIndexOf('/');
var pos2 = path.lastIndexOf('\\');
var pos = Math.max(pos1, pos2)
if( pos<0 )
return path;
else
return path.substring(pos+1);
}

function popFileName()
{
var path = document.getElementById("file").value;
alert(path+";---;"+getFileName(path));
}
获取后缀：
//文件路径
var filePath = "file:///storage/emulated/0/opmark/User/Pic/hangge.png";
//获取最后一个.的位置
var index= filePath.lastIndexOf(".");
//获取后缀
var ext = filePath.substr(index+1);
//输出结果
console.log(ext);
```

#### Java获取文件文件名

1.用 System.IO.Path 轻松获取文件的标识符和扩展名

string fullPath = @"\WebSite1\Default.aspx";

string filename = System.IO.Path.GetFileName(fullPath);//文件名 “Default.aspx”
string extension = System.IO.Path.GetExtension(fullPath);//扩展名 “.aspx”
string fileNameWithoutExtension = System.IO.Path.GetFileNameWithoutExtension(fullPath);// 没有扩展名的文件名 “Default”

 

2.用Substring截取

string str=@"F:\Documents and Settings\WXZ\My Documents\千千all.ttp";
 int s = str.LastIndexOf("\\")+1;
 int e = str.IndexOf(".");
 Console.WriteLine(str.Substring(s,e-s));

3.//获取当前进程的完整路径，包含文件名(进程名)。
string str = this.GetType().Assembly.Location;
result: X:\xxx\xxx\xxx.exe (.exe文件所在的目录+.exe文件名)

//获取新的 Process 组件并将其与当前活动的进程关联的主模块的完整路径，包含文件名(进程名)。
string str = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
result: X:\xxx\xxx\xxx.exe (.exe文件所在的目录+.exe文件名)

//获取和设置当前目录（即该进程从中启动的目录）的完全限定路径。
string str = System.Environment.CurrentDirectory;
result: X:\xxx\xxx (.exe文件所在的目录)

//获取当前 Thread 的当前应用程序域的基目录，它由程序集冲突解决程序用来探测程序集。
string str = System.AppDomain.CurrentDomain.BaseDirectory;
result: X:\xxx\xxx\ (.exe文件所在的目录+"")

//获取和设置包含该应用程序的目录的名称。
string str = System.AppDomain.CurrentDomain.SetupInformation.ApplicationBase;
result: X:\xxx\xxx\ (.exe文件所在的目录+"")

//获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。
string str = System.Windows.Forms.Application.StartupPath;
result: X:\xxx\xxx (.exe文件所在的目录)

//获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。
string str = System.Windows.Forms.Application.ExecutablePath;
result: X:\xxx\xxx\xxx.exe (.exe文件所在的目录+.exe文件名)

//获取应用程序的当前工作目录(不可靠)。
string str = System.IO.Directory.GetCurrentDirectory();
result: X:\xxx\xxx (.exe文件所在的目录) 

### 文件上传保存到服务器

https://blog.csdn.net/qq_34469943/article/details/69945158?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control

https://blog.csdn.net/tajiaowm/article/details/83624681

https://blog.csdn.net/zhyzh134/article/details/50961845?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control

### 内嵌iframe跳转

 表单提交，是要刷新页面的。。但是在和表单的同一个页面里面有个iframe，给iframe一个name属性值为a，form给个target属性值为a，当表单提交的时候刷新的只是iframe而不是整个页面，这样就可以实现form表单提交的不刷新页面效果。。。至于怎么拿到后台的数据，我是通过js定期循环判断对应设定的cookie有没有改变来确定的，额，通过这个方案我就做出了纯js的不刷新的文件上传功能了。。。
不过说了这么多，还是建议用ajax提交表单。。
用用jq的ajax，就是那些$.get和$.post，就明白怎么发数据和接收数据了。。 

### jsp页面自动跳转

 JSP中实现在某页面停留若干秒后,自动重定向到另一页面
　　在html文件中，下面的代码：
　　＜meta http-equiv="refresh" content="300; url=target.jsp"＞
　　它的含义：在5分钟之后正在浏览的页面将会自动变为target.html这一页。代码中300为刷新的延迟时间，以秒为单位。targer.html为你想转向的目标页,若为本页则为自动刷新本页。
　　可以通过setHeader来实现某页面停留若干秒后,自动重定向到另一页面。代码：
　　String content=stayTime+";URL="+URL;
　　response.setHeader("REFRESH",content); 

 <body> <jsp:forward page="/buyer/index.do"/> </body> 

1.用window.location.href，让页面加载时自动运行js
<script language="JavaScript">
 window.location.href = '../../learner/jsp/authenticate.jsp';
</script>

2.response.sendRedirect
jsp页面中可用response.sendRedirect()直接实现重定位

\3. ＜jsp:forward page="" /＞
　　它的底层部分是由RequestDispatcher来实现的，因此它带有RequestDispatcher.forward()方法的印记。
4.让a标签自动跳转
 <a href="http://elearning.com"%3E%3C/a>
<script language="JavaScript">
var comment = document.getElementsByTagName('a')[0];
if (document.all) {
 // For IE
comment.click();
}else if (document.createEvent) {
  //FOR DOM2
 var ev = document.createEvent('MouseEvents');
 ev.initEvent('click', false, true);
 comment.dispatchEvent(ev);
}
</script>

### 路径问题

```
<form action="uploadImage" method="post" enctype="multipart/form-data">
  选择图片:<input type="file" name="image" accept="image/*" /> <br> 
  <input type="submit" value="上传">
</form>
这是jsp页面内容
提交到处理这个action的controller后  controller在将结果传递给特定的网页页面或者调用特定的网页页面显示，controller里所有的路径都是相对于原来的action所在的网页的路径
```

 Modules里设置的web资源根目录   web Resource Directory

运行tomcat后访问的url是web.xml中配置的初始页面 （url中不显示此设置）   所以相对路径是根目录不是初始页面所在的目录  比如：<welcome-file>/shiyan2/main.jsp</welcome-file>   url为：http://localhost:8888/JavaEE_Projects_war_exploded/     

那么在main.jsp中访问和main.jsp同目录下的index.jsp 如果直接写index.jsp（觉得和main.jsp同目录  访问应该没事但是会出错）会无法访问 因为整个文件相对路径是tomcat设置的JavaEE_Projects_war（tomcat部署里关联artifacts设置的）跳转也是在这个基础上进行的而不是相对于访问的页面   url会为：http://localhost:8888/JavaEE_Projects_war_exploded/index.jsp  

但是页面的文件路径改变后整体的文件路径也就改变了  /文件/。。。   或者../   会改变整体相对路径

**JavaWeb三层架构分别为：**

> ##### ***Web层\***：表示层，主要的架构模式为MVC（Model View Controller，模型-视图-控制器），主要框架有：Spring MVC和Struts2（当然也有Struts1）；
>
> ##### ***Service层\***：业务逻辑层，主要框架有：Spring；
>
> ##### ***Dao层\***：数据访问层，即数据持久化层，主要框架有：MyBatis（前身是iBATIS）和Hibernate。

**常用的两种框架组合：**

> ##### **SSH**：Struts2 + Spring + Hibernate
>
> ##### **SSM**：Spring MVC + Spring + MyBatis（目前更流行）

以下的框架都要在项目的Project Structure里配置对应的配置文件

### Spring

### [spring mvc + xmlHttpRequest2.0 实现无刷新上传文件，带进度条和剩余时间](https://www.cnblogs.com/iwideal/p/6938863.html)

####  SpringMvc中的HandlerInterceptor

https://blog.csdn.net/treeshu321/article/details/108395441

拦截器：

![1](笔记.assets/1-1608184189535.png)

![2](笔记.assets/2.png)

![3](笔记.assets/3.png)

![4](笔记.assets/4.png)

```
1、springmvc支持文件上传，需要在spring-mvc.xml配置文件中加上下面的一段话：
<!-- 支持上传文件 --> 
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>
2、下面介绍下XMLHttpRequest2.0

　　最早，微软在IE 5引进了这个接口。因为它太有用，其他浏览器也模仿部署了，ajax操作因此得以诞生。
　　但是，这个接口一直没有标准化，每家浏览器的实现或多或少有点不同。HTML 5的概念形成后，W3C开始考虑标准化这个接口。2008年2月，就提出了XMLHttpRequest Level 2 草案。
这个XMLHttpRequest的新版本，提出了很多有用的新功能，将大大推动互联网革新。本文就对这个新版本进行详细介绍。
　　老版本的XMLHttpRequest对象有以下几个缺点：
　　　　* 只支持文本数据的传送，无法用来读取和上传二进制文件。
　　　　* 传送和接收数据时，没有进度信息，只能提示有没有完成。
　　　　* 受到"同域限制"（Same Origin Policy），只能向同一域名的服务器请求数据
　　新版本的XMLHttpRequest对象，针对老版本的缺点，做出了大幅改进：　　　
　　　　* 可以设置HTTP请求的时限。
　　　　* 可以使用FormData对象管理表单数据。
　　　　* 可以上传文件。
　　　　* 可以请求不同域名下的数据（跨域请求）。
　　　　* 可以获取服务器端的二进制数据。
　　　　* 可以获得数据传输的进度信息。
　　新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。假定files是一个"选择文件"的表单元素（input[type="file"]），我们将它装入FormData对象。
var formData = new FormData();
for (var i = 0; i < files.length;i++) {
　　formData.append('files[]', files[i]);
}
然后，发送这个FormData对象
xhr.send(formData);
3、代码实现
废话不多说，上代码：
前端页面代码：
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>XMLHttpRequest上传文件进度实现</title>
    <script type="text/javascript">
    var xhr;
    var ot; //
    var oloaded;
    //上传文件方法
    function UpladFile() {
        var fileObj = document.getElementById("uploadForm"); // js 获取文件对象
        var url = "http://192.168.0.116:8080/partnersys/service/uploadFile"; // 接收上传文件的后台地址
 
        var form = new FormData(fileObj); // FormData 对象
 
        xhr = new XMLHttpRequest(); // XMLHttpRequest 对象
        xhr.open("post", url, true); //post方式，url为服务器请求地址，true 该参数规定请求是否异步处理。
        xhr.onload = uploadComplete; //请求完成
        xhr.onerror = uploadFailed; //请求失败
        xhr.upload.onprogress = progressFunction; //【上传进度调用方法实现】
        xhr.upload.onloadstart = function() { //上传开始执行方法
            ot = new Date().getTime(); //设置上传开始时间
            oloaded = 0; //设置上传开始时，以上传的文件大小为0
        };
        xhr.send(form); //开始上传，发送form数据
    }
    //上传进度实现方法，上传过程中会频繁调用该方法
    function progressFunction(evt) {
 
        var progressBar = document.getElementById("progressBar");
        var percentageDiv = document.getElementById("percentage");
        // event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0
        if (evt.lengthComputable) { //
            progressBar.max = evt.total;
            progressBar.value = evt.loaded;
            percentageDiv.innerHTML = Math.round(evt.loaded / evt.total * 100) + "%";
        }
 
        var time = document.getElementById("time");
        var nt = new Date().getTime(); //获取当前时间
        var pertime = (nt - ot) / 1000; //计算出上次调用该方法时到现在的时间差，单位为s
        ot = new Date().getTime(); //重新赋值时间，用于下次计算
 
        var perload = evt.loaded - oloaded; //计算该分段上传的文件大小，单位b      
        oloaded = evt.loaded; //重新赋值已上传文件大小，用以下次计算
 
        //上传速度计算
        var speed = perload / pertime; //单位b/s
        var bspeed = speed;
        var units = 'b/s'; //单位名称
        if (speed / 1024 > 1) {
            speed = speed / 1024;
            units = 'k/s';
        }
        if (speed / 1024 > 1) {
            speed = speed / 1024;
            units = 'M/s';
        }
        speed = speed.toFixed(1);
        //剩余时间
        var resttime = ((evt.total - evt.loaded) / bspeed).toFixed(1);
        time.innerHTML = '，速度：' + speed + units + '，剩余时间：' + resttime + 's';
        if (bspeed == 0)
            time.innerHTML = '上传已取消';
    }
    //上传成功响应
    function uploadComplete(evt) {
        //服务断接收完文件返回的结果
        //    alert(evt.target.responseText);
        alert("上传成功！");
    }
    //上传失败
    function uploadFailed(evt) {
        alert("上传失败！");
    }
    //取消上传
    function cancleUploadFile() {
        xhr.abort();
    }
    </script>
</head>
 
<body>
    <progress id="progressBar" value="0" max="100" style="width: 300px;"></progress>
    <span id="percentage"></span><span id="time"></span>
    <br />
    <br />
    <form id="uploadForm" method="post" enctype="multipart/form-data">
        <input type="file" id="file" name="myfile" /><!-- input标签的name属性用于post传输，作为表单的键值，后台通过键值获取序列化后的表单数据。name属性值和springmvc中的“@RequestParam(value = "myfile", required = true)”的value值相同，通过该值反序列化成springmvc的MultipartFile对象 -->
        <input type="button" onclick="UpladFile()" value="上传" />
        <input type="button" onclick="cancleUploadFile()" value="取消" />
    </form>
</body>
 
</html>
　后端java代码：
@RequestMapping(value = "/uploadFile",method = RequestMethod.POST)
    public void upload(@RequestParam(value = "myfile", required = true) MultipartFile file, HttpServletRequest request,
            HttpServletResponse response)
    {
        String path = request.getSession().getServletContext().getRealPath("uploadFile");
        String fileName = file.getOriginalFilename();
        System.out.println("文件上传路径为：" + path);
        File targetFile = new File(path, fileName);
        if (!targetFile.exists())
        {
            targetFile.mkdirs();
        }
        // 保存
        try
        {
            file.transferTo(targetFile);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
```

无法访问静态资源：https://blog.csdn.net/shixin_li/article/details/80576753?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control

#### @RequestParam MultipartFile获取上传文件名称

**jsp**

![img](笔记.assets/20181205172216363_.png)

**croller**

controller层通过name值image提取文件image的信息。
Spring上传文件时MultipartFile 类型的参数上边一定要写@RequestParam(“xxx”) ，不然编译部署到服务器上之后，会报错误。
![img](笔记.assets/20181205173437472_.png)

#### [springmvc访问静态资源,以及相对路径,绝对路径问题.](https://www.cnblogs.com/orangeCitrus/p/9815932.html)

一般情况下,在web工程里,css js png jpg 这类资源文件，由浏览器发起请求，由 tomcat、jetty、nginx 这类进程直接接管，类似于 jfinal、Struts、spring mvc 框架都不会去干预.


而 WEB-INF 目录下面由于有 jar 包、配置文件等需要被保护的文件，所以 tomcat、jetty 这类 java web 容器天然禁止对 WEB-INF 之下一切资源的访问

因此， css、js 这类文件生来就不应该被放在 WEB-INF 之下，这个是由很久以前的 java web 规范决定的

如果一定要放在 WEB-INF 之下，需要添加 Filter 接管这类资源的请求，然后象 tomcat、jetty 一样将这类资源的内容自行加载并响应给客户端

静态资源文件应该都在webapp目录下,目录结构如下:

![img](笔记.assets/1316891-20181019121007057-368792180.png)

假如有需要把静态资源出于安全之类的原因放在了WEB-INF目录下,那么springmvc应该首先做如下配置:

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
    <!--静态资源访问  -->
    <mvc:default-servlet-handler/>
    <!--把符合/js/**匹配规则的请求,映射到目录/WEB-INF/js/下-->
    <mvc:resources mapping="/js/**" location="WEB-INF/js/"/>
    <!--<mvc:resources mapping="/img/**" location="WEB-INF/img/"/>-->
    <mvc:resources mapping="/css/**" location="WEB-INF/css/"/>
    <!--<mvc:resources mapping="/commons/**" location="WEB-INF/commons"/>-->
    <!--<mvc:resources mapping="/upload/**" location="WEB-INF/upload/"/>-->

    <!-- 配置ViewResolver视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!--这里配置的目的是,把controller返回的逻辑视图名,加入前缀/WEB-INF/jsp/,加入后缀.jsp.例如controller
               返回的是逻辑视图名为test,则会被拼接为/WEB-INF/jsp/test.jsp
        -->
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
```

然后在前端页面中调用静态资源.

在调用静态资源的时候,会涉及到路径问题,相对路径和绝对路径.

1.什么是绝对路径：

​    大家都知道，在我们平时使用计算机时要找到需要的文件就必须知道文件的位置，而表示文件的位置的方式就是路径，例如只要看到这个路径：c:/website/img/photo.jpg我们就知道photo.jpg文件是在c盘的website目录下的img子目录中。类似于这样完整的描述文件位置的路径就是绝对路径。我们不需要知道其他任何信息就可以根据绝对路径判断出文件的位置。而在网站中类似以http://www.pckings.net/img/photo.jpg来确定文件位置的方式也是绝对路径。

​    另外，在网站的应用中，通常我们使用"/"来表示根目录，/img/photo.jpg就表示photo.jpg文件在这个网站的根目录上的img目录里。但是这样使用对于初学者来说是具有风险性的，因为要知道这里所指的根目录并不是你的网站的根目录，而是你的网站所在的服务器的根目录，因此当网站的根目录与服务器根目录不同时，就会发生错误。
2.什么是相对路径：

​    让我们先来分析一下为什么会发生图片不能正常显示的情况。举一个例子，现在有一个页面index.htm,在这个页面中联接有一张图片photo.jpg。他们的绝对路径如下：
 c:/website/index.htm 
 c:/website/img/photo.jpg

​    如果你使用绝对路径c:/website/img/photo.jpg，那么在自己的计算机上将一切正常，因为确实可以在指定的位置即c:/website/img/photo.jpg上找到photo.jpg文件，但是当你将页面上传到网站的时候就很可能会出错了，因为你的网站可能在服务器的c盘，可能在d盘，也可能在aa目录下，更可能在bb目录下，总之没有理由会有c:/website/img/photo.jpg这样一个路径。那么，在index.htm文件中要使用什么样的路径来定位photo.jpg文件呢？对，应该是用相对路径，所谓相对路径，顾名思义就是自己相对与目标位置。在上例中index.htm中联接的photo.jpg可以使用img/photo.jpg来定位文件，那么不论将这些文件放到哪里，只要他们的相对关系没有变，就不会出错。

​    另外我们使用“../”来表示上一级目录，“../../”表示上上级的目录，以此类推。（学习过dos的朋友可能更容易理解）

总结：
    个人简单来说，绝对路径说白了就是完整路径，比如我在同一目录（C:\Users）有A.TXT和B.TXT两个文件，那么绝对路径就是C:\Users\A.txt和C:\Users\B.txt 而绝对路径就是A.txt和B.txt，因为它们两都在C:\Users这个目录下的。

   而我们常常在页面会用到引用CSS或者图片的，js的，这个时候在页面的前面就需要引用，路径的不对，会导致相关引用也不对。

二、引用路径
那么针对路径，我们是如何引用呢？这就是第二个问题，引用。

1.${pageContext.request.contextPath}是JSP取得绝对路径的方法，等价于<%=request.getContextPath()%> 

比如我的项目名称叫project，那么${ctx}就是/project

说明下：

假定你的名称为project,你在浏览器中输入请求路径： 
http://localhost:8088/project/list.jsp
则执行下面向行代码后打印出如下结果： 
1、 System.out.println(request.getContextPath()); //可返回站点的根路径。也就是项目的名字 
打印结果：/project
2、System.out.println(request.getServletPath()); 
打印结果：/list.jsp 
3、 System.out.println(request.getRequestURI()); 
打印结果：/project/list.jsp 
4、 System.out.println(request.getRealPath("/")); 

打印结果：C:\Tomcat 7.0\webapps\project\test 

2.<base href="<%=basePath%>"> 所谓的小脚本

这里的${basePath}获得是绝对路径，比如http://localhost:8088/project/list.jsp，这里的${basePath}是http://localhost:8088/project/ 注意包含最后一个‘/’的。
\---------------------

一般情况下,项目最好用绝对路径 <%=basePath%>/js/jquery.js
其中basePath是下面的值
<%
 String path = request.getContextPath();
 String basePath = request.getScheme() + "://"
 \+ request.getServerName() + ":" + request.getServerPort()
 \+ path + "/";
%>

**为什么要这么做？因为从静态的jsp路径来看它和js的路径相对关系是../js/，但是往往很多时候我们不是直接访问jsp页面的，是通过其他的jsp页面或者servlet，或者struts的action通过forward的方式转发过来访问的，这时候请求的当前路径就不是该jsp的路径，而是转发过来之前那个jsp，servlet或action的路径，所以和js的相对路径关系就可能不再是../js/了，而在实际使用中，访问同一个jsp可能由很多不同的来源，那么它的相对路径关系可能随时都可能改变，这时候jsp页面里写死的相对路径就无法访问到对应的资源了。所以要使用绝对路径访问。**

例如：
假如我们要访问这个页面，http://localhost:8080/web/jsp/abc.jsp
abc.jsp的相对路径是http://localhost:8080/web/jsp/,abc.jsp里引用了../js/jquery.js，这时候直接访问abc.jsp是没有问题的。
但如果由以下三个请求转发到abc.jsp来访问
\1. http://localhost:8080/web/business/test/test.jsp 
相对路径是http://localhost:8080/web/business/test/，访问js需要使用../../js/jquery.js
\2. http://localhost:8080/web/struts/action/test.action
相对路径是http://localhost:8080/web/struts/test/，（？）访问js需要使用../../js/jquery.js

相对路径是http://localhost:8080/web/struts/action/ 
\3. http://localhost:8080/web/servlet
相对路径是http://localhost:8080/web/，访问js需要使用js/jquery.js

这时候abc.jsp里的../js/jquery.js的死路径就不能正确访问到js了。


===========================================

而真正的相对于web工程的绝对路径写法是：/ 代表url根路径，例如http://localhost:8080/web/js/jquery.js里的http://localhost:8080/，而./代表web工程根路径http://localhost:8080/web/
所以你还可以这么写：
\1. /web/js/jquery.js
\2. ./js/jquery.js





项目无法访问：

https://blog.csdn.net/WGH100817/article/details/101722334?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param

只有配置的初始页面能进入controller  路径栏上输入其他都是404无法访问controller:



![1605611731887](笔记.assets/1605611731887.png)

![1605611664664](笔记.assets/1605611664664.png)

![1605611704788](笔记.assets/1605611704788.png)

原因：

具体配置SpringMvc就不再赘述了

具体配置可以参看：https://www.cnblogs.com/zyw-205520/p/4771253.html

下面说下问题：

访问controller层一直报404

1.首先，访问头如图：

![img](https://img-blog.csdn.net/20181019165412673?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTEwMjE3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

必须是以Application context处配置的名称开头，如图，无论项目名是什么都是：localhost:8080/demo/{controller中配置的访问路径}，若Application context为空则为：localhost:8080/{controller中配置的访问路径}

2.用的是JDK8创建的maven项目，后来因为服务器要求用JDK1.7所以，在IDEA中把JDK8修改为1.7，环境变量也修改为1.7。

​    启动tomcat报错：“主版本 52 比 51 新, 此编译器支持最新的主版本。 建议升级此编译器”，后来发现是应为pom文件中引入的jar包是用1.8编译的，在环境变量JDK7下运行就会出现这种错误，总的来说就是“用高版本编译器编译后的文件在低版本的JDK上运行”就会出现这种错误。

  正常启动tomcat，能正常访问index.jsp页面，但是访问controller还是404，烦！

3. 后来发现是创建maven项目的时候使用JDK1.8创建，虽然事后在项目上改成1.7(没重新建项目)，但是不知为什么并没有用，最后重新用1.7新建的maven项目，正常访问controller层了。

#### [SpringMVC之ModelAndView的用法（转）](https://www.cnblogs.com/alsf/p/9134552.html)

原文地址：https://blog.csdn.net/qq30211478/article/details/78016155

（一）使用ModelAndView类用来存储处理完后的结果数据，以及显示该数据的视图。从名字上看ModelAndView中的Model代表模型，View代表视图，这个名字就很好地解释了该类的作用。业务处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中，把要返回的视图信息存储在该类的view属性中，然后让该ModelAndView返回该Spring MVC框架。框架通过调用配置文件中定义的视图解析器，对该对象进行解析，最后把结果数据显示在指定的页面上。 

具体作用：

1、返回指定页面

**ModelAndView构造方法可以指定返回的页面名称，**

**也可以通过setViewName()方法跳转到指定的页面 ,**

2、返回所需数值

使用addObject()设置需要返回的值，addObject()有几个不同参数的方法，可以默认和指定返回对象的名字。

在Facts 和  Modules里配置对应的xml文件 为项目添加对应的依赖包

#### Spring示例

新建一个Book类，定义两个字段bookName,author和一个实例方法printBookInfo()

```java
public class Book {
    private String bookName;

    private String author;

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public void printBookInfo() {
        System.out.println("Book Name：" + this.bookName + ",Author：" + this.author);
    }
}
```

如果我们想要输出图书信息，按照传统的方式，需要以下几步：

1. 创建Book类的实例对象
2. 设置实例对象的bookName字段和author字段
3. 调用实例对象的printBookInfo()方法

```java
public class Main {
    public static void main(String[] args) {

        Book book = new Book();
        book.setBookName("平凡的世界");
        book.setAuthor("路遥");

        book.printBookInfo();
    }
}
```

运行结果：

> Book Name：平凡的世界,Author：路遥

那么在Spring项目中，如何实现同样的调用呢？

首先，修改spring-config.xml，添加如下配置：

```xml
<bean id="book" class="Book">
    <property name="bookName" value="平凡的世界"/>
    <property name="author" value="路遥"/>
</bean>
```

然后修改Main的方法为：

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {

        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml");
        Book book = applicationContext.getBean("book", Book.class);
        book.printBookInfo();
    }
}
```

运行结果：

![img](笔记.assets/424537-20190228094354971-848456512.png)

我们会发现，运行结果和传统方式一样，只是多了一些Spring的日志信息。

在上面的代码中，我们并未使用new运算符来创建Book类的实例，但是却可以得到Book类的实例，这就是Spring的强大之处，所有类的实例的创建都不需要应用程序自己创建，而是交给Spring容器来创建及管理。

#### 3. Spring示例讲解

虽说实例的创建交给Spring容器来创建及管理，但是在上述的代码中，什么时候创建了Book类的实例并对字段赋值了呢？

为验证这个疑问，我们修改下Book类。

```java
public class Book {
    private String bookName;

    private String author;

    public Book(){
        System.out.println("This is Book constructor.");
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        System.out.println("This is Book setBookName().");
        this.bookName = bookName;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        System.out.println("This is Book setAuthor().");
        this.author = author;
    }

    public void printBookInfo() {
        System.out.println("Book Name：" + this.bookName + ",Author：" + this.author);
    }
}
```

再添加一个Author类：

```java
public class Author {
    private String name;

    private int age;

    public Author() {
        System.out.println("This is Author constructor.");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        System.out.println("This is Author setName().");
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        System.out.println("This is Author setAge().");
        this.age = age;
    }

    public void printAuthorInfo() {
        System.out.println("Name：" + this.name + ",Age：" + this.age);
    }
}
```

然后修改下spring-config.xml文件。

```xml
<bean id="book" class="Book">
    <property name="bookName" value="平凡的世界"/>
    <property name="author" value="路遥"/>
</bean>
<bean id="author" class="Author">
    <property name="name" value="路遥"/>
    <property name="age" value="60"/>
</bean>
```

最后，我们修改下Main类的代码来Debug下，看下代码的执行顺序。

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {

        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml");

        Book book = applicationContext.getBean("book", Book.class);
        book.printBookInfo();

        Author author = applicationContext.getBean("author", Author.class);
        author.printAuthorInfo();
    }
}
```

为更直观的展示，请看如下的Gif图。

![img](笔记.assets/424537-20190228094242154-283489989.gif)

从图中，我们可以看出，在执行完 `ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml");`后，控制台先输出了以下内容：

> This is Book constructor.
>
> This is Book setBookName().
>
> This is Book setAuthor().
>
> This is Author constructor.
>
> This is Author setName().
>
> This is Author setAge().

也就是这句代码执行完后，Book类和Author类的实例已经被创建并且字段已经被赋值，接下来的代码只是从Spring容器中获取实例而已。

#### 4. 注意事项

获取Bean时，第一个参数beanName要与spring-config.xml定义的bean id保持一致，比如我们在spring-config.xml中定义的是book,如果在获取时写的是Book,就会报错。

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {

        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml");

        // 错误的beanName
        Book book = applicationContext.getBean("Book", Book.class);
        book.printBookInfo();
    }
}
```

报错信息如下所示：

![img](笔记.assets/424537-20190228094121691-784000136.png)

### Struts

报错：https://blog.csdn.net/qq_39187822/article/details/80378913

No result defined for action com.sshblog.struts.action.RegeistCheck and result input    form表单中name属性命名错误

#### action和jsp传数据

https://blog.csdn.net/qq_29606237/article/details/79619845?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control     起作用的

一个参考问题例子https://ask.csdn.net/questions/645399

##### Struts2中在Action里面向前端页面传值的方法总结

https://www.cnblogs.com/bloodhunter/p/4584321.html

```
jsp怎样获取struts2中action类里的值？

方式一、Action中定义成员变量，并生成get/set方法，在JSP页面可以取到这个变量值。
    例如：action类：
public class BookAction extends ActionSupport {
	private Book book;
	private List<Book> books;
	...
	public String findBook(){
		books=bookService.findBook(book.getBookName());
		return SUCCESS;
	}
	public Book getBook() {
		return book;
	}
	public void setBook(Book book) {
		this.book = book;
	}
	public List<Book> getBooks() {
		return books;
	}
	public void setBooks(List<Book> books) {
		this.books = books;
	}
	...
}
jsp页面：用OGNL表达式

<s:iterator id="b" value="books"> 
  <tr> 
        <td><s:property value='#b.getBookId()'/> </td>
        <td><s:property value='#b.getBookName()'/> </td>
  </tr>
</s:iterator>
    或EL表达式

<s:iterator value="books" var="b">
	<tr>
    	<td>${b.bookId}</td>
	<td>${b.bookName}</td>
	</tr>
</s:iterator>

方式二、但是定义的成员变量多了，感觉整个Action的代码就很长了。这个时候可以使用一些Servlet API进行值的存取操作：HttpServletRequest、HttpSession和ServletContext。Struts2对这个三个对象用Map进行了封装，我们就可以使用Map对象来存取数据了。 

ActionContext actionContext = ActionContext.getContext(); 
          
//get HttpServletRequest 
Map<String,Object> request = (Map) actionContext.get("request"); 
request.put("a", "a is in request"); 
          
//get HttpSession 
//Map<String,Object> session = (Map) actionContext.get("session"); 
Map<String,Object> session = actionContext.getSession(); 
session.put("b", "b is in session"); 
          
//get ServletContext 
//Map<String,Object> application  = (Map) actionContext.get("application"); 
Map<String,Object> application  = actionContext.getApplication(); 
application.put("c", "c is in application");
jsp
${a} 
${b} 
${c} 
or               
${requestScope.a} 
${sessionScope.b} 
${applicationScope.c}
或者直接使用ActionContex类的put()方法：

ActionContext.getContext().put("greeting", "你好虫虫");
然后在结果页面中，从请求对象中取出greeting属性，如下：

${requestScope.greeting} 或者 <%=request.getAttribute("greeting")%>
```

由于在Action中 并不能直接诶访问Servlet API，但它提供了相关类ActionContext来访问HttpServletRequest、HttpSession和ServletContext，所以在向前端页面传值的方法就出现了多样化。一般我们经常使用的就是通过request、session来传值，至于Application范围这一级别的基本上用的少。

1. 首先如果变量是Action的全局变量，并且定义了Setter方法，那么此时无须做任何更多工作，只要它有值在前端页面就可以取到。此时取值的方法大概有这几种：

- 使用Java代码：<%= request.getParameter(“str”)%>, <%=request.getAttribute(“str”)%> 这两种方式通常不推荐，原则上html代码不用掺杂Java代码；
- 使用EL表达式：${str};
- 使用Struts2标签：<s:property value=”str” /> ;
- 使用OGNL表达式：<s:property value=”#request.str”/>.

1. 对应方法体内的局部变量，我们可以放在request里面，也可以放在session里面。但是，只有在必要的时候才放在session里面。

(1)放在request里面：

a. 直接调用ActionContext提供的put方法：ActionContext.getContext().put(key, value);此时的取值方式有：

- 使用Java代码：<%=request.getAttribute(“str”) %>，同样不推荐；
- 使用EL表达式：${str }；
- 使用Struts2标签：<s:property value=”str”/>;
- 使用OGNL表达式：<s:property value=’’#request.str”/>.

b. 使用ActionContext提供的get方法：Map request = (Map)ActionContext.getContext().get(“request”); request.put(key, value);此时的取值方式有：

- 使用Java代码：<%=request.getAttribute(“str”) %>，同样不推荐；
- 使用EL表达式：${str }；
- 使用OGNL表达式：<s:property value=’’#request.str”/>.

c. 使用ServletActionContext访问HttpServletRequest得到Servlet中的request：HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(key, value);此时的取值方式有：

- 使用Java代码：<%=request.getAttribute(“str”) %>，同样不推荐；
- 使用EL表达式：${str }；
- 使用OGNL表达式：<s:property value=’’#request.str”/>.

(2)放在session里面：

a. 使用ServletActionContext访问HttpServletRequest得到Servlet中的request，再由request得到session：HttpServletRequest request = ServletActionContext.getRequest();

HttpSession session = request.getSession(); session.setAttribute(key, value);或session.putValue(key, value);（已过时，不推荐使用），此时的取值方式有：

- 使用Java代码：<%=session.getAttribute(“str”) %>或<%=session.getValue(“sstr”) %>（与putValue对应，已过时，不推荐使用）;
- 使用EL表达式：${str }；
- 使用OGNL表达式：<s:property value=’’#session.str”/>.

b.直接使用ActionContext.getContext().getSession()：这种方式取值与上面的完全一样，不再赘述。

参考：

> https://www.cnblogs.com/hgfrzh/p/3401658.html

####   https://blog.csdn.net/yuexiaduzhe/article/details/84649555

**重点：**

![1604367546042](笔记.assets/1604367546042.png)

**struts.xml**和**web.xml**文件，其位置分别为**src/struts.xml**和**/web/WEB-INF/web.xml**（两个文件名称和位置不可更改）

![1604241597170](笔记.assets/1604241597170.png)

#### struts.xml中的package

 package提供了将多个Action组织为一2113个模块的5261方式
package的名字必须是唯一的 package可以4102扩展 当一个package扩展自1653
另一个package时该package会在本身配置的基础上加入扩展的package
的配置 父package必须在子package前配置
name：package名称
extends:继承的父package名称
abstract:设置package的属性为抽象的 抽象的package不能定义action 值true:false
namespace:定义package命名空间 该命名空间影响到url的地址，例如此命名空间为/test那么访问是的地址为http://localhost:8080/struts2/test/XX.action
总之，一个struts.xml中 package可以有多个 

### Hibernate

https://blog.csdn.net/qq_34197553/article/details/77718925?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.pc_relevant_is_cache

可看补充：

https://blog.csdn.net/qq_15096707/article/details/51419304

<img src="笔记.assets/1604908202444.png" alt="1604908202444" style="zoom:50%;" />

<img src="笔记.assets/1604908312103.png" alt="1604908312103" style="zoom:50%;" />

重点信息：

```java
Caused by: org.hibernate.service.spi.ServiceException: 
Unable to create requested service [org.hibernate.engine.jdbc.env.spi.JdbcEnvironment]
...
Caused by: org.hibernate.HibernateException: 
Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set
12345
```

#### 报错原因：

是因为没有加Hibernate SQL方言导致的

#### 解决方案：

增加一行配置

```bash
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect
1
```

#### 附件

其他Hibernate SQL方言

| 数据库               | 方言                                        |
| -------------------- | ------------------------------------------- |
| DB2                  | org.hibernate.dialect.DB2Dialect            |
| DB2 AS/400           | org.hibernate.dialect.DB2400Dialect         |
| DB2 OS390            | org.hibernate.dialect.DB2390Dialect         |
| PostgreSQL           | org.hibernate.dialect.PostgreSQLDialect     |
| MySQL                | org.hibernate.dialect.MySQLDialect          |
| MySQL with InnoDB    | org.hibernate.dialect.MySQLInnoDBDialect    |
| MySQL with MyISAM    | org.hibernate.dialect.MySQLMyISAMDialect    |
| Oracle (any version) | org.hibernate.dialect.OracleDialect         |
| Oracle 9i/10g        | org.hibernate.dialect.Oracle9Dialect        |
| Sybase               | org.hibernate.dialect.SybaseDialect         |
| Sybase Anywhere      | org.hibernate.dialect.SybaseAnywhereDialect |
| Microsoft SQL Server | org.hibernate.dialect.SQLServerDialect      |
| SAP DB               | org.hibernate.dialect.SAPDBDialect          |
| Informix             | org.hibernate.dialect.InformixDialect       |
| HypersonicSQL        | org.hibernate.dialect.HSQLDialect           |
| Ingres               | org.hibernate.dialect.IngresDialect         |
| Progress             | org.hibernate.dialect.ProgressDialect       |
| Mckoi SQL            | org.hibernate.dialect.MckoiDialect          |
| Interbase            | org.hibernate.dialect.InterbaseDialect      |
| Pointbase            | org.hibernate.dialect.PointbaseDialect      |
| FrontBase            | org.hibernate.dialect.FrontbaseDialect      |
| Firebird             | org.hibernate.dialect.FirebirdDialect       |

### IOC容器](https://www.cnblogs.com/boke1/p/11047260.html)

1.IOC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合，更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的使程序的整个体系结构变得非常灵活。在运行期，在外部容器动态的将依赖对象注入组件，当外部容器启动后，外部容器就会初始化。创建并管理bean对象，以及销毁他，这种应用本身不负责依赖对象的创建和维护，依赖对象的创建和维护是由外部容器负责的称为控制反转。

2.\*IOC\*（\*控制反转\*）和 \*DI（依赖注入）\*

IOC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IOC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。

 DI（依赖注入）。IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的

###  Maven

 maven【把jar包放在仓库中统一管理】 

 用maven，我们可以方便统一的进行jar包管理，jar包版本升级，快速项目构建以及分模块开发等相关功能。maven使用得好，项目开发速度就会成倍的提升。总之，项目越大，越能体现maven的优势。 

 Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。 

###  JavaBean

 JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的[构造器](https://baike.baidu.com/item/构造器/9844976)。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。 Javabean 就是一个类，这个类就定义一系列 get<Name> 和 set<Name> 方法。 

 JavaBeans 是 Java 中一种特殊的类，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供 getter 方法和 setter 方法访问对象的属性。名称中的 “Bean” 是用于 Java 的可重用软件组件的惯用叫法 .

 JavaBeans事实上有三层含义。首先，JavaBeans是一种规范，一种在Java（包括JSP）中可重复使用的Java组件的技术规范,也可以说成我们常说的接口。其次，JavaBeans是一个Java的类，一般来说，这样的Java类将对应于一个独立的 .java文件 ，在绝大多数情况下，这应该是一个public类型的类。最后，当JavaBeans这样的一个Java类在我们的具体的Java程序中被实例之后，这就是我们面向对象的对象，我们有时也会将这样的一个JavaBeans的实例称之为JavaBeans。总之，就是Java中的接口、类和对象。 

##### 优点

- *Bean* 可以控制它的属性、事件和方法是否暴露给其他程序。
- *Bean* 可以接收来自其他对象的事件，也可以产生事件给其他对象。
- 有软件可用来配置 *Bean*。
- *Bean* 的属性可以被序列化，以供日后重用。

##### 契约/约定

- *Bean* 应该具有默认构造函数（无参数）。
- *Bean* 应该提供 *getter* 和 *setter* 方法。
- 使用 *getter* 方法读取可读属性的值。
- 要更新值，应调用 *setter* 方法。
- *Bean* 应该实现 *java.io.serializable*，因为它允许保存，存储和恢复正在使用的 *JavaBean* 的状态。

##### 属性

对象的用户可以访问 *JavaBean* 属性。该功能部件可以是任何 *Java* 数据类型，其中包含您定义的类。它可能具有以下模式：读，写，只读或只写。*JavaBean* 功能通过两种方法访问：

1. getter

    

   方法的属性如下：

   - 必须 *public* 修饰
   - 返回类型不应为空
   - *getter* 方法应以单词 **get** 开头

2. setter

    

   方法的属性：

   - 必须公开性质
   - 返回类型应为空
   - *setter* 方法必须以单词 **set** 为前缀

### EJB

EJB是的Enterprise Java Beans技术的简称, 又被称为企业Java Beans。这种技术最早是由美国计算公司研发出来的。EJB技术的诞生标志着Java Beans的运行正式从客户端领域扩展到服务器领域。在电子商务领域运用EJB技术可以简化应用系统的开发, 这是由该技术的结构和特点所决定的。 

- 中文名

  EJB

- 外文名

  Enterprise [JavaBean](https://baike.baidu.com/item/JavaBean)

- 中文全称

  企业级JavaBean

- 设计目标

  是部署分布式[应用程序](https://baike.baidu.com/item/应用程序)等

- 用  途

  构筑企业级应用的服务器端

- 发布时间

  1997年

  EJB (Enterprise Java Beans) 是基于分布式事务处理的企业级应用程序的组件。Sun公司发布的文档中对EJB的定义是：EJB是用于开发和部署多层结构的、分布式的、面向对象的Java应用系统的跨平台的构件体系结构。 

  在开发分布式系统时, 采用EJB可以使得开发商业应用系统变得容易, 应用系统可以在一个支持EJB的环境中开发, 开发完之后部署在其它的EJB环境中, 随着需求的改变, 应用系统可以不加修改地迁移到其它功能更强、更复杂的服务器上。EJB在系统实现业务逻辑层里面负责表示程序的逻辑和提供访问数据库的接口。

### PAGECONTEXT

page:在JSP里面,page是该JSP页面的当前对象,类似于该JSP页面的"this".
request:是HttpServletRequest类的对象,具体用法你自行了解.
session:HttpSession类的对象,但是不是每个JSP页面都可以共享该session对象,如果在某个JSP页面中加上了语句
<%@ page session="false" %>
那么当前JSP页面则不能使用session对象.
application:即ServletContext类的对象.
pageContext:即PageContext类的对象,页面上下文对象.是Javaweb四大域对象之一,其他三个域对象分别是session,request,application. Servlet只能使用session,request,application三大域对象,而JSP则可以使用全部的这四大域对象

pageContext对象

这个对象代表页面上下文，该对象主要用于访问JSP之间的共享数据。使用pageContext可以访问page、request、session、application范围的变量。

pageContext是PageContext类的实例，它提供了如下两个方法来访问page、request、session、application范围的变量。

getAttribute(String name)：取得page范围内的name属性。

getAttribute(String name,int scope)：取得指定范围内的name属性，其中scope可以是如下4个值：

PageContext.PAGE_SCOPE：对应于page范围。

PageContext.REQUEST_SCOPE：对应于request范围。

PageContext.SESSION_SCOPE：对应于session范围。

PageContext.APPLICATION_SCOPE：对应于application范围。

与getAttribute()方法相对应，PageContext也提供了2个对应的setAttribute()方法，用于将指定变量放入page、request、session、application范围内。


pagecontext 隐含物件对应於javax.servlet.jsp.pagecontext型态之物件，，隐含物件都自动的被加入至pagecontext中，您可以藉由它来取得与jsp相关的隐含物件对应之servlet物件，像是getrequest()可以取得servletrequest， getservletconfig()可以取得servletconfig，getsession()可以取得httpsession等等。提供取得隐含物件对应之servlet物件并不是pagecontext的主要作用，它的主要功能在提供一个单一个介面，以管理各种的公开物件（像是 httpsession、servletcontext、servletconfig、servletrequest、servletresponse等等），提供一个单一的api来管理属性作用范围等等。
我们之前曾经使用过session的setattribute()等方法设定一个进程可以共用的属性物件，使用session设定的属性在同一个进程中可以共用，除了session之外，还有pagecontext、 request、application也都可以使用setattribute()之类的方法（详请查阅api文件）来设定可以共用的属性物件，只不过这四个物件所设定的属性其共用范围各不相同。
使用pagecontext所设定的属性物件，其共用范围限於同一个 jsp页面，使用request所设定的属性物件，其在同一个request处理期间可以共用（包括forward给其它jsp页面），session物件所设定的属性物件则限於同一个进程作用期间可以共用，而application物件所设定的属性，则在整个web应用程式中的jsp页面都可以共用。

以下举application为例，您可以将一些物件当作属性设定给application，则另一个jsp页面就可以在适当的时候取得这个属性物件，例如：

<%
 string attr = "字串物件";
 out.println("设定属性给application：" + attr);
 application.setattribute("str", attr);
%>

我们先连上这个jsp网页以执行属性设定，然后我们再连上这个jsp网页：

<%
 string attr = (string) application.getattribute("str");
 out.println("取得application属性：" + attr);
%>

由於我们之前已经将字串物件设定在application中作为属性，所以我们可以在上面这个页面中取得之前设定的物件，同样的道理，您也可以用相同的方式设定属性给pagecontext、request、session等物件，只要在允许的作用范围中，就可以取得所设定的属性物件。

您可以使用pagecontext物件来设定属性，并指定属性的作用范围，而不用使用个别的pagecontext、request、session、 application来进行设定，这就是之前所提的，以pagecontext提供一个单一的api来管理属性作用范围，您可以使用以下的方法来进行设定：

getattribute(string name, int scope)
setattribute(string name, object value, int scope)
removeattribute(string name, int scope)

其中的scope可以使用以下的常数来进行指定：pagecontext.page_scope、pagecontext.request_scope、 pagecontext.session_scope、pagecontext.application_scope，常数的名称已经直接指明属性范围，我们可以将上面的两个jsp页面改为以下的形式：

<%
 string attr = "字串物件";
 out.println("设定属性给application：" + attr);
 pagecontext.setattribute("str", attr, pagecontext.application_scope);
%>

<%
 string attr = (string) pagecontext.getattribute("str", pagecontext.application_scope);
 out.println("取得application属性：" + attr);
%>


对于开发者来说,pageContext页面上下文对象有三大主要功能:
1.域对象功能;
2.代理其他的JavaWeb三个域对象;
3.获取其他的8个JSP内置对象;
这些对象除了page之外,其他的都是比较常用的

###  泛型

List<T>、List<?>、List<Object>这三者都可以容纳所有的对象，但使用的顺序应该是首选List<T>,次之List<?>,最后选择List<Object>,原因如下：

(1) List<T>是确定的某一个类型

List<T>表示的是List集合中的元素都为T类型，具体类型在运行期决定；List<?>表示 的是任意类型，与List<T>类似，而List<Object>则表示List集合中的所有元素为Object类 型，因为Object是所有类的父类，所以LiSt<Object>也可以容纳所有的类类型，从这一字面 意义上分析，List<T>更符合习惯：编码者知道它是某一个类型，只是在运行期才确定而已。

(2) List<T>可以进行读写操作

List<T>可以进行诸如add、remove等操作，因为它的类型是固定的T类型，在编码期 不需要进行任何的转型操作。

List<?>是只读类型的，不能进行增加、修改操作，因为编译器不知道List中容纳的是 什么类型的元素，也就无毕校验类型是否安全了，而且List<?>读取出的元素都是Object类 型的，需要主动转型，所以它经常用于泛型方法的返回值。注意，List<?>虽然无法增加、修 改元素，但是却可以删除元素，比如执行remove、clear等方法，那是因为它的删除动作与泛型类型无关

List<Object>也可以读写操作，但是它执行写入操作时需要向上转型（Upcast),在读 取数据后需要向下转型（Downcast),而此时已经失去了泛型存在的意义了。

打个比方，有一个篮子用来容纳物品，List<T>的意思是说，“嘿，我这里有一个篮子， 可以容纳固定类别的东西，比如西瓜、番茄等”。List<?>的意思是说“嘿，我也有一个篮子， 我可以容纳任何东西，只要是你想得到的”。而List<Object>就更有意思了，它说“嘿，我 也有一个篮子，我可以容纳所有物质，只要你认为是物质的东西就都可以容纳进来”。

推而广之，Dao<T>应该比Dao<?>、Dao<Object>更先采用，Desc<Person>则比Desc<?>、Desc<Object> 更优先采用

## .NET

上下框架：

![1608445015670](笔记.assets/1608445015670.png)

发布网站：

https://blog.csdn.net/liaoyunjxn/article/details/100044104

https://jhrs.com/2018/26157.html

后端前端交互：

https://www.cnblogs.com/chenghm2003/archive/2008/07/04/1235238.html

 .net的书一开始都是按java的概念迁移对比的，jvm对应clr，java se runtime对应 .net framework， jdk对应 .net framework sdk，java对应C#，JPype对应IronPython，scala对应F#（不准），就是想表达jvm上可以有很多种语言，clr上也可以有很多语言。在java平台上可以开发web，服务，界面程序，安卓，C#也可以开发web，服务，界面exe程序，手机app。spring里面东西好像比较多，.net有移植的[http://spring.net](http://spring.net/)，但是更应该对应aspnet mvc + unity啥的。java体系跨平台，C#体系一开始用mono现在由微软主导的 .net core 跨平台。java现在用JetBrains开发了吧，C#一直是VS为主。 

.NET是个平台，理论上，各种语言都可以编译成它的IL，在上面运行。.NET开发，就是把它当作目标平台的开发。（除非你在极少数的公司，那是真正做.NET开发的。做的是开发.NET这个平台本身。）

然而实际上，.NET上还分了阶级。C#是全能的亲儿子，ASP/VB/F#是能力较弱的亲儿子，其他语言那是干儿子或者过继的。所以，实际中，你可以认为就是在搞C#了。

所以说，.NET上所有语言都是平等的，但有些语言比另一些更平等一些。

```
dotnet new console -o D:\study\NetCore
```

讲解一下，new是新建，console是控制台，-o是IO路径，后面的是我准备安放的路径，D盘的study目录下，项目名称是NetCore



设置在runat=”server”的控件里面的执行的方法需要设置autopostback属性为true因为这些事发送到服务器由服务器执行的  一般除了button的onclick都要设置  因为asp.net里button的type都为“submit”所以要想设置有相应动作需要设置autopostback为true   注意回发时可能设置的控件属性会有相应的冲突

```



<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>

</title></head>
<body>
    <form method="post" action="./WebForm2.aspx" id="form1">
<div class="aspNetHidden">
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="CkQaaCA//PRCxAe/Czm7uUzlOtqLJAOUMiuSEKUn1jLvcOTXQqsfl/3TOj5CeCeMgtf0wYiO6tYK91mla5vxFQp3pJs5IZ09CSg51m5INoSyq9d6oQjrexkGPk0DUOwJJzQRD4IT67Qoi3oYDaR50TZFRL9glll2bwapoxcVgYs/Qv7NB36qfFnBeeihK59s/OoiGIsi0ZkiyVc9hkm94rfcCyhpMsZg0bseIfkoACg=" />
</div>

<div class="aspNetHidden">

	<input type="hidden" name="__VIEWSTATEGENERATOR" id="__VIEWSTATEGENERATOR" value="D51E3F29" />
	<input type="hidden" name="__EVENTVALIDATION" id="__EVENTVALIDATION" value="boaD0Smfb7ayOgwQsAhyreE5IfJlc6U66aMYu0uegWzIBbzKfI3QMMd/nu+Mn2i8KFk1j/beRP13QZb0HTlEK/68SVVAomwqm4sWUuvQz0I7PjSqUahsNrumNMoRBEPhVyr/xk+o9rlPOH8zIhtTrlbxDOugNwKYuKmVVSv5+WbQJWwIuA/wYbCKfZObMKQ+" />
</div>
        <div>
            <span id="Label1">爱好：</span>
            <input id="CheckBox1" type="checkbox" name="CheckBox1" />
            <br />
            <input id="RadioButton1" type="radio" name="ao" value="RadioButton1" /><label for="RadioButton1">我喜欢看奥运会</label>
            <input id="RadioButton2" type="radio" name="ao" value="RadioButton2" /><label for="RadioButton2">我不喜欢看奥运会</label>
            <br />
            <input type="submit" name="Button1" value="查看结果" id="Button1" />
            <br />
            <span id="Label2">结果：</span>
            <span id="Label3"></span>
        </div>
    </form>
</body>
</html>

```



## XML

| `xmlns`              | 命名空间，类似包名，因为xml的标签可自定义，需要命名空间来 |
| -------------------- | --------------------------------------------------------- |
| `xmlns:xsi`          | xml遵循的标签规范                                         |
| `xsi:schemaLocation` | 用来定义xmlschema的地址，也就是xml书写时需要遵循的语法    |

### xmlns

 添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。  当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。
对于xml命名空间还有一个定义就是“默认命名空间”，为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。  对于默认的Namespace中的元素，可以不使用前缀。 

###  xsi

表示前缀，如：`http://www.w3.org/2001/XMLSchema-instance` 表示命名空间唯一名称，xsi是xml shema instance的缩写，翻译后就是xml文档实例。要理解xsi具体含义，我们先理解xml文档验证，在验证xml文档时，一个合法的xml文档，同样遵守文档类型定义（DTD）的语法规则，例如：
 验证xml文档时，一个合法的xml文档，同样遵守文档类型定义（DTD）的语法规则 ,dtd文件的作用是定义xml文档的结构，它使用一系列合法的元素来定义文档结构。  dtd是一种XML的约束，说白了就是我定义了dtd文件，下面的xml编写必须按照我的约束条件来写。分为内部dtd和外部dtd（系统标识符（**SYSTEM**）和公共标识符（**PUBLIC**)） 

对dtd文件的使用最多的还是在html文件中，我们创建jsp页面时，在jsp页面会出现一行代码（若使用html5，不会出现这行代码）：

```
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">1
```

这句代码就是说明了我们html文档使用了哪个版本的dtd文件。

### dtd

**内部dtd：**

![img](笔记.assets/648507-20170523143546038-1098361359.png)

**外部dtd：就是这个dtd文件是外部引用的，和css文件的内部，外部一个意思**

**![img](笔记.assets/648507-20170523143727648-525306956.png)**

![img](https://images2015.cnblogs.com/blog/648507/201705/648507-20170523143746507-1744275666.png)

![img](笔记.assets/648507-20170523143804195-87195487.png)

![img](笔记.assets/648507-20170523143821038-1060310006.png)

![img](笔记.assets/648507-20170523143917538-2115398001.png)

所以SYSTEM和PUBLIC这种关键字就是引入外部dtd文件的。

对于xml文档验证，W3C支持一种基于xml的dtd替代者，它名为**xml schema**（注意**xml schema instance**这个词义）。

xmlns:xsi表示使用xsi作为前缀的Namespace，当然前缀xsi需要在文档中声明。

 其中，前缀、url都是固定不变的，说明遵守w3c协议。
那么，现在我们拥有了xml schema instance，接下来就是为xml schema instance提供使用的xml schema地址(schemaLocation)，即xsd文件全路径。 

### xsi:schemaLocation

xsi:schemaLocation属性其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，正是因为我们一开始声明了

[ ](http://my.oschina.net/itblog/blog/390001#)

![img](笔记.assets/648507-20170523145541179-534825216.png)

 

  这里才写作xsi:schemaLocation（当然一般都使用这个前缀）。它定义了XML Namespace和对应的XSD（Xml Schema Definition）文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔（空格和换行均可）。第一个URI是定义的XML Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，该文档的targetNamespace必须与第一个URI相匹配。 xsi：schemaLocation包含的部分一定要出现在名字空间中。而实际上写的只需要>=xsi：schemaLocation中的内容即可 例如

## VUE

### Layui

像用这种layui 第三方的东西，出现这种类似的JavaScript错误，第三方出错一般有两个最主要的原因：

1、引用问题。（例如，没有正确引入js；）

2、位置问题。（例如，引入的js位置放在顶部、尾部等；）

 

### 一. export是什么

export主要用于对外输出本模块变量的接口，一个文件就可以被理解为一个模块。export就是导出。

import就是在一个模块中加载另一个含有export接口的模块， import就是导入。

1. export default和export都能导出一个模块里面的常量，函数，文件，模块等，在其它文件或模块中通过import来导入常量，函数，文件或模块。这样就可以使用它们了。但是，在一个文件或模块中，export,import可以有多个，export default却只能有一个。
2. 通过export方式导出，在导入的时候需要加{}大括号，export default 就不需要{}.

```js
var name = 'zhangsan'
export { name }

import { name } from "/.test.js"123
var name = 'zhangsan'
export default name 

import name from "/.test.js"123
import ComponentA from './ComponentA.vue'

export default {
  components: {
    ComponentA
  },
  // ...
}1234567
 export default {
    name: 'GoTop',
    data() {
      return {
        topShow: false
      }
    },
    methods: {
      toTop() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        this.topShow = false;
      },
      needToTop() {
        let curHeight = document.documentElement.scrollTop || document.body.scrollTop;

        if (curHeight > 400) {
          this.topShow = true;
        } else {
          this.topShow = false;
        }

      }
    },
    mounted() {
      /**
       * 等到整个视图都渲染完毕
       */
      this.$nextTick(function () {
        window.addEventListener('scroll', this.needToTop);
      });
    }
  }1234567891011121314151617181920212223242526272829303132
```

let是在当前作用域下声明变量，var是全局，外层可以调用。

||表示逻辑或

`new Vue({})` ,只是创建一个`Vue`实例，就是相当于创建一个根组件。

### 二. != 和 !==的区别

两个都是用来比较的，在比较过程中会有差别。

!= 在比较时，若类型不同，会尝试转换类型之后再比较。

!== 在在进行比较之前会进行判断，如果不是相同类型，则不会比较。因此，只有相同类型才会比较。

同样道理：

==代表相同， ===代表严格相同。

== 在进行比较的时候，若类型不同，会尝试转换类型之后再比较。

===在进行比较的时候，若类型不同，就直接不相等了。

判断一个值是否是`NaN`,只能通过`isNaN()`来进行判断。

### 优点

渐进式Javascript框架  由浅入深的使用

体积小   更高运行效率  基于虚拟DOM，一种预先通过Javascript进行各种计算，把最终的DOM操作计算出来并优化的技术，这个DOM操作属于预处理操作，并没有真实的操作DOM，叫虚拟DOM。大幅度提高了渲染效率

双向数据绑定，不用再去操作DOM对象

生态丰富  市场上有大量成熟的基于vue.js的ui框架、常用组件。

### 安装与部署

#### 直接用<script>引入   

直接下载并用<script>标签引入，Vue  会被注册为一个全局变量。   下载生产版本（包含完整的警告和提示信息）和压缩版本的vue.js  将此文件直接放在项目目录下    script的src直接引用项目就安装好了vue.js,vue.js即部署在了项目下   console里会有警告信息

使用script标签直接引入的文件使用html的后缀名

vue.js一旦引入之后会暴露一个全局的变量叫Vue()  通过这个函数就可以进行vue的后续操作

#### CDN方式

对于制作原型或学习，你可以这样使用最新版本：

```
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
```

对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：

```
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
```

#### 命令行工具 (CLI）

支持单文件组件的应用  支持.vue的文件

 Vue 提供了一个[官方的 CLI](https://github.com/vuejs/vue-cli)，为单页面应用 (SPA) 快速搭建繁杂的脚手架。  CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读[指南](https://cn.vuejs.org/v2/guide/)，在熟悉 Vue 本身之后再使用 CLI。 

### 创建第一个vue.js的应用

用简洁的模板语法，声明式是的将数据渲染进DOM中的一个系统  分两个部分：视图   脚本

```
<div id="app">//id为app的div标签
	  {{ message }} {{name}}//{{}}声明一个变量，名字是message  vue.js最常见的文本插值的一个方式
</div>
	/*引入vue.js时声明了一个全局变量 叫Vue()   通过new Vue()获得一个Vue的应用，会返回一个对象，叫应用对象|vue.js的对象   new Vue()的时候需要传递一个对象作为参数，有两个非常重要的属性：el(element  通过id选择器来选中dom元素)   data(用于保存数据，视图中声明了那些变量就要在data中注册并对变量进行初始化的赋值)
	*/
	
<script type="text/javascript">//script脚本包裹一段js
	var app = new Vue({
		el: '#app',
		data: {
			message: 'Hello Vue!',
			name : "Vue"
		}
	});
</script>
```

### 数据与方法

每一个vue应用都是通过Vue()函数创建一个新的vue实例开始的，通常用一个变量来接受一个Vue()函数被new 之后的一个结果--vue的对象  vue没有完全遵守MVVM的模型但是设计受启发，通常用vm（viewmodel）代表一vue实例。

当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 

```
// 我们的数据对象
var data = { a: 1 }
// 该对象被加入到一个 Vue 实例中
var vm = new Vue({
  data: data
})
// 获得这个实例上的 property
// 返回源数据中对应的字段
vm.a == data.a // => true
// 设置 property 也会影响到原始数据
vm.a = 2
data.a // => 2  改变的是var定义的data变量的属性  视图会重新渲染
// ……反之亦然    通过data变量修改会达到响应式的目的
data.a = 3
vm.a // => 3
vm.b  或者data.b  赋值不会显示 不在data中注册console会报错  想让某一个属性或者变量能够响应式的需要在new  Vue时提前声明

<script type="text/javascript">
var data = { a : 1 };//外层外部声明一个变量，对象的形式
var vm = new Vue({//new Vue时传递参数时有所变化  vm来保存VUe的实例  通过vm改变他的a属性也可以vm.a <==> data.a 
	el   : "#app",
	data : data //之前是直接写一个对象   这里在new Vue之前创建了一个对象data    第一个data是对象的属性 第二个data是var定义的一个变量-对象形式
});

vm.$watch('a', function(newVal, oldVal){
	console.log(newVal, oldVal);
})

vm.$data.a = "test...."

</script>
```

当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 `data` 中的 property 才是**响应式**的。也就是说如果你添加一个新的 property，比如：

```
vm.b = 'hi'
```

那么对 `b` 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：

```
data: {
  newTodoText: '',
  visitCount: 0,
  hideCompletedTodos: false,
  todos: [],
  error: null
}
```

这里唯一的例外是使用 `Object.freeze()`，这会阻止修改现有的 property，也意味着响应系统无法再*追踪*变化。会阻止修改现有的属性，响应系统无法进行追踪变化。

```
var obj = {
  foo: 'bar'
}

Object.freeze(obj)

new Vue({
  el: '#app',
  data: obj
})
<div id="app">
  <p>{{ foo }}</p>
  <!-- 这里的 `foo` 不会更新！ -->
  <button v-on:click="foo = 'baz'">Change it</button>
</div>
```

除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。例如：

```
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})
vm.$data.a也可以
vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法  观察一个变量的变化并且获取变化前后的结果       参数：  观察哪个变量的变化  执行一个回调函数  两个参数(newvalue和oldvalue)记录变化的最新值和原来的值
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})
```

以后你可以在 [API 参考](https://cn.vuejs.org/v2/api/#实例-property)中查阅到完整的实例 property 和方法的列表。

### 生命周期的应用

实例生命周期钩子  

每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在应用不同阶段添加自己的代码的机会。



比如 [`created`](https://cn.vuejs.org/v2/api/#created) 钩子可以用来在一个实例被创建之后执行代码：

```
new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` 指向 vm 实例
    console.log('a is: ' + this.a)
  }
})
// => "a is: 1"
```

也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 [`mounted`](https://cn.vuejs.org/v2/api/#mounted)、[`updated`](https://cn.vuejs.org/v2/api/#updated) 和 [`destroyed`](https://cn.vuejs.org/v2/api/#destroyed)。生命周期钩子的 `this` 上下文指向调用它的 Vue 实例。

不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，比如 `created: () => console.log(this.a)` 或 `vm.$watch('a', newValue => this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。



需要写在new Vue()时传递的对象内以属性的方式进行声明，这个属性是一个函数，在Vue的应用运行的每一个阶段，系统自动调用已经声明的生命周期函数，还需要注意生命周期函数不能使用箭头函数（没有this），生命周期函数调用中需要频繁调用、应用this，

```
setTimeout(function(){
	vm.msg = "change ......";
}, 3000);
3秒钟之后将msg变量改变为chang....文本
```



#### [选项 / 生命周期钩子](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)      vie.js官网  学习  API下

所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着**你不能使用箭头函数来定义一个生命周期方法** (例如 `created: () => this.fetchTodos()`)。这是因为箭头函数绑定了父上下文，因此 `this` 与你期待的 Vue 实例不同，`this.fetchTodos` 的行为未定义。

beforeCreate:function(){

​      //pass

}

##### [beforeCreate](https://cn.vuejs.org/v2/api/#beforeCreate)

- **类型**：`Function`

- **详细**：

  在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。  简单理解为整个页面创建之前调用的生命周期

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [created](https://cn.vuejs.org/v2/api/#created)

- **类型**：`Function`

- **详细**：

  在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，`$el` property 目前尚不可用。  想对于beforecreate是已经创建好了的    实际是生命周期作用于在实例创建之后被调用

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [beforeMount](https://cn.vuejs.org/v2/api/#beforeMount)

- **类型**：`Function`

- **详细**：

  在挂载开始之前被调用：相关的 `render` 函数首次被调用。准备挂载状态

  **该钩子在服务器端渲染期间不被调用。**

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [mounted](https://cn.vuejs.org/v2/api/#mounted)

- **类型**：`Function`

- **详细**：

  实例被挂载后调用，这时 `el` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内。     挂载成功之后调用的函数，所有节点被新的Vue的节点所替换

  注意 `mounted` **不会**保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 [vm.$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick)：

  ```
  mounted: function () {
    this.$nextTick(function () {
      // Code that will run only after the
      // entire view has been rendered
    })
  }
  ```

  **该钩子在服务器端渲染期间不被调用。**

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [beforeUpdate](https://cn.vuejs.org/v2/api/#beforeUpdate)

- **类型**：`Function`

- **详细**：

  数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。   更新之前  数据变化之前被调用的的一个函数

  **该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。**

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [updated](https://cn.vuejs.org/v2/api/#updated)

- **类型**：`Function`

- **详细**：

  由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

  当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用[计算属性](https://cn.vuejs.org/v2/api/#computed)或 [watcher](https://cn.vuejs.org/v2/api/#watch) 取而代之。  整个数据已经被更新完毕了  DOM结构也被更新了

  注意 `updated` **不会**保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 `updated` 里使用 [vm.$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick)：

  ```
  updated: function () {
    this.$nextTick(function () {
      // Code that will run only after the
      // entire view has been re-rendered
    })
  }
  ```

  **该钩子在服务器端渲染期间不被调用。**

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [activated](https://cn.vuejs.org/v2/api/#activated)

- **类型**：`Function`

- **详细**：

  被 keep-alive 缓存的组件激活时调用。组件时使用到

  **该钩子在服务器端渲染期间不被调用。**

- **参考**：

  - [构建组件 - keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)
  - [动态组件 - keep-alive](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#在动态组件上使用-keep-alive)

##### [deactivated](https://cn.vuejs.org/v2/api/#deactivated)

- **类型**：`Function`

- **详细**：

  被 keep-alive 缓存的组件停用时调用。

  **该钩子在服务器端渲染期间不被调用。**

- **参考**：

  - [构建组件 - keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)
  - [动态组件 - keep-alive](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#在动态组件上使用-keep-alive)

##### [beforeDestroy](https://cn.vuejs.org/v2/api/#beforeDestroy)

- **类型**：`Function`

- **详细**：

  实例销毁之前调用。在这一步，实例仍然完全可用。页面、整个应用销毁之前调用

  **该钩子在服务器端渲染期间不被调用。**

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [destroyed](https://cn.vuejs.org/v2/api/#destroyed)

- **类型**：`Function`

- **详细**：

  实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。

  **该钩子在服务器端渲染期间不被调用。**

- **参考**：[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

##### [errorCaptured](https://cn.vuejs.org/v2/api/#errorCaptured)

> 2.5.0+ 新增      捕获来自子组件的错误

- **类型**：`(err: Error, vm: Component, info: string) => ?boolean`

- **详细**：

  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。

  你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。

  **错误传播规则**

  - 默认情况下，如果全局的 `config.errorHandler` 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。
  - 如果一个组件的继承或父级从属链路中存在多个 `errorCaptured` 钩子，则它们将会被相同的错误逐个唤起。
  - 如果此 `errorCaptured` 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 `config.errorHandler`。
  - 一个 `errorCaptured` 钩子能够返回 `false` 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 `errorCaptured` 钩子和全局的 `config.errorHandler`。

#### [生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。

![Vue 实例生命周期](笔记.assets/lifecycle.png)

### 模板语法-插值       

渲染------显示在页面上

Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器所解析。

在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。Vue从一定层面上提高了js的效率。

如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，[直接写渲染 (render) 函数](https://cn.vuejs.org/v2/guide/render-function.html)，使用可选的 JSX 语法。

##### [文本](https://cn.vuejs.org/v2/guide/syntax.html#文本)插值

数据绑定最常见的形式就是使用“Mustache”语法 (左右双大括号方式)包含一个变量的值方式的文本插值：

```
<span>Message: {{ msg }}</span>          //(左右双大括号方式)包含一个变量

var vm = new Vue({
	el : "#app",
	data : {                              //data里声明属性及其取值
		msg : "hi vue"
	}
});
```

Mustache 标签将会被替代为对应数据对象上 `msg` property 的值。无论何时，绑定的数据对象上 `msg` property 发生了改变，插值处的内容都会更新。

**通过使用 [v-once 指令](https://cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值，当数据被改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：

```
<span v-once>这个将不会改变: {{ msg }}</span>
```

##### [原始 HTML](https://cn.vuejs.org/v2/guide/syntax.html#原始-HTML)                   变量变为html元素

双大括号会将数据解释为字符串形式的普通文本，而非 HTML 代码。为了输出真正的 HTML代码（浏览器会进行相应的解析），你需要使用 [`v-html` 指令](https://cn.vuejs.org/v2/api/#v-html)：   这个指令要加在某一个标签上为（解析执行后会在这个标签内部产生对应的html标签|元素）这个指令赋一个值的方式来进行指令参数的传递

```
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

```
Using mustaches: <span style="color: red">This should be red.</span>

Using v-html directive: This should be red.
```

这个 `span` 的内容将会被替换成为 property 值 `rawHtml`，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 `v-html` 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。

你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。



##### [Attribute](https://cn.vuejs.org/v2/guide/syntax.html#Attribute)                         使用vue.js为html标签动态绑定属性

Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 [`v-bind` 指令](https://cn.vuejs.org/v2/api/#v-bind)：

```
<div v-bind:id="dynamicId"></div>    语法格式   v-bind:标签所具有的属性="某一个变量（的值）"
可以绑定id  class
```

对于布尔 attribute (它们只要存在就意味着值为 `true`)，`v-bind` 工作起来略有不同，在这个例子中：

```
<button v-bind:disabled="isButtonDisabled">Button</button>
```

如果 `isButtonDisabled` 的值是 `null`、`undefined` 或 `false`，则 `disabled` attribute 甚至不会被包含在渲染出来的 `` 元素中。

例子：

```
<div id="app">
	{{msg}}
	<p>Using mustaches: {{ rawHtml }}</p>
	<p v-html="rawHtml"></p>
	<div v-bind:class="color">test...</div>   绑定一个class   给HTML元素绑定一个动态的样式 color是一个变量的值   ----要赋值
	<p>{{ number + 1 }}</p>
	<p>{{ 1 == 1 ? 'YES' : 'NO' }}</p>
	<p>{{ message.split('').reverse().join('') }}</p>
</div>
<script type="text/javascript">
var vm = new Vue({
	el : "#app",
	data : {
		msg : "hi vue",
		rawHtml : '<span style="color:red">this is should be red</span>',  v-html里是""所以这里用''
		color:'red',//可以再去绑定blue  来对样式进行动态的变化
		number : 10,
		ok : 1,
		message : "vue"
	}
});
vm.msg = "hi....";

</script>
<style type="text/css">   在css中声明red的样式
.red{color:red;}
.blue{color:blue; font-size:100px;}
</style>
```

##### [使用 JavaScript 表达式](https://cn.vuejs.org/v2/guide/syntax.html#使用-JavaScript-表达式)

迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值对。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。

```
{{ number + 1 }}      对变量的算术运算

{{ ok ? 'true' : 'false' }}   三元运算  第一个是一个变量或者一个条件运算的结果问号前面可以是变量bool类型 更支持比较运算的结果   页面上可以对ok赋值ok为true或1等非false的数字为输出文本true  也可是1==3这种比较运算

{{ message.split('').reverse().join('') }}  使用复杂的函数运算  核心变量是message将这个变量的内容（字符串）以没有任何内容的方式拆分成字母split函数返回一个数组  reverse将数组反序 然后结合成一个字符串（结合的字母间没有任何间隔或内容）
<div v-bind:id="'list-' + id"></div>
```

这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。

```
<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}

<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

模板表达式都被放在沙盒中，只能访问[全局变量的一个白名单](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9)，如 `Math` 和 `Date` 。你不应该在模板表达式中试图访问用户定义的全局变量。

### 模板语法-指令

指令 (Directives) 是带有 `v-` 前缀的特殊特性。指令 attribute特性的值预期是**单个 JavaScript 表达式** (`v-for` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：

```
<p v-if="seen">现在你看到我了</p>
```

这里，`v-if` 指令将根据表达式 （data中的属性）`seen`属性 的值的真假来插入(渲染)/移除p 元素。

```
<div id="app">
	<p v-if="seen">现在你看到我了</p>
	<a v-bind:href="url">...</a>
	<div @click="click1">
		<div @click.stop="click2">
			click me
		</div>
	</div>
</div>
<script type="text/javascript">
var vm = new Vue({
	el : "#app",
	data : {
		seen : false,
		url : "https://cn.vuejs.org/v2/guide/syntax.html#%E6%8C%87%E4%BB%A4"
	},
	methods:{
		click1 : function () {
			console.log('click1......');
		},
		click2 : function () {
			console.log('click2......');
		}
	}
});
</script>
```



##### [参数](https://cn.vuejs.org/v2/guide/syntax.html#参数)

一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML 属性attribute：

```
<a v-bind:href="url">...</a>      v-bind为a标签绑定了一个href属性  然后为data对象的url属性赋值
```

在这里 `href` 是参数，告知 `v-bind` 指令将该元素的 `href` attribute 与表达式 `url` 的值绑定。

另一个例子是 `v-on` 指令，它用于监听 DOM 事件：

```
<a v-on:click="doSomething">...</a>
```

在这里参数是监听的事件名。我们也会更详细地讨论事件处理。

##### [动态参数](https://cn.vuejs.org/v2/guide/syntax.html#动态参数)

> 2.6.0 新增

从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：

```
<!--
注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。
-->
<a v-bind:[attributeName]="url"> ... </a>
```

这里的 `attributeName` 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 `data` property `attributeName`，其值为 `"href"`，那么这个绑定将等价于 `v-bind:href`。

同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：

```
<a v-on:[eventName]="doSomething"> ... </a>
```

在这个示例中，当 `eventName` 的值为 `"focus"` 时，`v-on:[eventName]` 将等价于 `v-on:focus`。

##### 对动态参数的值的约束

动态参数预期会求出一个字符串，异常情况下值为 `null`。这个特殊的 `null` 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。

##### 对动态参数表达式的约束

动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：

```
<!-- 这会触发一个编译警告 -->
<a v-bind:['foo' + bar]="value"> ... </a>
```

变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。

在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：

```
<!--
在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。
除非在实例中有一个名为“someattr”的 property，否则代码不会工作。
-->
<a v-bind:[someAttr]="value"> ... </a>
```

##### [修饰符](https://cn.vuejs.org/v2/guide/syntax.html#修饰符)       指令的修饰符

修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：

```
<form v-on:submit.prevent="onSubmit">...</form>

<div id="app">
	<p v-if="seen">现在你看到我了</p>
	<a v-bind:href="url">...</a>
	<div @click="click1">    //绑定点击事件  @click指令可以为某一个元素绑定对应的事件  绑定的是click1函数
		<div @click.stop="click2">
			click me    点击这个时同样click1也会被触发点击事件    只希望执行click2而不执行父类的事件可以使用@click.stop后缀的方式 vue.js的修饰符  stop指当前的事件一旦执行完毕后就会停下来
		</div>
	</div>
</div>
<script type="text/javascript">
var vm = new Vue({            //初始化vue对象时 使用methods属性 在属性内部使用键值对的方式声明对应的方法和函数体
	el : "#app",
	data : {
		seen : false,
		url : "https://cn.vuejs.org/v2/guide/syntax.html#%E6%8C%87%E4%BB%A4"
	},
	methods:{
		click1 : function () {
			console.log('click1......');
		},
		click2 : function () {
			console.log('click2......');
		}
	}
});
</script>
```

在接下来对 [`v-on`](https://cn.vuejs.org/v2/guide/events.html#事件修饰符) 和 [`v-for`](https://cn.vuejs.org/v2/guide/forms.html#修饰符) 等功能的探索中，你会看到修饰符的其它例子。

##### [缩写](https://cn.vuejs.org/v2/guide/syntax.html#缩写)

`v-` 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，`v-` 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的[单页面应用程序 (SPA - single page application)](https://en.wikipedia.org/wiki/Single-page_application) 时，`v-` 前缀也变得没那么重要了。因此，Vue 为 `v-bind` 和 `v-on` 这两个最常用的指令，提供了特定简写：

##### [`v-bind` 缩写](https://cn.vuejs.org/v2/guide/syntax.html#v-bind-缩写)

```
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a :[key]="url"> ... </a>
```

[`v-on` 缩写  ](https://cn.vuejs.org/v2/guide/syntax.html#v-on-缩写)     重点  注意！

```
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
```

它们看起来可能与普通的 HTML 略有不同，但 `:` 与 `@` 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。

### Class与style绑定

 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性attribute，所以我们可以用 `v-bind` 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 

绑定html class

##### [对象语法](https://cn.vuejs.org/v2/guide/class-and-style.html#对象语法)

我们可以传给 `v-bind:class` 一个对象，以动态地切换 class：

```
<div v-bind:class="{ active: isActive }"></div>  动态添加一个名称为active的class属性通过v-bind语法  active样式是否绑定在标签上取决于isactive变量的值

<div id="app">
	<div 
	class="test"   静态的test样式  普通的class
	v-bind:class="[ isActive ? 'active' : '', isGreen ? 'green' : '']" v-bind语法支持数组形式"['active','green']"-----绑定active样式和green样式 两个class 静态样式    动态 : 支持三元运算为某一个样式进行动态的赋值  三元运算来判断isactive是否为真  来绑定返回的对应的样式
	绑定多个动态的样式{ active: isActive,green:isgreen }
	style="width:200px; height:200px; text-align:center; line-height:200px;">文字垂直水平居中
		hi vue
	</div>
	
	<div 
	:style="{color:color, fontSize:size, background: isRed ? '#FF0000' : ''}">
		hi vue
	</div>
</div>
<script type="text/javascript">
var vm = new Vue({
	el : "#app",
	data : {
		isActive : true,   //初始化为true   false则div上不会绑定名称为active的class
		isGreen : true,
		color : "#FFFFFF",
		size : '50px',
		isRed : true
	}
});
</script>
<style>
.test{font-size:30px;}
.green{color:#00FF00;}
.active{background:#FF0000;} 红色  //声明active样式
</style>
```

上面的语法表示 `active` 这个 class 存在与否将取决于数据 property `isActive` 的 [truthiness](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)。

你可以在对象中传入更多字段来动态切换多个 class。此外，`v-bind:class` 指令也可以与普通的 class attribute 共存。当有如下模板：

```
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```

和如下 data：

```
data: {
  isActive: true,
  hasError: false
}
```

结果渲染为：

```
<div class="static active"></div>
```

当 `isActive` 或者 `hasError` 变化时，class 列表将相应地更新。例如，如果 `hasError` 的值为 `true`，class 列表将变为 `"static active text-danger"`。

绑定的数据对象不必内联定义在模板里：

```
<div v-bind:class="classObject"></div>
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
```

渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的[计算属性](https://cn.vuejs.org/v2/guide/computed.html)。这是一个常用且强大的模式：

```
<div v-bind:class="classObject"></div>
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```

##### [数组语法](https://cn.vuejs.org/v2/guide/class-and-style.html#数组语法)

我们可以把一个数组传给 `v-bind:class`，以应用一个 class 列表：

```
<div v-bind:class="[activeClass, errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

渲染为：

```
<div class="active text-danger"></div>
```

如果你也想根据条件切换列表中的 class，可以用三元表达式：

```
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```

这样写将始终添加 `errorClass`，但是只有在 `isActive` 是 truthy[[1\]](https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1) 时才添加 `activeClass`。

不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：

```
<div v-bind:class="[{ active: isActive }, errorClass]"></div>
```

##### [用在组件上](https://cn.vuejs.org/v2/guide/class-and-style.html#用在组件上)

> 这个章节假设你已经对 [Vue 组件](https://cn.vuejs.org/v2/guide/components.html)有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。

当在一个自定义组件上使用 `class` property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。

例如，如果你声明了这个组件：

```
Vue.component('my-component', {
  template: '<p class="foo bar">Hi</p>'
})
```

然后在使用它的时候添加一些 class：

```
<my-component class="baz boo"></my-component>
```

HTML 将被渲染为：

```
<p class="foo bar baz boo">Hi</p>
```

对于带数据绑定 class 也同样适用：

```
<my-component v-bind:class="{ active: isActive }"></my-component>
```

当 `isActive` 为 truthy[[1\]](https://cn.vuejs.org/v2/guide/class-and-style.html#footnote-1) 时，HTML 将被渲染成为：

```
<p class="foo bar active">Hi</p>
```

#### [绑定内联样式](https://cn.vuejs.org/v2/guide/class-and-style.html#绑定内联样式)   v-bind语法为html标签动态绑定style

##### [对象语法](https://cn.vuejs.org/v2/guide/class-and-style.html#对象语法-1)    

`v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：

```
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
或者

<div 
	:style="{color:color, fontSize:size, background: isRed ? '#FF0000' : ''}">  可以使用三元运算对元素实现动态样式绑定  background是否取值为'#FF0000'取决于isRed变量
		hi vue
</div>     color对象属性取值为一个color变量的值
<script type="text/javascript">
var vm = new Vue({
	el : "#app",
	data : {    data内进行赋值和注册
		isActive : true,
		isGreen : true,
		color : "#FF00FF",
		size : '50px', //vue.js语法中 除了bool  int等数值类型外动用''包围起来
		isRed : true
	}
});
</script>


data: {
  activeColor: 'red',
  fontSize: 30
}
```

直接绑定到一个样式对象通常更好，这会让模板更清晰：

```
<div v-bind:style="styleObject"></div>
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
```

同样的，对象语法常常结合返回对象的计算属性使用。

##### [数组语法](https://cn.vuejs.org/v2/guide/class-and-style.html#数组语法-1)

`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：

```
<div v-bind:style="[baseStyles, overridingStyles]"></div>
```

##### [自动添加前缀](https://cn.vuejs.org/v2/guide/class-and-style.html#自动添加前缀)

当 `v-bind:style` 使用需要添加[浏览器引擎前缀](https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix)的 CSS property 时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。

##### [多重值](https://cn.vuejs.org/v2/guide/class-and-style.html#多重值)

> 2.3.0+

从 2.3.0 起你可以为 `style` 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：

```
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 `display: flex`。
**译者注**
[1] truthy 不是 `true`，详见 [MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 的解释。

← [计算属性和侦听器](https://cn.vuejs.org/v2/guide/computed.html)[条件渲染](https://cn.vuejs.org/v2/guide/conditional.html) →

### 条件渲染

`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 真truthy 值的时候被渲染。

```
<h1 v-if="awesome">Vue is awesome!</h1>
```

也可以用 `v-else` 添加一个“else 块”：

```
<h1 v-if="awesome">Vue is awesome!</h1>
<h1 v-else>Oh no 😢</h1>
```

#### [在 ` 元素上使用 `v-if` 条件渲染分组](https://cn.vuejs.org/v2/guide/conditional.html#在-lt-template-gt-元素上使用-v-if-条件渲染分组)

因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 ` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 ` 元素。

```
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
```

##### [`v-else`](https://cn.vuejs.org/v2/guide/conditional.html#v-else)

你可以使用 `v-else` 指令来表示 `v-if` 的“else 块”：

```
<div v-if="Math.random() > 0.5">
  Now you see me
</div>
<div v-else>
  Now you don't
</div>
```

`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。

##### [`v-else-if`](https://cn.vuejs.org/v2/guide/conditional.html#v-else-if)

> 2.1.0 新增

`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用：

```
<div v-if="type === 'A'">    等于===
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```

类似于 `v-else`，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后。

#### [用 `key` 管理可复用的元素](https://cn.vuejs.org/v2/guide/conditional.html#用-key-管理可复用的元素)

Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：

```
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address">
</template>
```

那么在上面的代码中切换 `loginType` 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`` 不会被替换掉——仅仅是替换了它的 `placeholder`。

自己动手试一试，在输入框中输入一些文本，然后按下切换按钮：

Username 

Toggle login type

这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` attribute 即可：

```
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```

现在，每次切换时，输入框都将被重新渲染。请看：

Username 

Toggle login type

注意，`` 元素仍然会被高效地复用，因为它们没有添加 `key` attribute。

##### [`v-show`](https://cn.vuejs.org/v2/guide/conditional.html#v-show)     = 一个表达式

另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样：  

```
<h1 v-show="ok">Hello!</h1>    ok变量没有被声明默认是false  data中声明赋值为true则显示h1
```

不同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS 样式的property 属性`display`取值null   block。

注意，`v-show` 不支持 ` 元素，也不支持 `v-else`。

##### [`v-if` vs `v-show`](https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show)

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

##### [`v-if` 与 `v-for` 一起使用](https://cn.vuejs.org/v2/guide/conditional.html#v-if-与-v-for-一起使用)

**不推荐**同时使用 `v-if` 和 `v-for`。请查阅[风格指南](https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起-必要)以获取更多信息。

当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。请查阅[列表渲染指南](https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if)以获取详细信息。

### 列表渲染

数组形式的列表渲染

#### [用 `v-for` 把一个数组对应为一组元素](https://cn.vuejs.org/v2/guide/list.html#用-v-for-把一个数组对应为一组元素)

我们可以用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。

```
<ul id="example-1">
  <li v-for="item in items" :key="item.message">   使用v-for指令对item标签进行了列表渲染  v-for指令对items数组迭代时会得到item对象每一个对象有message属性
    {{ item.message }}
  </li>
</ul>

script----------------------------------
var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [    //每一个数组元素都是一个对象
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

结果：

- Foo
- Bar

在 `v-for` 块中，我们可以访问所有父作用域的 property。`v-for` 还支持一个可选的第二个参数，即当前项的索引。

```
<ul id="example-2">
  <li v-for="(item, index) in items">   item代表数组的某一个项目  这种语法格式表示迭代过程中获取两个元素	  一个是数组的元素  另外一个是数组的索引  index变量可以访问	
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

结果：

- Parent - 0 - Foo
- Parent - 1 - Bar

你也可以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法：

```
<div v-for="item of items"></div>
```

#### [在 `v-for` 里使用对象](https://cn.vuejs.org/v2/guide/list.html#在-v-for-里使用对象)

你也可以用 `v-for` 来遍历一个对象的属性 property。

```
<ul id="v-for-object" class="demo">
  <li v-for="value in object">  //v-for对objects对象进行列表渲染	  每一次迭代得到一个属性对应的值
    {{ value }}
  </li>
</ul>

script--------------------
new Vue({
  el: '#v-for-object',
  data: {
    object: { //对象具有的属性  
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
```

结果：

- How to do lists in Vue
- Jane Doe
- 2016-04-10

你也可以提供第二个的参数为 property 名称 (也就是键名)：

```
<div v-for="(value, name) in object">   对象渲染时可以获取对象的键key或者name  等价   可以不加()
  {{ name }}: {{ value }}
</div>
```

title: How to do lists in Vue

author: Jane Doe

publishedAt: 2016-04-10

还可以用第三个参数作为索引：

```
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```

\0. title: How to do lists in Vue

\1. author: Jane Doe

\2. publishedAt: 2016-04-10

在遍历对象时，会按 `Object.keys()` 的结果遍历，但是**不能**保证它的结果在不同的 JavaScript 引擎下都一致。

#### [维护状态](https://cn.vuejs.org/v2/guide/list.html#维护状态)

当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 `track-by="$index"`。

这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` attribute：

```
<div v-for="item in items" v-bind:key="item.id">   v-bind:  缩写 :  添加key属性赋值 index唯一
  <!-- 内容 -->
</div>

<ul>
		<li v-for="item,index in items" :key="index">  key唯一
		{{index}}{{ item.message }}
		</li>
	</ul>
	<ul>
		<li v-for="value, key in object">
			{{key}} : {{ value }}
		</li>
	</ul>
```

建议尽可能在使用 `v-for` 时提供 `key` attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。

因为它是 Vue 识别节点的一个通用机制，`key` 并不仅与 `v-for` 特别关联。后面我们将在指南中看到，它还具有其它用途。

不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`。请用字符串或数值类型的值。

更多 `key` attribute 的细节用法请移步至 [`key` 的 API 文档](https://cn.vuejs.org/v2/api/#key)。

### 事件绑定 处理

#### [监听事件](https://cn.vuejs.org/v2/guide/events.html#监听事件)

可以用 `v-on` 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。

示例：

```
<div id="example-1">
  <button v-on:click="counter += 1">Add 1</button>  //v-on指令为button绑定click事件  事件被触发count++
  <p>The button above has been clicked {{ counter }} times.</p>
</div>
var example1 = new Vue({
  el: '#example-1',
  data: {
    counter: 0  //data对象内注册count属性
  }
})
```

#### [事件处理方法](https://cn.vuejs.org/v2/guide/events.html#事件处理方法)

然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 还可以接收一个需要调用的javascript函数|方法名称。

v-on指令可以绑定html元素拥有的所有的事件   每一个html都会有对应的事件 只需要使用：对事件进行绑定即可

click单击事件   dblclick双击事件

示例：  

```
<div id="example-2">
  <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>  button被点击时触发greet函数  可以再代用函数时传递参数 可以传递实参如字符串'abc'
</div>
var example2 = new Vue({  vue.js中声明函数
  el: '#example-2',
  data: {
    name: 'Vue.js'
  },
  // 在 `methods` 对象中定义方法  初始化对象时传递的对象参数内添加一个methods属性  属性内声明函数及函数体  函数内可以调用data中的数据  
  methods: {
    greet: function (event) {
      // `this` 在方法里指向当前 Vue 实例对象
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
      if (event) {
        alert(event.target.tagName)
      }
    }
  }
})

// 也可以用 JavaScript 直接调用方法
example2.greet() // => 'Hello Vue.js!'
```

#### [内联处理器中的方法](https://cn.vuejs.org/v2/guide/events.html#内联处理器中的方法)

除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：

```
<div id="example-3">
  <button v-on:click="say('hi')">Say hi</button>
  <button v-on:click="say('what')">Say what</button>
</div>
new Vue({
  el: '#example-3',
  methods: {
    say: function (message) {
      alert(message)
    }
  }
})
```

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```
<button v-on:click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) {                          可以使用控制台console观察event变量  打印event对象的详细信息
      event.preventDefault()
    }
    alert(message)
  }
}
```

#### [事件修饰符](https://cn.vuejs.org/v2/guide/events.html#事件修饰符)

在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。

为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**。之前提过，修饰符是由点开头的指令后缀来表示的。

- `.stop`
- `.prevent`
- `.capture`
- `.self`
- `.once`
- `.passive`

```
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```

使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**，而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。

> 2.1.4 新增

```
<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>
```

不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的[组件事件](https://cn.vuejs.org/v2/guide/components-custom-events.html)上。如果你还没有阅读关于组件的文档，现在大可不必担心。

> 2.3.0 新增

Vue 还对应 [`addEventListener` 中的 `passive` 选项](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters)提供了 `.passive` 修饰符。

```
<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

这个 `.passive` 修饰符尤其能够提升移动端的性能。

不要把 `.passive` 和 `.prevent` 一起使用，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，`.passive` 会告诉浏览器你*不*想阻止事件的默认行为。

#### [按键修饰符](https://cn.vuejs.org/v2/guide/events.html#按键修饰符)

在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：

```
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

你可以直接将 [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。

```
<input v-on:keyup.page-down="onPageDown">
```

在上述示例中，处理函数只会在 `$event.key` 等于 `PageDown` 时被调用。

##### [按键码](https://cn.vuejs.org/v2/guide/events.html#按键码)

`keyCode` 的事件用法[已经被废弃了](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode)并可能不会被最新的浏览器支持。

使用 `keyCode` attribute 也是允许的：

```
<input v-on:keyup.13="submit">
```

为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：

- `.enter`
- `.tab`
- `.delete` (捕获“删除”和“退格”键)
- `.esc`
- `.space`
- `.up`
- `.down`
- `.left`
- `.right`

有一些按键 (`.esc` 以及所有的方向键) 在 IE9 中有不同的 `key` 值, 如果你想支持 IE9，这些内置的别名应该是首选。

你还可以通过全局 `config.keyCodes` 对象[自定义按键修饰符别名](https://cn.vuejs.org/v2/api/#keyCodes)：

```
// 可以使用 `v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112
```

#### [系统修饰键](https://cn.vuejs.org/v2/guide/events.html#系统修饰键)

> 2.1.0 新增

可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。

- `.ctrl`
- `.alt`
- `.shift`
- `.meta`

> 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。

例如：

```
<!-- Alt + C -->
<input v-on:keyup.alt.67="clear">

<!-- Ctrl + Click -->
<div v-on:click.ctrl="doSomething">Do something</div>
```

请注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。如果你想要这样的行为，请为 `ctrl` 换用 `keyCode`：`keyup.17`。

##### [`.exact` 修饰符](https://cn.vuejs.org/v2/guide/events.html#exact-修饰符)

> 2.5.0 新增

`.exact` 修饰符允许你控制由精确的系统修饰符组合触发的事件。

```
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button v-on:click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button v-on:click.exact="onClick">A</button>
```

##### [鼠标按钮修饰符](https://cn.vuejs.org/v2/guide/events.html#鼠标按钮修饰符)

> 2.2.0 新增

- `.left`
- `.right`
- `.middle`

这些修饰符会限制处理函数仅响应特定的鼠标按钮。

##### [为什么在 HTML 中监听事件？](https://cn.vuejs.org/v2/guide/events.html#为什么在-HTML-中监听事件？)

你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 `v-on` 有几个好处：

1. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。
2. 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。
3. 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。

### 表单输入绑定

你可以用 `v-model` 指令在表单 ``、`` 及 `` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。

`v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 `data` 选项中声明初始值。

`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

- text 和 textarea 元素使用 `value`属性 property 和 `input` 事件；
- checkbox 和 radio 使用 `checked` 属性property 和 `change` 事件；
- select 字段将 `value` 作为 prop 并将 `change` 作为事件。

对于需要使用[输入法](https://zh.wikipedia.org/wiki/输入法) (如中文、日文、韩文等) 的语言，你会发现 `v-model` 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 `input` 事件。

```
<div id="app">
	<div id="example-1">
		<input v-model="message" placeholder="edit me">
		<p>Message is: {{ message }}</p>
		<textarea v-model="message2" placeholder="add multiple lines"></textarea>
		<p style="white-space: pre-line;">{{ message2 }}</p>
		<br />
		
		<div style="margin-top:20px;">
			<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
			<label for="jack">Jack</label>
			<input type="checkbox" id="john" value="John" v-model="checkedNames">
			<label for="john">John</label>
			<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
			<label for="mike">Mike</label>
			<br>
			<span>Checked names: {{ checkedNames }}</span>
		</div>
		
		<div style="margin-top:20px;">
			<input type="radio" id="one" value="One" v-model="picked">
			<label for="one">One</label>
			<br>
			<input type="radio" id="two" value="Two" v-model="picked">
			<label for="two">Two</label>
			<br>
			<span>Picked: {{ picked }}</span>
		</div>      完成和表单提交
		<button type="button" @click="submit">提交</button>  创建提交按钮 绑定点击事件
	</div>
	
</div>
<script type="text/javascript">
var vm = new Vue({
	el : "#app",
	data : {   表单元素发生变化时  data对象对应属性内都可以收集到表单元素对应的值
		message : "test",
		message2 :"hi",
		checkedNames : ['Jack', 'John'],
		picked : "Two"
	},
	methods: {
		submit : function () {  通过this对象获取每一个表单元素的值   可以声明对象形式的变量将表单元素的所有值保存下来
			console.log(this.message);
			var postObj={
			msg1:this.message,
			msg2:this.message2,
			checkval:this.checkNames
			};
			console.log(postObj);  利用这个变量实现表单的提交工作
		}
	}
});
</script>
```

对表单元素默认值进行设置：可以设置变单元素默认值   通过改变data对象的属性来对表单元素默认值进行设置

#### [文本](https://cn.vuejs.org/v2/guide/forms.html#文本)

```
<input v-model="message" placeholder="edit me">   v-model指令进行双向数据绑定   绑定所对应的data对象的属性是message   data对象中进行注册并注册空值
<p>Message is: {{ message }}</p>
```

Message is:

#### [多行文本](https://cn.vuejs.org/v2/guide/forms.html#多行文本)

```
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

Multiline message is:





在文本区域插值 (`{{text}}`) 并不会生效，应用 `v-model` 来代替。

#### [复选框](https://cn.vuejs.org/v2/guide/forms.html#复选框)

单个复选框，绑定到布尔值：

```
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
```

 false

多个复选框，绑定到同一个数组：

```
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">   选项选中后对应value保存进双向绑定对应的数组checkedNames中   显示值时有""其他类似文本框没有
<label for="mike">Mike</label>
<br>
<span>Checked names: {{ checkedNames }}</span>
new Vue({
  el: '...',
  data: {
    checkedNames: []     data对象中属性变量进行初始化  复选框可能还会选中多个元素保存时使用数组	
  }
})
```

 Jack John Mike
Checked names: []

#### [单选按钮](https://cn.vuejs.org/v2/guide/forms.html#单选按钮)

```
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
new Vue({
  el: '#example-4',
  data: {
    picked: ''   使用普通字符串变量进行保存
  }
})
```

 One
 Two
Picked:

#### [选择框](https://cn.vuejs.org/v2/guide/forms.html#选择框)

单选时：

```
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
```

请选择 A B C Selected:

如果 `v-model` 表达式的初始值未能匹配任何选项，`` 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。

多选时 (绑定到一个数组)：

```
<div id="example-6">
  <select v-model="selected" multiple style="width: 50px;">
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <br>
  <span>Selected: {{ selected }}</span>
</div>
new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})
```

A B C
Selected: []

用 `v-for` 渲染的动态选项：

```
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value">
    {{ option.text }}
  </option>
</select>
<span>Selected: {{ selected }}</span>
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
```

​     One       Two       Three   Selected: A

#### [值绑定](https://cn.vuejs.org/v2/guide/forms.html#值绑定)

对于单选按钮，复选框及选择框的选项，`v-model` 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：

```
<!-- 当选中时，`picked` 为字符串 "a" -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` 为 true 或 false -->
<input type="checkbox" v-model="toggle">

<!-- 当选中第一个选项时，`selected` 为字符串 "abc" -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
```

但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 `v-bind` 实现，并且这个 property 的值可以不是字符串。

#### [复选框](https://cn.vuejs.org/v2/guide/forms.html#复选框-1)

```
<input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no"
>
// 当选中时
vm.toggle === 'yes'
// 当没有选中时
vm.toggle === 'no'
```

这里的 `true-value` 和 `false-value` attribute 并不会影响输入控件的 `value` attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。

#### [单选按钮](https://cn.vuejs.org/v2/guide/forms.html#单选按钮-1)

```
<input type="radio" v-model="pick" v-bind:value="a">
// 当选中时
vm.pick === vm.a
```

#### [选择框的选项](https://cn.vuejs.org/v2/guide/forms.html#选择框的选项)

```
<select v-model="selected">
    <!-- 内联对象字面量 -->
  <option v-bind:value="{ number: 123 }">123</option>
</select>
// 当选中时
typeof vm.selected // => 'object'
vm.selected.number // => 123
```

#### [修饰符](https://cn.vuejs.org/v2/guide/forms.html#修饰符)

#### [`.lazy`](https://cn.vuejs.org/v2/guide/forms.html#lazy)

在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 (除了[上述](https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip)输入法组合文字时)。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：

```
<!-- 在“change”时而非“input”时更新 -->
<input v-model.lazy="msg">
```

#### [`.number`](https://cn.vuejs.org/v2/guide/forms.html#number)

如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：

```
<input v-model.number="age" type="number">
```

这通常很有用，因为即使在 `type="number"` 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()` 解析，则会返回原始的值。

#### [`.trim`](https://cn.vuejs.org/v2/guide/forms.html#trim)

如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：

```
<input v-model.trim="msg">
```

#### [在组件上使用 `v-model`](https://cn.vuejs.org/v2/guide/forms.html#在组件上使用-v-model)

> 如果你还不熟悉 Vue 的组件，可以暂且跳过这里。

HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 `v-model` 一起使用！

### 组件基础

#### [基本示例](https://cn.vuejs.org/v2/guide/components.html#基本示例)

这里有一个 Vue 组件的示例：   vue.js使用vue.component函数去创建一个组件   第一个参数时这个组件的名称  第二个参数以对象的形式描述一个组件  data必须是一个函数

```
// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
```

##### [`data` 必须是一个函数](https://cn.vuejs.org/v2/guide/components.html#data-必须是一个函数)

当我们定义这个 `` 组件时，你可能会发现它的 `data` 并不是像这样直接提供一个对象：

```
data: {
  count: 0
}
```

取而代之的是，**一个组件的 `data` 选项必须是一个函数**，因此每个实例可以维护一份被返回对象的独立的拷贝：

```
data: function () {
  return {
    count: 0
  }
}
```

如果 Vue 没有这条规则，点击一个按钮就可能会影响到*其它所有实例*。

组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 ``。我们可以在一个通过 `new Vue` 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：

```
<div id="components-demo">
  <button-counter></button-counter>
</div>
new Vue({ el: '#components-demo' })
```

```
<div id="app">    组件标签内部可以插入任意的html标签内容
	<button-counter title="title1 : " @clicknow="clicknow">
		<h2>hi...h2</h2>
	</button-counter>               使用html标签的形式对组件进行调用  标签名就是就是组件的名称  每个组件数据封闭在组件内部相互不影响
	<button-counter title="title2 : "></button-counter>   调用组件时可以对组件的属性进行赋值
</div>
<script type="text/javascript">
Vue.component('button-counter', {   vue.component函数创建一个button-conter组件   接下来描述整个组件的数据和模板内容  组件的模板内容为一个按钮  按钮被点击时  模板的count会+1
	props: ['title'],      为组件定义属性   定义了title属性
	data: function () {
		return {
		  count: 0
		}                             模板内容中对组件属性进行应用和渲染
	},                        创建一个组件时组件内容必须具有一个根节点     组件的事件监听javascript脚本改为一个可执行的js函数	
	template: '<div><h1>hi...</h1><button v-on:click="(最开始是count+1)clickfun">{{title}} You clicked me {{ count }} times.</button><slot></slot></div>',    模板内可以通过solt标签去声明一个插槽  通过插槽可以插入任意的html内容及标签
	methods:{          methods属性来声明对应的函数
		clickfun : function () {
			this.count ++;       函数内部 使用this对象对count数据进行处理
			this.$emit('clicknow', this.count);   this对象的emit函数去触发一个事件  第一个参数是事件名称  第二个参数是触发这个事件时可携带的一些参数    此处声明了一个函数 ： 点击button按钮后会触发一个（事件）并且携带了当前count的值   在组件的父级就可以通过事件绑定的方式去接受emit触发的事件    在页面上同样通过methods属性去声明相应的接收到emit触发的事件后执行的方法  这个方法可以接受对应的参数
		}
	}
})
var vm = new Vue({               
	el : "#app",
	data : {
		
	},
	methods:{
		clicknow : function (e) {
			console.log(e);
		}
	}
});
</script>
```



### 组件注册

```
<script type="text/javascript">
Vue.component('button-counter', {   实现了全局注册
	props: ['title'],
	data: function () {
		return {}
	},
	template: '<div><h1>hi...</h1></div>',
	methods:{
		
	}
})
var vm = new Vue({   实现局部注册在创建Vue实例对象时即对Vue函数进行初始化的时候  在vue函数的参数--对象形式内声明一个components属性  声明后就可以在它内部进行组建的局部注册
	el : "#app",
	data : {
		
	},
	methods:{
		clicknow : function (e) {
			console.log(e);
		}
	},       页面上可以再id===app的vue组件中直接用test标签去调用test局部组件
	components:{
		test : {   注册一个组件 名称叫test  声明成一个对象的形式  使用template属性进行模板的赋值
			template:"<h2>h2...</h2>"，
			methods:{  在这个组件内部可以通过methods属性去声明这个组件的方法   data去声明这个局部组件的数据
			
			}
		}
	}
});
</script>
```



#### [组件名](https://cn.vuejs.org/v2/guide/components-registration.html#组件名)

在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了：

```
Vue.component('my-component-name', { /* ... */ })
```

该组件名就是 `Vue.component` 的第一个参数。

你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或[单文件组件](https://cn.vuejs.org/v2/guide/single-file-components.html)) 的时候，我们强烈推荐遵循 [W3C 规范](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name)中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。

你可以在[风格指南](https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐)中查阅到关于组件名的其它建议。

#### [组件名大小写](https://cn.vuejs.org/v2/guide/components-registration.html#组件名大小写)

定义组件名的方式有两种：

#### 使用 kebab-case

```
Vue.component('my-component-name', { /* ... */ })
```

当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 ``。

#### 使用 PascalCase

```
Vue.component('MyComponentName', { /* ... */ })
```

当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 `` 和 `` 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。

#### [全局注册](https://cn.vuejs.org/v2/guide/components-registration.html#全局注册)

到目前为止，我们只用过 `Vue.component` 来创建组件：

```
Vue.component('my-component-name', {
  // ... 选项 ...
})
```

这些组件是**全局注册的**。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (`new Vue`) 的模板中。比如：

```
Vue.component('component-a', { /* ... */ })
Vue.component('component-b', { /* ... */ })
Vue.component('component-c', { /* ... */ })

new Vue({ el: '#app' })
<div id="app">
  <component-a></component-a>
  <component-b></component-b>
  <component-c></component-c>
</div>
```

在所有子组件中也是如此，也就是说这三个组件*在各自内部*也都可以相互使用。

#### [局部注册](https://cn.vuejs.org/v2/guide/components-registration.html#局部注册)

全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。

在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：

```
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
```

然后在 `components` 选项中定义你想要使用的组件：

```
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```

对于 `components` 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。

注意**局部注册的组件在其子组件中\*不可用\***。例如，如果你希望 `ComponentA` 在 `ComponentB` 中可用，则你需要这样写：

```
var ComponentA = { /* ... */ }

var ComponentB = {
  components: {
    'component-a': ComponentA
  },
  // ...
}
```

或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：

```
import ComponentA from './ComponentA.vue'

export default {
  components: {
    ComponentA
  },
  // ...
}
```

注意在 ES2015+ 中，在对象中放一个类似 `ComponentA` 的变量名其实是 `ComponentA: ComponentA` 的缩写，即这个变量名同时是：

- 用在模板中的自定义元素的名称
- 包含了这个组件选项的变量名

#### [模块系统](https://cn.vuejs.org/v2/guide/components-registration.html#模块系统)

如果你没有通过 `import`/`require` 使用一个模块系统，也许可以暂且跳过这个章节。如果你使用了，那么我们会为你提供一些特殊的使用说明和注意事项。

##### [在模块系统中局部注册](https://cn.vuejs.org/v2/guide/components-registration.html#在模块系统中局部注册)

如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 `components` 目录，并将每个组件放置在其各自的文件中。

然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 `ComponentB.js` 或 `ComponentB.vue` 文件中：

```
import ComponentA from './ComponentA'    import组件名称from组件位置方式 去引入一个组件   vue对象内部通过components属性进行组件的局部注册   单文件组件用
import ComponentC from './ComponentC'

export default {
  components: {
    ComponentA,
    ComponentC
  },
  // ...
}
```

现在 `ComponentA` 和 `ComponentC` 都可以在 `ComponentB` 的模板中使用了。

##### [基础组件的自动化全局注册](https://cn.vuejs.org/v2/guide/components-registration.html#基础组件的自动化全局注册)

可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为[基础组件](https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐)，它们会在各个组件中被频繁的用到。

所以会导致很多组件里都会有一个包含基础组件的长列表：

```
import BaseButton from './BaseButton.vue'
import BaseIcon from './BaseIcon.vue'
import BaseInput from './BaseInput.vue'

export default {
  components: {
    BaseButton,
    BaseIcon,
    BaseInput
  }
}
```

而只是用于模板中的一小部分：

```
<BaseInput
  v-model="searchText"
  @keydown.enter="search"
/>
<BaseButton @click="search">
  <BaseIcon name="search"/>
</BaseButton>
```

如果你恰好使用了 webpack (或在内部使用了 webpack 的 [Vue CLI 3+](https://github.com/vuejs/vue-cli))，那么就可以使用 `require.context` 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 `src/main.js`) 中全局导入基础组件的示例代码：

```
import Vue from 'vue'
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

const requireComponent = require.context(
  // 其组件目录的相对路径
  './components',
  // 是否查询其子目录
  false,
  // 匹配基础组件文件名的正则表达式
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  // 获取组件配置
  const componentConfig = requireComponent(fileName)

  // 获取组件的 PascalCase 命名
  const componentName = upperFirst(
    camelCase(
      // 获取和目录深度无关的文件名
      fileName
        .split('/')
        .pop()
        .replace(/\.\w+$/, '')
    )
  )

  // 全局注册组件
  Vue.component(
    componentName,
    // 如果这个组件选项是通过 `export default` 导出的，
    // 那么就会优先使用 `.default`，
    // 否则回退到使用模块的根。
    componentConfig.default || componentConfig
  )
})
```

记住**全局注册的行为必须在根 Vue 实例 (通过 `new Vue`) 创建之前发生**。[这里](https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js)有一个真实项目情景

### 单文件组件

在很多 Vue 项目中，我们使用 `Vue.component` 来定义全局组件，紧接着用 `new Vue({ el: '#container '})` 在每个页面内指定一个容器元素。

这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显：

- **全局定义 (Global definitions)** 强制要求每个 component 中的命名不得重复
- **字符串模板 (String templates)** 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 `\`
- **不支持 CSS (No CSS support)** 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏
- **没有构建步骤 (No build step)** 限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug (formerly Jade) 和 Babel

文件扩展名为 `.vue` 的 **single-file components (单文件组件)** 为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具。

为了能够使用单文件组件需要安装环境

```
### 安装 `npm`
`npm` 全称为 `Node Package Manager`，是一个基于`Node.js`的包管理器，也是整个`Node.js`社区最流行、支持的第三方模块最多的包管理器。  安装node.js就可以完成安装
​```
npm -v  查看npm版本
​```

### 由于网络原因 npm安装 `cnpm`  中国的npm镜像
​```
npm install -g cnpm --registry=https://registry.npm.taobao.org
​```

### 安装 `vue-cli`   vue官方提供的脚手架工具
​```
cnpm install -g @vue/cli
​```

### 安装 `webpack`
`webpack` 是  `JavaScript` 打包器(module bundler)
​```
cnpm install -g webpack
​```
```

项目创建  cd到对应位置  vue ui 命令启动vue cli的图像化管理界面

creat选项来创建项目  包管理器可以npm选择默认设置  命令行查看创建过程  就可以关闭命令行和图像化管理界面   对应位置就有了创建的项目

目录结构：public 打包之后用于部署到生产环境下的目录  src开发的目录  下有components目录是整个项目的组件目录（如有helloworld.vue文件  单文件组件  可以尝试修改   在这个文件夹下新建自己的单文件组件）  src下还有app.vue是整个项目的入口文件 完成了对组件的引入工作  在srcipt标签中可以使用import方式去引入一个组件   页面上就可以通过components属性局部注册并使用 对应名称的组件（如helloworld）

运行一下可以知道整个组件的调用和运行效果   HbuilderX菜单运行-运行到终端  npm run server  命令执行成功  terminal告诉一个本地路径  浏览器就可以访问  项目就被运行起来

做单文件组件：

单文件组件整个页面分为三个比较大的区域：template 标签放置模板  script 脚本区域 style  视图区域  完整描绘html开发中必须的三个点  DOM结构  JS脚本 和css样式  标签可以有class属性  css中为其添加样式

template 标签里声明这个组件的模板内容 

script内可以声明这个组件的属性props进行声明  数据  方法

props规范的写法：

```
<script>
export default {
  name: 'HelloWorld',   组件名
  data () {   为组件注册对应法的组件数据   用函数的形式
    return {     key:value的形式
      msg: 'Welcome to Your Vue.js App'
    }<script>

  },
  props:{     类型  默认值
    msg:{
      type:String,
      default:""

    }
  },
  methods:{    为组件注册对应的方法

  }
}<script>

</script>
```



单文件组件做好后app.vue中就可以进行引入和注册：

import语法引入对应名称的组件  

引入后在components内对其进行局部注册   对应模板就可以使用对应名称标签调用对应名称组件

```
<script>
	import HelloWorld from './components/HelloWorld'
	export default {
		name: 'App',
		// data() {
		// 	return {
		// 		date: '',
		// 		show: false,
		// 	};
		// },
		// methods: {
		// 	formatDate(date) {
		// 		return `${date.getMonth() + 1}/${date.getDate()}`;
		// 	},
		// 	onConfirm(date) {
		// 		this.show = false;
		// 		this.date = this.formatDate(date);
		// 	},
		// },
		components: {
			HelloWorld
		}
	}
</script>
```



### 免终端开发vue应用

上个是通过命令行完成vue单文件组建的部署工作  基于vue的商业开发基本不使用html内嵌vue.js的方式开发   而是使用基于vue cli的方式开发

cli是命令行，一个黑色的终端窗体，在里面敲命令。这要求开发者需要了解终端、node、npm等很多知识，不然在以下方面会困难重重:
CLI是命令行，一个黑色的终端窗体，在里面敲命令.这要求开发者需要了解终端、节点、npm等很多知识，不然在以下方面会困难重重：

1.搭建项目环境

2.运行和发布项目

3.配置less/sass/typescript/babel等预编译器

4.安装各种流行的组件库
使用uni-app + HBuilder X

uni-app和HBuilderX都是DCloud公司出品的，前者是框架，后者是ide，它们互相搭配，实现免终端开发，使得基于vue.js开发项目变的更简单和高效!让开发者把更多精力放在业务逻辑上。

使用uni-app 框架实现免终端开发vue.js应用

新建项目选uni-app  默认模板  就创建了一个uni-app类型的项目

目录结构:

![1605422725907](笔记.assets/1605422725907.png)

index下每一个页面文件都以单文件组件的形式存在  运行到浏览器来预览和调试  编辑器内修改并保存  浏览器自动进行刷新

发行按钮  项目发行为网站|H5手机版本  HbuilderX自动完成发行工作  打包完成后可以看到导出的位置   打包结果部署到服务器就完成了整个项目的发行工作

HbuilderX安装插件来支持扩展语言  如less  cass   安装less插件

![1605423732964](笔记.assets/1605423732964.png)

![1605423488213](笔记.assets/1605423488213.png)

![1605423521870](笔记.assets/1605423521870.png)

uni-app提供非常的丰富的组件和api 提高移动端应用开发效率 官网：  https://uniapp.dcloud.io/component/README

内部通过代码块功能快速创建uni-app提供的组件  如switch组件的创建：

![1605424098461](笔记.assets/1605424098461.png)

uni-app提供查件市场  HbuilderX导入插件 可以快算将组件导入项目内<img src="笔记.assets/1605424188582.png" alt="1605424188582" style="zoom:50%;" />

选择导入的项目  这样一个组件就导入了项目内  项目根目录下的components文件夹(通常用来放置开发过程中用到的组件)  插件下提供组件使用说明

自定义组件的创建和使用:

components文件夹 下新建组件  命名

![1605424799618](笔记.assets/1605424799618.png)

简单组件的创建：两个重要的属性去描绘组建的属性：第一个属性：type组件属性的类型  可以是js标准的变量类型  default:组件属性的初始值

index.vue 页面文件内  引入时通过import  后面需要声明一个组件的名称   components文件夹下的组件   

 components属性内通过组件名称去注册组件  注册好后就可以在页面上对组件进行应用  标签上通过组件的属性进行每一个组件的属性的赋值

![1605425034051](笔记.assets/1605425034051.png)

组件内部执行事件并且将他的事件传递给父级组件：  @tap为H1组件添加了一个单击事件  被点击时调用一个函数  （执行事件） 组件内部methods属性声明组件的事件对应的函数 this.emit将子组件的事件传递给他的调用者(index.vue)  传递很多数值时可以使用数组的方式

父级使用@事件名称的方式监听子组件的对应事件  父级页面上声明一个函数（可以接受参数  子组件内部传递给父级页面的参数）去执行对应的事件

![1605425422954](笔记.assets/1605425422954.png)

<img src="笔记.assets/1605425389255.png" alt="1605425389255" style="zoom:50%;" />

<img src="笔记.assets/1605425652372.png" alt="1605425652372" style="zoom:50%;" />

#### [基础组件](https://uniapp.dcloud.io/component/README?id=基础组件)

uni-app为开发者提供了一系列基础组件，类似HTML里的基础标签元素。

但uni-app的组件与HTML不同，而是与小程序相同，更适合手机端使用。

虽然不推荐使用HTML标签，但实际上如果开发者写了`div`等标签，在编译到非H5平台时也会被编译器转换为`view`标签，类似的还有`span`转`text`、`a`转`navigator`等，包括css里的元素选择器也会转。但为了管理方便、策略统一，新写代码时仍然建议使用view等组件。

开发者可以通过组合这些基础组件进行快速开发。 基于内置的基础组件，可以开发各种扩展组件，组件规范与vue组件相同。

什么是组件：

- 组件是视图层的基本组成单元。
- 一个组件包括开始标签和结束标签，标签上可以写属性，并对属性赋值。内容则写在两个标签之内。

```html
<template>
    <view>
        <tagname property="value">
            content
        </tagname>
    </view>
</template>
```

**Tips**

- 所有组件与属性名都是小写，单词之间以连字符`-`连接。
- 根节点为 `，这个 ` 下只能且必须有一个根``组件。这是vue单文件组件规范。
- **平台差异说明**若无特殊说明，则表示所有平台均支持。

##### [属性类型](https://uniapp.dcloud.io/component/README?id=属性类型)

| 类型         | 描述           | 注解                                                         |
| :----------- | :------------- | :----------------------------------------------------------- |
| Boolean      | 布尔值         | 组件写上该属性，不管该属性等于什么，其值都为 `true`，只有组件上没有写该属性时，属性值才为 `false`。如果属性值为变量，变量的值会被转换为 `Boolean` 类型。 |
| Number       | 数字           | 1, 2.5                                                       |
| String       | 字符串         | "string"                                                     |
| Array        | 数组           | [ 1, "string" ]                                              |
| Object       | 对象           | { key: value }                                               |
| EventHandler | 事件处理函数名 | `handlerName` 是 methods 中定义的事件处理函数名              |
| Any          | 任意属性       |                                                              |

##### [共同属性类型](https://uniapp.dcloud.io/component/README?id=共同属性类型)

所有组件都有的属性：

| 属性名 | 类型         | 描述           | 注解                                                         |
| :----- | :----------- | :------------- | :----------------------------------------------------------- |
| id     | String       | 组件的唯一标示 | 保持整个页面唯一                                             |
| class  | String       | 组件的样式类   | 在对应的 css 中定义的样式类                                  |
| style  | String       | 组件的内联样式 | 可以动态设置的内联样式                                       |
| hidden | Boolean      | 组件是否隐藏   | 所有组件默认是显示的                                         |
| data-* | Any          | 自定义属性     | 组件上触发的事件时，会发送给事件处理函数                     |
| @*     | EventHandler | 组件的事件     | 详见各组件详细文档，事件绑定参考 [事件处理器](https://uniapp.dcloud.io/use?id=事件处理器) |

##### [特殊属性](https://uniapp.dcloud.io/component/README?id=特殊属性)

几乎所有组件都有各自自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个组件的定义。

##### [组件列表](https://uniapp.dcloud.io/component/README?id=组件列表)

基础组件分为以下八大类：

**视图容器（View Container）：**

| 组件名                                                       | 说明                        |
| :----------------------------------------------------------- | :-------------------------- |
| [view](https://uniapp.dcloud.io/component/view)              | 视图容器，类似于HTML中的div |
| [scroll-view](https://uniapp.dcloud.io/component/scroll-view) | 可滚动视图容器              |
| [swiper](https://uniapp.dcloud.io/component/swiper)          | 滑块视图容器                |

**基础内容（Basic Content）：**

| 组件名                                                    | 说明   |
| :-------------------------------------------------------- | :----- |
| [icon](https://uniapp.dcloud.io/component/icon)           | 图标   |
| [text](https://uniapp.dcloud.io/component/text)           | 文字   |
| [rich-text](https://uniapp.dcloud.io/component/rich-text) | 富文本 |
| [progress](https://uniapp.dcloud.io/component/progress)   | 进度条 |

**表单组件（Form）：**

| 标签名                                                       | 说明                 |
| :----------------------------------------------------------- | :------------------- |
| [button](https://uniapp.dcloud.io/component/button)          | 按钮                 |
| [form](https://uniapp.dcloud.io/component/form)              | 表单                 |
| [input](https://uniapp.dcloud.io/component/input)            | 输入框               |
| [checkbox](https://uniapp.dcloud.io/component/checkbox)      | 多项选择器           |
| [radio](https://uniapp.dcloud.io/component/radio)            | 单项选择器           |
| [picker](https://uniapp.dcloud.io/component/picker)          | 弹出式列表选择器     |
| [picker-view](https://uniapp.dcloud.io/component/picker-view) | 窗体内嵌式列表选择器 |
| [slider](https://uniapp.dcloud.io/component/slider)          | 滑动选择器           |
| [switch](https://uniapp.dcloud.io/component/switch)          | 开关选择器           |
| [label](https://uniapp.dcloud.io/component/label)            | 标签                 |

**导航（Navigation）：**

| 组件名                                                    | 说明                          |
| :-------------------------------------------------------- | :---------------------------- |
| [navigator](https://uniapp.dcloud.io/component/navigator) | 页面链接。类似于HTML中的a标签 |

**媒体组件（Media）：**

| 组件名                                                       | 说明                         |
| :----------------------------------------------------------- | :--------------------------- |
| [audio](https://uniapp.dcloud.io/component/audio)            | 音频                         |
| [camera](https://uniapp.dcloud.io/component/camera)          | 相机                         |
| [image](https://uniapp.dcloud.io/component/image)            | 图片                         |
| [video](https://uniapp.dcloud.io/component/video)            | 视频                         |
| [live-player](https://uniapp.dcloud.io/component/live-player) | 直播播放                     |
| [live-pusher](https://uniapp.dcloud.io/component/live-pusher) | 实时音视频录制，也称直播推流 |

**地图（Map）：**

| 组件名                                        | 说明 |
| :-------------------------------------------- | :--- |
| [map](https://uniapp.dcloud.io/component/map) | 地图 |

**画布（Canvas）：**

| 组件名                                              | 说明 |
| :-------------------------------------------------- | :--- |
| [canvas](https://uniapp.dcloud.io/component/canvas) | 画布 |

**webview（Web-view）：**

| 组件名                                                  | 说明          |
| :------------------------------------------------------ | :------------ |
| [web-view](https://uniapp.dcloud.io/component/web-view) | web浏览器组件 |

**各平台专有组件**

在小程序平台和weex平台，还有一些专有组件，比如open-data，详见左侧导航

##### [扩展组件（uni-ui）：](https://uniapp.dcloud.io/component/README?id=uniui)

uni-ui是DCloud提供的一个跨端ui库，它是基于vue组件的、flex布局的、无dom的跨全端ui框架。

uni-ui不包括基础组件，**它是基础组件的补充**。

###### [uni ui产品特点](https://uniapp.dcloud.io/component/README?id=uni-ui产品特点)

###### 1、高性能

目前为止，在小程序和混合app领域，uni ui是性能的标杆。

- 自动差量更新数据

虽然uni-app支持小程序自定义组件，所有小程序的ui库都可以用。但小程序自定义组件的ui库都需要使用setData手动更新数据，在大数据量时、或高频更新数据时，很容易产生性能问题。

而uni ui属于vue组件，uni-app引擎底层自动diff更新数据。当然其实插件市场里众多vue组件都具备这个特点。

- 优化逻辑层和视图层通讯折损

非H5，不管是小程序还是App，不管是app的webview渲染还是原生渲染，全都是逻辑层和视图层分离的。这里就有一个逻辑层和视图层通讯的折损问题。 比如在视图层拖动一个可跟手的组件，由于通讯的损耗，用js监听很难做到实时跟手。

这时就需要使用css动画以及平台底层提供的wxs、bindingx等技术。不过这些技术都比较复杂，所以uni ui里做了封装，在需要跟手式操作的ui组件，比如swiperaction列表项左滑菜单，就在底层使用了这些技术，实现了高性能的交互体验

- 背景停止

很多ui组件是会一直动的，比如轮播图、跑马灯。即便这个窗体被新窗体挡住，它在背景层仍然在消耗着硬件资源。在Android的webview版本为chrome66以上，背景操作ui会引发很严重的性能问题，造成前台界面明显卡顿。

而uni ui的组件，会自动判断自己的显示状态，在组件不再可见时，不会再消耗硬件资源。

2、全端

uni ui的组件都是多端自适应的，底层会抹平很多小程序平台的差异或bug。

比如导航栏navbar组件，会自动处理不同端的状态栏。 比如swiperaction组件，在app和微信小程序上会使用交互体验更好的wxs技术，但在不支持wxs的其他小程序端会使用js模拟类似效果。

uni ui还支持nvue原生渲染，[详见](https://github.com/dcloudio/uni-ui/tree/nvue-uni-ui)

未来uni ui还会支持pc等大屏设备。

3、与uni统计自动集成实现免打点

uni统计是优秀的多端统计平台，见[tongji.dcloud.net.cn](https://tongji.dcloud.net.cn/)。

除了一张报表看全端，它的另一个重要特点是免打点。 比如使用uni ui的navbar标题栏、收藏、购物车等组件，均可实现自动打点，统计页面标题等各种行为数据。 当然你也可以关闭uni统计，这不是强制的。

4、风格扩展

uni ui的默认风格是中型的，与uni-app基础组件风格一致。但它支持[uni.scss](https://uniapp.dcloud.io/collocation/uni-scss)，可以方便的扩展和切换App的风格。

ui是一种需求非常发散的产品，DCloud官方也无意用uni ui压制第三方ui插件的空间，但官方有义务在性能和跨端方面提供一个开源的标杆给大家。

我们欢迎更多优秀的ui组件出现，也欢迎更多人贡献uni ui的主题风格，满足更多用户的需求。

###### [uni ui的使用方式](https://uniapp.dcloud.io/component/README?id=uni-ui的使用方式)

uni ui支持 HBuilderX直接新建项目模板、npm安装和单独导入个别组件等多种使用方式

![HBuilderX内创建uni ui项目](https://img.cdn.aliyun.dcloud.net.cn/uni-app/doc/create-uni-ui-project.jpg)

1. 在HBuilderX新建uni-app项目的模板中，选择uni ui模板 由于uni-app独特的[easycom](https://uniapp.dcloud.io/collocation/pages?id=easycom)技术，可以免引用、注册，直接使用各种符合规则的vue组件。

在代码区键入`u`，拉出各种内置或uni ui的组件列表，选择其中一个，即可使用该组件。

光标放在组件名称上，按F1，可以查阅组件的文档。

![uni ui代码块](https://img.cdn.aliyun.dcloud.net.cn/uni-app/doc/uni-ui-snippet.jpg)

1. npm安装参考：https://ext.dcloud.net.cn/plugin?id=55
2. 单独安装组件 如果你没有创建uni ui项目模板，也可以在你的工程里，单独安装需要的那个组件。下表为uni-ui的扩展组件清单，点击每个组件在详情页面可以导入组件到项目下，导入后直接使用即可，无需import和注册。

| 组件名                                                     | 说明               |
| :--------------------------------------------------------- | :----------------- |
| [Badge](https://ext.dcloud.net.cn/plugin?id=21)            | 数字角标           |
| [Calendar](https://ext.dcloud.net.cn/plugin?id=56)         | 日历               |
| [Card](https://ext.dcloud.net.cn/plugin?id=22)             | 卡片               |
| [Collapse](https://ext.dcloud.net.cn/plugin?id=23)         | 折叠面板           |
| [Combox](https://ext.dcloud.net.cn/plugin?id=1261)         | 可下拉选择的输入框 |
| [CountDown](https://ext.dcloud.net.cn/plugin?id=25)        | 倒计时             |
| [Drawer](https://ext.dcloud.net.cn/plugin?id=26)           | 抽屉               |
| [Fab](https://ext.dcloud.net.cn/plugin?id=144)             | 悬浮按钮           |
| [Fav](https://ext.dcloud.net.cn/plugin?id=864)             | 收藏按钮           |
| [GoodsNav](https://ext.dcloud.net.cn/plugin?id=865)        | 底部购物导航       |
| [Grid](https://ext.dcloud.net.cn/plugin?id=27)             | 宫格               |
| [Icons](https://ext.dcloud.net.cn/plugin?id=28)            | 图标               |
| [IndexedList](https://ext.dcloud.net.cn/plugin?id=375)     | 字母索引列表       |
| [List](https://ext.dcloud.net.cn/plugin?id=24)             | 列表               |
| [LoadMore](https://ext.dcloud.net.cn/plugin?id=29)         | 加载更多           |
| [NavBar](https://ext.dcloud.net.cn/plugin?id=52)           | 自定义导航栏       |
| [NoticeBar](https://ext.dcloud.net.cn/plugin?id=30)        | 通告栏             |
| [NumberBox](https://ext.dcloud.net.cn/plugin?id=31)        | 数字输入框         |
| [Pagination](https://ext.dcloud.net.cn/plugin?id=32)       | 分页器             |
| [PopUp](https://ext.dcloud.net.cn/plugin?id=329)           | 弹出层             |
| [Rate](https://ext.dcloud.net.cn/plugin?id=33)             | 评分               |
| [SearchBar](https://ext.dcloud.net.cn/plugin?id=866)       | 搜索栏             |
| [SegmentedControl](https://ext.dcloud.net.cn/plugin?id=54) | 分段器             |
| [Steps](https://ext.dcloud.net.cn/plugin?id=34)            | 步骤条             |
| [SwipeAction](https://ext.dcloud.net.cn/plugin?id=181)     | 滑动操作           |
| [SwiperDot](https://ext.dcloud.net.cn/plugin?id=284)       | 轮播图指示点       |
| [Tag](https://ext.dcloud.net.cn/plugin?id=35)              | 标签               |

**更多组件**

除了基础组件、uni-ui，插件市场还有更多扩展组件、模板，包括前端组件和原生扩展组件，具体见[插件市场](https://ext.dcloud.net.cn/)。

关于其他vue的web组件库、小程序组件库是否能在uni-app中使用的问题，参考https://ask.dcloud.net.cn/article/35489

### [vue 文件目录结构详解](https://www.cnblogs.com/dragonir/p/8711761.html)

#### vue 文件目录结构详解

本篇文章主要介绍了vue 文件目录结构详解，小编觉得挺不错的，现在分享给大家，也给大家做个参考。一起跟随小编过来看看吧
项目简介
基于 vue.js 的前端开发环境，用于前后端分离后的单页应用开发，可以在开发时使用 ES Next、scss 等最新语言特性。项目包含：

基础库: vue.js、vue-router、vuex、whatwg-fetch
编译/打包工具：webpack、babel、node-sass
单元测试工具：karma、mocha、sinon-chai
本地服务器：express
目录结构

```
├── README.md            项目介绍
├── index.html           入口页面
├── build              构建脚本目录
│  ├── build-server.js         运行本地构建服务器，可以访问构建后的页面
│  ├── build.js            生产环境构建脚本
│  ├── dev-client.js          开发服务器热重载脚本，主要用来实现开发阶段的页面自动刷新
│  ├── dev-server.js          运行本地开发服务器
│  ├── utils.js            构建相关工具方法
│  ├── webpack.base.conf.js      wabpack基础配置
│  ├── webpack.dev.conf.js       wabpack开发环境配置
│  └── webpack.prod.conf.js      wabpack生产环境配置
├── config             项目配置
│  ├── dev.env.js           开发环境变量
│  ├── index.js            项目配置文件
│  ├── prod.env.js           生产环境变量
│  └── test.env.js           测试环境变量
├── mock              mock数据目录
│  └── hello.js
├── package.json          npm包配置文件，里面定义了项目的npm脚本，依赖包等信息
├── src               源码目录  
│  ├── main.js             入口js文件
│  ├── app.vue             根组件
│  ├── components           公共组件目录
│  │  └── title.vue
│  ├── assets             资源目录，这里的资源会被wabpack构建
│  │  └── images
│  │    └── logo.png
│  ├── routes             前端路由
│  │  └── index.js
│  ├── store              应用级数据（state）
│  │  └── index.js
│  └── views              页面目录
│    ├── hello.vue
│    └── notfound.vue
├── static             纯静态资源，不会被wabpack构建。
└── test              测试文件目录（unit&e2e）
  └── unit              单元测试
    ├── index.js            入口脚本
    ├── karma.conf.js          karma配置文件
    └── specs              单测case目录
      └── Hello.spec.js
```

#### 环境安装

本项目依赖 node.js， 使用前先安装 node.js 和 cnpm（显著提升依赖包的下载速度）。

自行下载并安装 node.js： https://nodejs.org/en/download/

然后安装 cnpm 命令：

npm install -g cnpm --registry=https://registry.npm.taobao.org
快速开始
git clone https://github.com/hanan198501/vue-spa-template.git
cd vue-spa-template
cnpm install
npm run dev
命令列表：

#### 开启本地开发服务器，监控项目文件的变

#### 化，实时构建并自动刷新浏览器，浏览器访问 [http://localhost:8081](http://localhost:8081/)

npm run dev

#### 使用生产环境配置构建项目，构建好的文件会输出到 "dist" 目录，

> npm run build

#### 运行构建服务器，可以查看构建的页面

> npm run build-server

#### 运行单元测试

> npm run unit

#### 前后端分离

项目基于 spa 方式实现前后端分离，服务器通过 nginx 区分前端页面和后端接口请求，分发到不同服务。前端物理上只有一个入口页面, 路由由前端控制（基于vue-router），根据不同的 url 加载相应数据和组件进行渲染。

#### 接口 mock

前后端分离后，开发前需要和后端同学定义好接口信息（请求地址，参数，返回信息等），前端通过 mock 的方式，即可开始编码，无需等待后端接口 ready。 项目的本地开发服务器是基于 express 搭建的，通过 express 的中间件机制，我们已经在 dev-server 中添加了接口 mock 功能。 开发时，接口的 mock 数据统一放在 mock 目录下，每个文件内如下：

```
module.exports = {

 // 接口地址
 api: '/api/hello',

 // 返回数据 参考http://expressjs.com/zh-cn/4x/api.html
 response: function (req, res) {
  res.send(`
   <p>hello vue!</p>
  `);
 }
}
```

#### 模块化

开发时可以使用 ES2015 module 语法，构建时每个文件会编译成 amd 模块。

#### 组件化

整个应用通过 vue 组件的方式搭建起来，通过 vue-router 控制相应组件的展现，组件树结构如下：

app.vue 根组件（整个应用只有一个）
├──view1.vue 页面级组件，放在 views 目录里面，有子组件时，可以建立子目录
│ ├──component1.vue 功能组件，公用的放在 components 目录，否则放在 views 子目录
│ ├──component2.vue
│ └──component3.vue
├──view2.vue
│ ├──component1.vue
│ └──component4.vue
└──view3.vue
├──component5.vue
……

#### 单元测试

可以为每个组件编写单元测试，放在 test/unit/specs 目录下面, 单元测试用例的目录结构建议和测试的文件保持一致（相对于src），每个测试用例文件名以 .spec.js结尾。 执行 npm run unit 时会遍历所有的 spec.js 文件，产出测试报告在 test/unit/coverage 目录。

#### 联调方式

前后端分离后，由于服务端和前端的开发环境处于2台不同的机器上，前端的异步请求需要代理到后端机器中。 联调的时候，只需通过 proxy 参数运行 dev 脚本即可，所有 mock 目录下定义的接口将会转发到 proxy 参数指定的机器：

#### 172.16.36.904:8083 为后端机器的环境地址

npm run dev -- --proxy=172.16.36.90:8083
这样，如果 mock 目录下有定义了接口 /api/hello ，将会转发到 http://172.16.36.90/:8083/api/hello

## HTML  

### [HTML5 标签download 属性](https://www.cnblogs.com/tianma3798/p/6121320.html)

一、简单实例

```
  <a href="../images/1.jpg" download="下载图片.jpg">
      点击按钮下载
    </a>
```

二、说明：

#### 定义和用法

download 属性规定被下载的超链接目标。

在 <a> 标签中必须设置 href 属性。

该属性也可以设置一个值来规定下载文件的名称。所允许的值没有限制，浏览器将自动检测正确的文件扩展名并添加到文件 (.img, .pdf, .txt, .html, 等等)。

注：

1.href 指定下载文件的地址

2.download指定下载文件保存时的名称

3.jpg图片测试Google、FF支持下载，IE直接打开图片。

### [打开新窗口 不展示工具栏，地址栏](https://www.cnblogs.com/xiebeibei/p/12852383.html)

window.open('page.html', 'windowname', 'height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no')  //该句写成一行代码
  参数解释：
   window.open 弹出新窗口的命令； 
　　'page.html' 弹出窗口的文件名； 
　　'windowname' 弹出窗口的名字（不是文件名），非必须，可用空''代替； 
　　height=100 窗口高度； 
　　width=400 窗口宽度； 
　　top=0 窗口距离屏幕上方的象素值； 
　　left=0 窗口距离屏幕左侧的象素值； 
　　toolbar=no 是否显示工具栏，yes为显示； 
　　menubar，scrollbars 表示菜单栏和滚动栏。 
　　resizable=no 是否允许改变窗口大小，yes为允许； 
　　location=no 是否显示地址栏，yes为允许； 
　　status=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许；

 这里场景是有一个div使用display：inline-block，前面有一个span元素，如此设置导致了，这两个元素的高度不一致，div的下边界明细要比span元素高出一块，并且对div使用margin，span元素也跟着联动。头疼。即使用了vertical-align解决了小x的问题也没有什么反应，看来问题的原因不在这里，至于具体原因现在仍不是很清楚，如果有人知道原因希望能够给予解答，感激不尽。网上找到了下面这样的代码得以解决。将div和span都table化。问题迎刃而解。看来table是个好东西，怪不得bootstrap也用到了此思想。 

  <table>
      <tr> 
          <th style="width:180px;border:1px solid red"> 
              <span style="float:right">span</span> 
              <div>div</div> 
          </th>
      </tr> 
</table>  

### float属性

float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。

如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。

**注释：**假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。

| 默认值：          | none                           |
| :---------------- | ------------------------------ |
| 继承性：          | no                             |
| 版本：            | CSS1                           |
| JavaScript 语法： | *object*.style.cssFloat="left" |

可能的值

| 值      | 描述                                                 |
| :------ | :--------------------------------------------------- |
| left    | 元素向左浮动。                                       |
| right   | 元素向右浮动。                                       |
| none    | 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |
| inherit | 规定应该从父元素继承 float 属性的值。                |



   .ui.item {....}和du .ui .item {....}还有 .ui > .item {....}

第一个匹配： <div class="ul item"></div>；无法匹配：<div class="ul"></div> 和 <div class="item"></div>；

第二个匹配：<div class="ul"><div class="item"></div></div> 中间的 div；

第三个匹配：<div class="ul"><div class="item"></div></div> 中间的 div；无法匹配：<div class="ul"><div class="abc"><div class="item"></div></div></div>。

三个的区别是：

规则 .ul.item 匹配 class 属性同时含有 ul 和 item 的元素；

规则 .ul .item 匹配 class 属性包含 ul 的元素中 *任意的* class 属性包含 item 的元素（二者是祖先元素与后代元素的关系）；

规则 .ul > .item 匹配 class 属性包含 ul 的元素的子元素中 class 属性包含 item 的元素（二者是父元素与子元素的关系，在相邻的层  

### 选择器

https://blog.csdn.net/DYD850804/article/details/80997251?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param

基本选择器：

- 标签选择器：针对一类标签
- ID选择器：针对某一个特定的标签使用
- 类选择器：针对你想要的所有标签使用
- 通用选择器（通配符）：针对所有的标签都适用（不建议使用）

组合使用不同的选择器可以匹配更特定的元素。有的复合选择器能将目标样式应用到更多元素，有的复合选择器则会锁定更少元素，总之会让你的选择非常具体。复合选择器主要包括：群组选择器、后代选择器、子选择器和同级元素选择器。

 **‘+’选择器则表示某元素后相邻的兄弟元素，也就是紧挨着的，是单个的。而‘~’选择器则表示某元素后所有同级的指定元素，强调所有的。** 

#### 群组选择器

群组选择器的使用范畴是，多个选择器使用同一个样式或者同一组样式。这在做CSS样式初始化，CSS框架设计以及后期CSS代码优化时会经常使用。多个选择器之间用逗号（`,`）隔开，其语法形式为：`<选择器1>,<选择器2>，<选择器3> { 定义样式 }；`v代码示例如下：

```
<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <title>Example</title>
    <style type="text/css">
    /*群组选择器*/
    span, [title], div {
        color: blue;
    }
    </style>
</head>

<body>
    <div>群组选择器</div>
    <p title="">群组选择器</p>
    <span>群组选择器</span>
</body>

</html>123456789101112131415161718192021
```

#### 后代选择器

后代选择器是对某元素所嵌套的指定元素进行选择，每个选择符之间用空格进行分割，多个嵌套层次应该以多个空格进行分割（多层嵌套难免会增加选择器带来高权重，这样在处理一些元素的特殊样式的时候会带来些困难，所以在实际开发中我们还是应该避免出现多层嵌套的后代选择器的存在），示例如下：

```
<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <title>Example</title>
    <style type="text/css">
    /*后代选择器*/
    .descendantSelectors span {
        color: red;
    }
    .descendantSelectors div p {
        color: blue;
    }

    </style>
</head>

<body>

<div class="descendantSelectors">
    <div>
        <p>文本内容01</p>
    </div>
    <span>文本内容02</span>
</div>

</body>

</html>123456789101112131415161718192021222324252627282930
```

上述示例中可以看到，后代选择器的选择可以是间接后代，也可以是直接后代，其中p为间接后代，span为直接后代，每一代之间使用空格隔开，我们可通过此方式找到更为复杂嵌套下的元素并设置样式。

#### 子选择器

子选择器区别与后代选择器的地方就是，后代选择器可以选择嵌套在标签内部任意层级的标签元素，而子选择器只能选择当前标签往内一层的元素，即子选择器只能匹配直接后代，通俗一点，就是只能匹配儿子辈，不能匹配孙子辈。每个选择符之间用“>”进行分割。示例如下：

```
<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <title>Example</title>
    <style type="text/css">
    /*子选择器*/
    div>p {
        color: red;
    }
    </style>
</head>

<body>
    <div>
        <p>文本内容01</p>
    </div>
</body>

</html>123456789101112131415161718192021
```

#### 同级元素选择器

该选择器能选定当前选择器同级的其它指定选择器，平时虽使用的不多，但配合伪类选择器经常可以做出一些很有“新意”的效果，也能减少对JavaScript的依赖。同级元素有两种，即“+”和“~”。该选择器的示例我将会用到伪类选择器中的`:hover`，其作用是当鼠标悬浮在目标上会被触发，具体的会在后续文档中介绍。

###### 【+】同级元素选择器

“+”只能选择该选择器相邻的下一个选择器，示例如下：

```
<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <title>Example</title>
    <style type="text/css">
        .sender {
            background-color: black;
            width: 50px;
            height: 50px;
            /*设置圆角，50%表示将该元素切割成一个圆*/
            border-radius: 50%;
        }

        /*同级元素选择器‘+’*/
        .sender:hover + .text_1 {
            color: blue;
            /*加粗粗细，bolder为更粗*/
            font-weight: bolder;
        }
        .sender:hover + .text_2 {
            color: blue;
            font-weight: bolder;
        }
    </style>
</head>

<body>
    <div class="sender"></div>
    <p class="text_1">文本内容01</p>
    <p class="text_2">文本内容02</p>
</body>

</html>1234567891011121314151617181920212223242526272829303132333435
```

这里对上述选择器的写法做一些声明，其中`.sender:hover`的作用是，首选找到`.sender类选择器`，然后为其设置一个悬浮的伪类选择器（hover），后面的+就表示找其对应的同级元素选择器了。运行程序我们可以发现，当鼠标悬浮在黑色圆球上时，第一段文本会做一些样式的变化，第二段文本不会。

###### 【~】同级元素选择器

“~”能选择该选择器**后**的所有同级选择器。同样使用上述案例，我们仅仅只需要将选择器中的 `+` 替换成 `~` 即可，运行程序我们会发现，两段文本内容都会做样式的改变。

### body标签

body标签里使用font改变文字   size不行   设置字体颜色是color  设置背景颜色是 background-color  看提示主要！

 topmargin：文档上边的边缘大小

 leftmargin：文档左边的边缘大小

rightmargin：文档右边的边缘大小
bottommargin：文档下边的边缘大小 

### 无序列表

- list-style-image：url图片地址 属性使用图像来替换列表项的标记；

- list-style-position 属性设置在何处放置列表项标记；还有一个inside的值：放在文本以内。

- list-style 复合写法

  list-style-image属性使用图像来替换列表项的标记，这个属性指定作为一个有序或无序列表项标志的图像。

  CSS list-style-image属性列表图标

  定义和用法

  list-style-image属性使用图像来替换列表项的标记。

  说明

  这个属性指定作为一个有序或无序列表项标志的图像。图像相对于列表项内容的放置位置通常使用list-style-position属性控制。

### 图像

＜img /＞标签表示向网页中插入图片，需要注意的是从技术上来说，＜img /＞标签并不会在网页中插入图像，而是从网页上链接图像，＜ing /＞标签创建的是被引用图像的占位空间。
＜img /＞标签有两个必须的HTML属性：src属性和alt属性。

- src属性：用来规定显示图像的链接（或是图片的路径），通常为src=“xxx”，xxx为图片所在的链接（路径）。
- alt属性：用来规定图像的替代文本，简单来说就是图片加载异常时的提示语，通常为alt=“xxx”，xxx为所要提示的内容。

## CSS 

### 鼠标不同光标：

 default 默认光标（通常是一个箭头）
auto 默认。浏览器设置的光标。
crosshair 光标呈现为十字线。
pointer 光标呈现为指示链接的指针（一只手）
move 此光标指示某对象可被移动。
e-resize 此光标指示矩形框的边缘可被向右（东）移动。
ne-resize 此光标指示矩形框的边缘可被向上及向右移动（北/东）。
nw-resize 此光标指示矩形框的边缘可被向上及向左移动（北/西）。
n-resize 此光标指示矩形框的边缘可被向上（北）移动。
se-resize 此光标指示矩形框的边缘可被向下及向右移动（南/东）。
sw-resize 此光标指示矩形框的边缘可被向下及向左移动（南/西）。
s-resize 此光标指示矩形框的边缘可被向下移动（北/西）。
w-resize 此光标指示矩形框的边缘可被向左移动（西）。
text 此光标指示文本。
wait 此光标指示程序正忙（通常是一只表或沙漏）。
help 此光标指示可用的帮助（通常是一个问号或一个气球）。 

### content 属性

#### 实例

以下示例将在每个链接后的括号内加上网址：

a:after {    content: " (" attr(href) ")"; }

#### 属性定义及使用说明

content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。

| 默认值：          | normal                                 |
| :---------------- | -------------------------------------- |
| 继承：            | no                                     |
| 版本：            | CSS2                                   |
| JavaScript 语法： | *object*.style.content="url(beep.wav)" |

#### Content属性值

| 值                | 说明                                                         |
| :---------------- | :----------------------------------------------------------- |
| none              | 设置Content，如果指定成Nothing                               |
| normal            | 设置content，如果指定的话，正常，默认是"none"（该是nothing） |
| counter           | 设定计数器内容                                               |
| attr*(attribute)* | 设置Content作为选择器的属性之一。                            |
| *string*          | 设置Content到你指定的文本                                    |
| open-quote        | 设置Content是开口引号                                        |
| close-quote       | 设置Content是闭合引号                                        |
| no-open-quote     | 如果指定，移除内容的开始引号                                 |
| no-close-quote    | 如果指定，移除内容的闭合引号                                 |
| url(*url*)        | 设置某种媒体（图像，声音，视频等内容）                       |
| inherit           | 指定的content属性的值，应该从父元素继承                      |

content 属性遵循一个原则：CSS 仅仅改变样式。因此，所加入的内容不会在 HTML 代码中直接展现：事实上，打开 F12 调试会发现浏览器把 before 作为一个特殊的节点嵌入到目标元素中。

 

这是很有用的一点，例如要制作一个伪输入元素（使用 contenteditable）时：

```
<p contenteditable="plaintext-only">默认值</p>
```

这一行 HTML 代码表示一个可编辑（仅允许纯文本）的段落，并且设置该“输入元素”的默认值。

但是在一般的 input 元素中还有一个 placeholder 属性，在输入框为空时展现一段文本，如：

```
<input type="text" value="默认值" placeholder="占位文本">
```

如果要在 contenteditable 元素中仿制一个 placeholder 功能，则可以使用 CSS 实现，例如：

```
p:empty:before
{
    color: #CCC;
    content: "Don't make me empty!";
}
```

这时如果将段落的文本全部删除，就会显示一段 "Don't make me empty!" 的浅色文本；最重要的是它不会被加入段落文本中，只要再键入一些内容，该文本就会消失。这表明 content 不是将文本单纯地加入元素中。

另外，在content中编辑的HTML标签会被直接显示，不能用于调整新加内容的属性。如果调整样式，可以在:before或:after伪元素内进行调整。

设置图片的url
<style>     
      img {
          content:url(https://image.png);
      } 
</style> 



这个的最后一种是现在比较常用的，如果你不想写太多代码的话，可以使用这种符合写法，简单的完成这些我们看个实例：

```
<style type="text/css">.zhe1,.zhe2,.zhe3,.zhe4,.zhe5{list-style:none;}</style>
```

这个css样式，加上这个，就能去掉那些不想要的东西了，还能写入别的属性，就这个我们来看看效果吧：

![tuer.png](笔记.assets/1536199962978081.png)

效果就是很明显了是不是，我们就这样把这些列表都去掉了，当然这只是最基础的符合写法，还能写入别的属性样式，这样才能显示节省更多的时间。

#### 命名规范：

##### id属性

id属性是HTML核心属性，用于为HTML元素定义唯一标识符（称为ID）。

在HTML文档中，ID必须确保唯一。

id属性可用于在JavaScript（通过HTML DOM）或CSS中针对给定ID来改变HTML元素。

| 值   | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| *ID* | 定义元素的唯一ID。命名规则：必须以字母A-Z或a-z开头之后的字符可以是：字母（A-Z a-z）、数字（0-9）、连字符（“-”）、下划线（“_”）、冒号（“:”）和圆点（“.”）ID是区分大小写的 |

##### class属性

class属性是HTML核心属性，用于为元素设置类名。

class属性主要用于引用样式表中的类。除此以外，它也可被用来在JavaScript中（通过HTML DOM）针对给定类来改变HTML元素。

------

提示和注意

**注意：**以下HTML元素不支持class属性：<base>、<head>、<html>、<meta>、<param>、<script>、<style>和<title>。

**提示：**可以给HTML元素分配多个类（用空格分开），例如<span class="left_menu important">。这样，你可以让一个HTML元素组合多个CSS类的特性。

**提示：**类名**不要**以数字开头！Internet Explorer以外的浏览器不支持。

| 值     | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| *类名* | 为一个元素指定类名。要为一个元素指定多个类，可用空格隔开各个类名 |

##### title属性

title属性是HTML核心属性，用于指定元素的提示文本。

当鼠标移动到元素上时，提示文本将作为工具提示（tooltip）显示出来。

**提示：**title属性经常与<form>和<a>元素一起使用，用以提供关于输入格式和链接目标的信息。对<abbr>和<acronym>元素来说，title是必选属性

##### style属性

style属性是HTML核心属性，用于为元素指定内联样式（inline style）。

style属性将覆盖其他全局样式，比如在<style>元素或外部样式表中定义的样式。



#### 权值问题

 id选择器权值为100；而<p></p>已经规定了最高权值p{color:red!important;}，所以<p></p>中的内容只显示最高权值中规定的red颜色。 

 不生效的3种情况：IE浏览器解析的话字体前要加@

#### 标点符号问题！ 标点有问题全角的 

1.当此属性定义的是全局样式时，对于表单类的标签就不会生效，还需要再次定义如：
body {font-family: "Microsoft YaHei";}对表单input就不生效，
还需要定义一个input {font-family: "Microsoft YaHei";}才可以。

2.本地计算机不存在微软雅黑字体，有的系统默认没有微软雅黑，则一般默认为宋体，只要下载一个微软雅黑字体，安装后即可。

3.还有一个是字符集问题，建议把中文font-family:" 微软雅黑";改为font-family: "Microsoft YaHei";字符集申明一下UTF-8或GB2312。 @charset='utf-8'

### 多空格

 在我们书写html代码的时候，为了便于阅读，标签与标签之间常用空格、换行隔开，但是在IE8以后的浏览器包括现在的Chrome、opera等浏览器中，把节点与节点之间的空白符（即空格和换行）也视为文本节点。因为这个原因而产生出很多坑 。

li标签不闭合，让其自动补全，也是可以清除空白。 

 还可以给li标签一个负边距来抵消空白符的宽度，但是有一个缺点，就是空白符作为文本节点，其大小跟父节点ul标签有关，而ul标签又跟浏览器有关，所以负边距的大小不好确定。（一般是3像素） 

 .既然空白符大小跟ul标签有关，那我们可以把ul标签的字体大小设置为0，再给li标签设置实际字体大小，这样就可以使空白符的大小为0。 

 .css4草案中有一个新增属性：white-space-collapsing，也可以解决这个问题，但是现在几乎没有浏览器支持，让我们展望未来吧。 

### 下划线

```
HTML设置水平分割线
1. HTML设置一条水平分割线
<hr />
这是水平分割线的最基本应用。它是居中对齐的。
2. HTML设置水平分割线的宽度
<hr width="200" />
水平分割线的宽度为像素（px）或者相对于屏幕宽度的百分比（%）。比如：
<hr width="200px" /> <!--单位为像素。默认值是将px去掉，成为上面的格式-->
<hr width="20%" />   <!--单位是相对于屏幕宽度的百分比-->
3. HTML设置水平分割线的粗细
<hr size="30" />
水平分割线的粗细单位仍然是像素（px）。
4. HTML去掉水平分割线的阴影
<hr noshade="noshade" />
一般情况下，水平分割线是带有阴影的，具体显示为一条突出的或者凹下去的线条。使用此属性，可以去掉分割线的阴影，使之成为一条无阴影效果的实心线。
5. HTML设置水平分割线的对齐方式
<hr width="30%" align="left" />
水平分割线的对齐方式默认为居中对齐。使用align属性可以改变它的对齐方式。并且只有当它的宽度设置小于屏幕的宽度时，才会显示出对齐方式的设置效果。
6. HTML设置水平分割线的颜色
<hr color="#FF0000" />
可以给水平分割线设置不同的颜色。
7. HTML设置水平分割线的title属性
<hr size="30" title="设置水平分割线的title属性" />
当浏览者将鼠标悬停在分割线上时会出现属性值设置的提示内容。
8. HTML水平分割线的综合应用
<hr width="300" size="20" noshade="noshade" align="right" color="#0000FF" />
可以分别设置<hr />的属性：size、width、align、color和noshade等。属性不用全部设置，而是根据需要选择某些属性进行设置，未设置的属性浏览器会以默认的方式显示。
默认方式：浏览器在遇到属性不全的标签时，对于未设置的属性将根据浏览器内部定义好的样式进行显示。
```



```
https://www.cnblogs.com/yanguobin/p/12017127.html:::::::
<a href="aaa/bbb">Get方式请求</a><br/>
    <!-- 会到web.xml中交给url-pattern为/aaa/bbb的Servlet来处理，根据get、post的提交方式来执行doGet()、doPost()方法-->
    <form action="aaa/bbb" method="post">
        <input type="submit" value="Post方式请求"/>
    </form>
    
    
Java类： MyServlet extends HttpServlet
     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("处理Get()请求...");
        //使servlet页面中文不会乱码，一定要放在getWriter()方法前面
        resp.setContentType("text/html; charset=utf-8");
        //添加上面这行才会解析html代码，显示Get()请求成功！的加粗模式，否则不会解析html代码，直接显示html标签
        PrintWriter out = resp.getWriter();
        out.println("<strong>Get()请求成功!</strong><br/>");
    }
    
web.xml:
<servlet>
    <servlet-name>myservlet</servlet-name>
    <servlet-class>com.yanguobin.MyServlet</servlet-class>  <!-- 包名类名写全 -->
  </servlet>
  <servlet-mapping>
    <servlet-name>myservlet</servlet-name>
    <url-pattern>/aaa/bbb</url-pattern>
    <!-- 第一个/表示项目的根目录，或者说使当前Web工程的根目录，不能省略 -->
    <!-- myget/aaa应与前端页面中的请求地址一致，即访问地址 -->
  </servlet-mapping>
```

### target属性

```
<p align="center"><font size="5"><b>目&nbsp;录</b></font></p> 
<p align="center">
<a href=" " target=" "><font size="3">第1题</a></font>
</p>
（提示：href属性设置为该题目对应的页面，target属性设置为在main.html中自己所定义的中间主框架名字。

```

<a> 标签的 target 属性规定在何处打开链接文档。

如果在一个 <a> 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、name名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。

### iframe实现左侧超链接，右侧显示内容

 利用 html 中的 iframe标签，结合超链接的 target 属性实现。
效果：在图中的粉色内容右边位置，显示对应的 html 链接的内容，而不是出现在一个新的、全屏的页面上。 

```
<body>
<div class="header">
  header
</div>
<div class="center">
    <div id="left">
        <ul>
            <li><a href="a.html" target="mainframe">a.html</a></li>
            <li><a href="b.html" target="mainframe">b.html</a></li>
            <li><a href="c.html" target="mainframe">c.html</a></li>
        </ul>
    </div>
    <div id="right">
        <iframe name="mainframe" id="frame_main" ></iframe>
    </div>
</div>
</body>

        body{
            width:100%;
            margin: 0 auto;
        }
        #right{
            margin-left:300px;
        }
        #frame_main,.header,.center{
            width:100%;
        }
        #frame_main, #right,#left{
            height:600px;
        }
        #left{
            position: absolute;
            width: 300px;
            background-color:peachpuff;
        }
        .header{
            background-color:powderblue;
            height:150px
        }
        .center{
            margin:0 auto;
        }
        li{
            list-style-type: none;
            padding:15px;
        }
```



```
<hr />
水平分割线
```

表格里垂直对齐：

<td valign="middle"></td>

###  vertical-align 

属性设置元素的垂直对齐方式。 

该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。

| 默认值：          | baseline                              |
| :---------------- | ------------------------------------- |
| 继承性：          | no                                    |
| 版本：            | CSS1                                  |
| JavaScript 语法： | *object*.style.verticalAlign="bottom" |

| 值          | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| baseline    | 默认。元素放置在父元素的基线上。                             |
| sub         | 垂直对齐文本的下标。                                         |
| super       | 垂直对齐文本的上标                                           |
| top         | 把元素的顶端与行中最高元素的顶端对齐                         |
| text-top    | 把元素的顶端与父元素字体的顶端对齐                           |
| middle      | 把此元素放置在父元素的中部。                                 |
| bottom      | 把元素的顶端与行中最低的元素的顶端对齐。                     |
| text-bottom | 把元素的底端与父元素字体的底端对齐。                         |
| length      |                                                              |
| %           | 使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。 |
| inherit     | 规定应该从父元素继承 vertical-align 属性的值。               |

**块级元素**

会占领页面的一行，其后多个block元素自动换行、 可以设置width，height，设置了width后同样也占领一行、同样也可以设置  margin与padding属性。

ps:常见的块级元素:div,img,ul,form,p等

**行级元素**

与其他元素在同一行上，高度，行高以及底边距不可改变，高度就是内容文字或者图片的宽度，不可以改变。

ps：em，strong，br,input等

**display:inline-block，block，inline元素的区别**

1、display：block将元素显示为块级元素，从而可以更好地操控元素的宽高，以及内外边距，每一个块级元素都是从新的一行开始。

2、display : inline将元素显示为行内元素，高度，行高以及底边距不可改变，高度就是内容文字或者图片的宽度，不可以改变。多个相邻的行内元素排在同一行里，知道页面一行排列不下，才会换新的一行。

3、display：inline-block看上去值名inline-block是一个混合产物，实际上确是如此，将元素显示为行内块状元素，设置该属性后，其他的行内块级元素会排列在同一行。比如我们li元素一个inline-block，使其既有block的宽度高度特性，又有inline的同行特性，在同一行内有不同高度内容的元素时，通常要设置对齐方式如vertical-align: top;来使元素顶部对齐。

### 列表

```
<p>有序列表：</p>
<ol>
  <li>打开冰箱门</li>
  <li>把大象放进去</li>
  <li>关上冰箱门</li>
</ol>

<p>无序列表：</p>
<ul>
  <li>雪碧</li>
  <li>可乐</li>
  <li>凉茶</li>
</ul>
```



### 图片载入调大小

  <img src=2009/04/1232336585-19.jpg onload='if (this.width>140 ||2113 this.height>226) if (this.width/this.height>140/226) this.width=140; else this.height=226;'>原理：用JS在加载图片后判断图片是否突破规定的高和宽，如果超过再根据图片的宽高比例进行调整。 特别说明，JS代码只限制图片的高或者宽时，宽或者高会按照比例进行相应调整。 或者：<imgsrc="..."style="width:100px;height:100px;"/>width宽height高，将改变的数值填入其中即可。  

### 下划线

![1603090948215](笔记.assets/1603090948215.png)

###   ![img](笔记.assets/8644ebf81a4c510fecb3c0446159252dd42aa57c-1604988134778.png)  ![img](笔记.assets/9825bc315c6034a8ddf095dfca13495409237659.png) 

###  request.getparameter()

根据name获取相应的值，如果传入的有相同的name当然只能获取一个值啊...如果你想获取很多相同name的值，应该用request.getParameterValues() 

对于httprequrest的request.getParameter()的作用，

  大致的内容如下：

<form action="xxxxxxx.do" >
<input name="name" value="哈哈"/>
<input type="submit" value="提交"/>
</form>
这个form提交请求后，在你的action中
String name = request.getparameter("name"); 
那么name的值就是“哈哈”
  它是一种取参数的方法。把jsp文件中的数据读取到出来。然后就可以封装利用起来。

### form标签

onsubmit 事件属性

当提交表单时执行一段 JavaScript：

```
<form action="demo_form.asp" onsubmit="checkForm()">
```

onsubmit 属性在提交表单时触发。

onsubmit 属性只在 <form> 中使用。

### radio按钮

实现单选个文本关联

				<input type="radio" name="sex" id="male" />
				<label for="male">男</label>
				<input type="radio" name="sex"id="female"/>
				<label for="female">女</lable>
### marquee标签详解

```txt

<marquee>标签，它是成对出现的标签，首标签<marquee>和尾标签</marquee>之间的内容就是滚动内容。<marquee>标签的属性主要有behavior、bgcolor、direction、width、height、hspace、vspace、loop、scrollamount、scrolldelay等，它们都是可选的。 

behavior属性 
behavior属性的参数值为alternate、scroll、slide中的一个，分别表示文字来回滚动、单方向循环滚动、只滚动一次，需要注意的是:如果在<marquee>标签中同时出现了direction和behavior属性，那么scroll和slide的滚动方向将依照direction属性中参数的设置。 
    <marquee behavior="alternate">我来回滚动</marquee> 
    <marquee behavior="scroll">我单方向循环滚动</marquee>
    <marquee behavior="scroll" direction="up" height="30">我改单方向向上循环滚动</marquee> 
    <marquee behavior="slide">我只滚动一次</marquee> 
    <marquee behavior="slide" direction="up">我改向上只滚动一次了</marquee> 

bgcolor属性
文字滚动范围的背景颜色，参数值是16进制(形式:#AABBCC或#AA5566等)或预定义的颜色名字(如red、yellow、blue等)。如下所示:<marquee behavior=="slide" direction="left" bgcolor="red">我的背景色是红色的</marquee> 

direction属性 
文字滚动的方向，属性的参数值有down、left、right、up共四个单一可选值，分别代表滚动方向向下、向左、向右、向上。如下所示: 
    <marquee direction="right">我向右滚动</marquee> 
    <marquee direction="right">我向下滚动</marquee> 

width和height属性 
width和height属性的作用决定滚动文字在页面中的矩形范围大小。width属性用以规定矩形的宽度，height属性规定矩形的高度。这两个属性的参数值可以是数字或者百分数，数字表示矩形所占的(宽或高)像素点数，百分数表示矩形所占浏览器窗口的(宽或高)百分比。如下所示: 
    <marquee width="300" height="30" bgcolor="red">我宽300像素，高30像素。</marquee> 

hspace和vspace属性 
这两个属性决定滚动矩形区域距周围的空白区域. 
    <marquee width="300" height="30" vspace="10" hspace="10" bgcolor="red">我矩形边缘水平和垂直距周围各10像素。</marquee> 
    <marquee width="300" height="30" vspace="50" hspace="50" bgcolor="red">我矩形边缘水平和垂直距周围各50像素。</marquee> 

loop属性 
loop属性决定滚动文字的滚动次数，缺省是无限循环。参数值可以是任意的正整数，如果设置参数值为-1或infinite时将无限循环。如下所示: 
    <marquee loop="2">我滚动2次。</marquee> 
    <marquee loop="infinite">我无限循环滚动。</marquee> 
    <marquee loop="-1">我无限循环滚动。</marquee> 

scrollamount和scrolldelay属性 
这两个属性决定文字滚动的速度(scrollamount)和延时(scrolldelay)，参数值都是正整数。如下所示: 
    <marquee scrollamount="100">我速度很快.</marquee> 
    <marquee scrollamount="50">我慢了些。</marquee> 
    <marquee scrolldelay="30">我小步前进。</marquee> 
    <marquee scrolldelay="1000" scrollamount="100">我大步前进。</marquee> 
align属性
这个属性决定滚动文字位于距形内边框的上下左右位置。您也可以将<marquee>和</marquee>之间的内容替换为图像或其它对象等功能。

参数 
direction 表示滚动的方向，值可以是left，right，up，down，默认为left 
behavior 表示滚动的方式，值可以是scroll(连续滚动)slide(滑动一次)alternate(来回滚动) 
loop 表示循环的次数，值是正整数，默认为无限循环 
scrollamount 表示运动速度，值是正整数，默认为6 
scrolldelay 表示停顿时间，值是正整数，默认为0，单位是毫秒 
align 表示元素的垂直对齐方式，值可以是top，middle，bottom，默认为middle 
bgcolor 表示运动区域的背景色，值是16进制的RGB颜色，默认为白色 
height、width 表示运动区域的高度和宽度，值是正整数(单位是像素)或百分数，默认width=100% height为标签内元素的高度。 
hspace、vspace 表示元素到区域边界的水平距离和垂直距离，值是正整数，单位是像素。 
onmouseover=this.stop() onmouseout=this.start() 表示当鼠标以上区域的时候滚动停止，当鼠标移开的时候又继续滚动。 

注释 
MARQUEE 元素的默认宽度与其父元素的宽度相等。如果 MARQUEE 位于没有指定宽度的 TD 内，你就需要明确设置 MARQUEE 的宽度。如果 MARQUEE 和 TD 的宽度都没有指定，那么滚动字幕就将限定于 1 个像素宽。
要创建垂直滚动的字幕，请将其 scrollLeft 属性设定为 0。要创建水平滚动的字幕，请将其 scrollTop 属性设定为 0，这将覆盖任何脚本设置。 
scrollLeft 和 scrollTop 属性当字幕滚动时为只读。当不处于滚动状态时，scrollLeft 对于设置为水平滚动的字幕来说为可读写，scrollTop 对于设置为垂直滚动的字幕来说为可读写。 
此元素在 Microsoft® Internet Explorer 3.0 的 HTML 中可用，在 Internet Explorer 4.0 的脚本中可用。 
此元素是块元素。 
此元素需要关闭标签。 

示例 
下面的例子使用了 MARQUEE 元素创建了由左向右的滚动字幕，移动速度为每 200 毫秒 10 像素。 
<MARQUEE DIRECTION=RIGHT BEHAVIOR=SCROLL SCROLLAMOUNT=10 SCROLLDELAY=200>这是一个滚动字幕。</MARQUEE> 
下面的例子显示了 marquee 元素的 scrollLeft 和 scrollTop 属性的一些用途。 
<MARQUEE id=m1 direction=right style="border-width:2px;border-style:solid;" width=200 height=200>向右</MARQUEE> 
<!-- 单击此按钮可在字幕滚动时读取 scrollLeft 和 scrollTop 属性的值。 --> 
<BUTTON onclick="alert('scrollLeft: ' + m1.scrollLeft + ' scrollRight: ' + m1.scrollTop)">读取</BUTTON> 
<!-- 当字幕停止时，你可以设置水平字幕的 scrollLeft，或者设置垂直字幕的 scrollTop。 --> 
<BUTTON onclick="m1.stop();m1.scrollLeft = 190;">停止并设置 scrollLeft=190</BUTTON> 
<BUTTON onclick="m1.start();">开始</BUTTON>
```



## Vscode

 你去学下CMake吧，Linux系统下VSCode装个Cmake插件直接用Cmake配置项目很方便，VScode编写C++，需要配置3个tasks.json、 launch.json 、 c_cpp_properties.json 这三个json文件。添加includePath只是让inteliSense在你编写代码的时候能够智能提示。你要debug还需要还需要配置tasks.json、 launch.json 这两个文件。（https://code.visualstudio.com/docs/cpp/config-mingw）这个是官网教程很详细。你要使用Linux系统的话最好先求看看基本的命令行，然后看看CMake怎么用。Linux其实下可以直接使用命令行来编译、调试，其实可以不用IDE，我使用VScode只是为了它提供InteliSense的代码补全功能。我的项目都是用CMake来构建的。配置那三个.json文件很麻烦 

## Ubuntu

### Ubuntu中拷贝文件或目录的方法

```
使用如下指令：

$ cp [选项] 源文件或目录 目标文件或目录
1
含义是把一个或者多个文件复制到目标文件或目录中。

选项有如下指令：

a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。

d 拷贝时保留链接。

f 删除已经存在的目标文件而不提示。

i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。

p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。

r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。

l 不作拷贝，只是链接文件。

需要说明的是，如果不加指令，如果复制的目录下已经含有同名文件，shell是不对覆盖进行提示的，这样会对文件造成破坏，建议在使用拷贝指令时，使用-i选项。

$ cp -i 源文件或目录 目标文件或目录

ubuntu下文件拷贝命令cp命令
　　该命令的功能是将给出的文件或目录拷贝到另一文件或目录中，就如同DOS下的copy命令一样，功能非常强大。
　　语法： cp ［选项］ 源文件或目录 目标文件或目录
　　说明：该命令把指定的源文件复制到目标文件或把多个源文件复制到目标目录中。
　　该命令的各选项含义如下：
　　- a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。
　　- d 拷贝时保留链接。
　　- f 删除已经存在的目标文件而不提示。
　　- i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。
　　- p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。
　　- r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。
　　- l 不作拷贝，只是链接文件。
　　需要说明的是，为防止用户在不经意的情况下用cp命令破坏另一个文件，如用户指定的目标文件名是一个已存在的文件名，用cp命令拷贝文件后，这个文件就会被新拷贝的源文件覆盖，因此，建议用户在使用cp命令拷贝文件时，最好使用i选项。
　　$ cp - i exam1.c /usr/wang/shiyan1.c
　　该命令将文件exam1.c拷贝到/usr/wang 这个目录下，并改名为 shiyan1.c。若不希望重新命名，可以使用下面的命令：
　　$ cp exam1.c /usr/ wang/
　　$ cp - r /usr/xu/ /usr/liu/
　　将/usr/xu目录中的所有文件及其子目录拷贝到目录/usr/liu中
　　功能: 复制文件或目录
说明: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息
参数:
     -a 或 --archive     此参数的效果和同时指定'-dpR'参数相同
     -b 或 --backup      删除、覆盖目的文件先备份，备份的文件或目录亦建立为符号链接，并指向源文件或目录链接的源文件或目录。假如没有加上这个参数，在复制过程中若遇到符号链接，则会直接复制源文件或目录
     -f 或 --force       强行复制文件或目录， 不论目的文件或目录是否已经存在
     -i 或 --interactive 覆盖文件之前先询问用户
     -l 或 --link        对源文件建立硬链接，而非复制文件
     -p 或 --preserve    保留源文件或目录的属性，包括所有者、所属组、权限与时间
     -P 或 --parents     保留源文件或目录的路径，此路径可以是绝对路径或相对路径，且目的目录必须已经丰在
     -r                  递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理
     -R 或 --recursive   递归处理，将指定目录下的文件及子目录一并处理
     -s 或 --symbolic-link  对源文件建立符号链接，而非复制文件
     -S <备份字尾字符串> 或 --suffix=<备份字尾字符串> 用"-b"参数备份目的文件后，备份文件的字尾会被加上一个备份字符串。默认的备份字尾符串是符号"~"
     -u 或 --update      使用这项参数之后，只会在源文件的修改时间(Modification Time)较目的文件更新时，或是名称相互对应的目的文件并不存在，才复制文件
     -v 或 --verbose     显示执行过程
     -V <备份方式> 或 --version-control=<备份方式>  指定当备份文件时，备份文件名的命名方式，有以下3种:
                         1.numbered或t, 将使用备份编号，会在字尾加上~1~字符串，其数字编号依次递增
                         2.simple或never 将使用简单备份，默认的备份字尾字符串是~, 也可通过-S来指定
                         3.existing或nil将使用当前方式，程序会先检查是否存在着备份编号，若有则采用备份编号，若无则采用简单备份
     -x 或 --one-file-system  复制的文件或目录存放的文件系统，必须与cp指令执行时所处的文件系统相同，否则不复制，亦不处理位于其他分区的文件
     --help              显示在线帮助
     --sparse=<使用时机>  设置保存希疏文件的时机
     --version           显示版本

示例:
    .复制文件，只有源文件较目的文件的修改时间新时，才复制文件
     cp -u -v file1 file2

    .将文件file1复制成文件file2
     cp file1 file2

    .采用交互方式将文件file1复制成文件file2
     cp -i file1 file2

    .将文件file1复制成file2，因为目的文件已经存在，所以指定使用强制复制的模式
     cp -f file1 file2

    .将目录dir1复制成目录dir2
     cp -R file1 file2

    .同时将文件file1、file2、file3与目录dir1复制到dir2
　　 cp -R file1 file2 file3 dir1 dir2

    .复制时保留文件属性
     cp -p a.txt tmp/

    .复制时保留文件的目录结构
     cp -P  /var/tmp/a.txt  ./temp/

    .复制时产生备份文件
     cp -b a.txt tmp/

    .复制时产生备份文件，尾标 ~1~格式
     cp -b -V t   a.txt /tmp   
 
    .指定备份文件尾标   
     cp -b -S _bak a.txt /tmp

 
```



### 游戏命令

https://blog.csdn.net/LUAOHAN/article/details/105407787?spm=1000.2123.3001.4430

### gcc编译

UBuntu16.04下用gcc编译c文件过程详解

https://blog.csdn.net/qq_29856169/article/details/88056767

 ![img](笔记.assets/11.png) 

 ![img](笔记.assets/12.png) 

![65750C500CA151F982F5F67D3599F0B0](笔记.assets/65750C500CA151F982F5F67D3599F0B0.png)

 ![img](笔记.assets/23.png)  

 ![img](笔记.assets/24.png) 

 ![img](笔记.assets/27.png) 

### shell脚本数组报错Syntax error: "(" unexpected

标签 [sh: Syntax error: "](http://www.voidcn.com/tag/sh%3A+Syntax+error%3A+") [bash](http://www.voidcn.com/tag/bash) 栏目 [Unix](http://www.voidcn.com/column/unix)

*原文*  [http://blog.51cto.com/sry2004/2057190](javascript:void())

按照正常的shell数组定义，例如3.sh

```
cat 3.sh 
#!/bin/sh
a=( 1 2 3)
for number in ${a[@]}
do
echo $number
done

执行命令
sh 3.sh   
3.sh: 2: 3.sh: Syntax error: "(" unexpected
执行该脚本，在有的机器上会报错Syntax error: "(" unexpected

bash 3.sh     
1
2
3
与你实际使用的shell版本有关。你可以用 ls -l /bin/*sh 打印出来，例如：
 ls -l /bin/*sh
-rwxr-xr-x 1 root root 1021112 Oct  7  2014 /bin/bash
-rwxr-xr-x 1 root root  121272 Feb 19  2014 /bin/dash
lrwxrwxrwx 1 root root       4 Dec  4 01:40 /bin/rbash -&gt; bash
lrwxrwxrwx 1 root root       4 Dec  4 01:40 /bin/sh -&gt; dash
lrwxrwxrwx 1 root root       7 Nov 14  2013 /bin/static-sh -&gt; busybox
```

在这里，sh被重定向到dash，因此，如果执行./3.sh，则使用的是dash 避免报错可有多种方法，例如执行 bash example.sh，或者，将脚本第一行改为 #!/bin/bash，执行./3.sh也可以。



${}里放的是变量，$(commamd)里是执行command然后用它的输出代替$()。

比如data + %Y%m%d执行后是20170930，date3=$(data + %Y%m%d),执行后就是date3=20170930

### Linux上.sh文件中的命令执行不了

 .sh第一行

\#!/bin/bash 以bash shell来解释
\#!/bin/csh 以csh shell来解释
\#!bin/sh 以下代码由sh shell来解释

linux有多个shell，bash shell、cshell，它们都是因为有不同的需求而产生。。所以有些脚本代码适合这个SHELL，有的适合那个SHELL 就用上面的方法来说明了。 

（1）当*.sh文件为dos格式时，无法执行文件中的命令。需要将文件格式设置为 linux格式才能执行。

（2）dos格式和linux格式之间的转换命令如下所示：



```html
		dos2unix [-n] file [newfile]   从DOS转换到UNIX
```



-n : 保留原来的文档,将转换后的内容输入到新文档中 例如: dos2unix -n old new

Linux中执行shell脚本的4种方法总结,即在Linux中运行shell脚本的4种方法:

**方法一：切换到shell脚本所在的目录（此时，称为工作目录）执行shell脚本：**

复制代码 代码如下:

```txt
cd /data/shell 
./hello.sh
```


./的意思是说在当前的工作目录下执行hello.sh。如果不加上./，bash可能会响应找到不到hello.sh的错误信息。因为目前的工作目录 （/data/shell）可能不在执行程序默认的搜索路径之列,也就是说，不在环境变量PATH的内容之中。查看PATH的内容可用 echo $PATH 命令。现在的/data/shell就不在环境变量PATH中的，所以必须加上./才可执行。

 

**方法二：以绝对路径的方式去执行bash shell脚本：**

复制代码 代码如下:

```bash
/data/shell/hello.sh
```

 

**方法三：直接使用bash 或sh 来执行bash shell脚本：**

复制代码 代码如下:

```bash
cd /data/shell 
bash hello.sh
```


或

复制代码 代码如下:

```bash
cd /data/shell 
sh hello.sh
```


注意，若是以方法三的方式来执行，那么，可以不必事先设定shell的执行权限，甚至都不用写shell文件中的第一行（指定bash路径）。因为方法三 是将hello.sh作为参数传给sh(bash)命令来执行的。这时不是hello.sh自己来执行，而是被人家调用执行，所以不要执行权限。那么不用 指定bash路径自然也好理解了啊，呵呵……。

 

**方法四：在当前的shell环境中执行bash shell脚本：**

复制代码 代码如下:

```bash
cd /data/shell
. hello.sh
```


或

复制代码 代码如下:

```bash
cd /data/shell 
source hello.sh
```


前三种方法执行shell脚本时都是在当前shell（称为父shell）开启一个子shell环境，此shell脚本就在这个子shell环境中执行。shell脚本执行完后子shell环境随即关闭，然后又回到父shell中。而方法四则是在当前shell中执行的。

**方法五：在shell中启动另外的shell**

在运行shell脚本时候，有三种方式来调用外部的脚本，exec（exec script.sh）、source（source script.sh）、fork（./script.sh） 
1、exec（exec /home/script.sh）： 
使用exec来调用脚本，被执行的脚本会继承当前shell的环境变量。但事实上exec产生了新的进程，他会把主shell的进程资源占用并替换脚本内容，继承了原主shell的PID号，即原主shell剩下的内容不会执行。

2、source（source /home/script.sh）

使用source或者“.”来调用外部脚本，不会产生新的进程，继承当前shell环境变量，而且被调用的脚本运行结束后，它拥有的环境变量和声明变量会被当前shell保留，类似将调用脚本的内容复制过来直接执行。执行完毕后原主shell继续运行。

3、fork（/home/script.sh）

直接运行脚本，会以当前shell为父进程，产生新的进程，并且继承主脚本的环境变量和声明变量。执行完毕后，主脚本不会保留其环境变量和声明变量。

总结：这样来看fork最灵活，source次之，exec最诡异。

 

查看哪个用户用的什么shell登录：

1.echo $SHELL     #查看当前登录的用户所用的shell
2.grep username /etc/passwd 看最後一段  #查看想要知道的用户登录所用的shell

 （“~/”表示当前用户目录，它等于“/home/username/”） 

### ASCII文件和二进制文件

 ASCII文件也称2113为文本文件，这种文件在磁盘中5261存放时每个字符对应一个字节，用4102于存放对应的ASCII码。例如，数16535678的存储形式为：5 6 7 8  ASCII文件一般是直接供人阅读的2113，它里面的信息是5261以ASCII码为准存储的，例如41024会转换为ASCII码52进行存储

二进制文件是按二进制的编码方式来存放文件的。 例如， 数5678的存储形式为： 00010110 00101110只占二个字节。二进制文件虽然也可在屏幕上显示， 但其内容无法读懂。C系统在处理这些文件时，并不区分类型，都看成是字符流，按字节进行处理。 输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。  二进制1653文件则不是用于供人阅读，而是用于保存数值的，它里面的信息是直接以二进制为准存储的，例如4不会先转换为ASCII码52，而会直接以二进制方式100存储 

Ubuntu查看文件格式（后缀名）

在文件目录执行：

```
$ file filename　　#filename表示要查看的文件名
```

### **ubuntu下创建文件的三种方式**

也可以：

在使用 "cat > filename.txt" 创建文件时，可采用下面步骤:
2、录入文本内容； 
4、在键盘上按下Ctrl+D (或者键入Control－D)。 

文本被存盘，shell提示符重新出现



使用cat << _EOF_ 时 Ctrl+D同样可以退出

**1.touch命令**：touch 文件名.后缀

在当前工作目录底下新建一个文件，如

```bash
touch velocity_publisher.cpp
1
```

**2.gedit命令**：gedit 文件名.后缀
打开一个新的文件，如果没有输入内容直接关掉，该文件没有保存，输入了内容，才可以保存下来
gedit命令必须修改文件权限。

```bash
gedit velocity_publisher.cpp
1
```

**3.vim命令**：vim 文件名.后缀
我的系统提示要先安装Vim

```bash
sudo apt install vim 
1
```

查看帮助的方式：终端输入 vim , 敲击回车键（enter/return） ，进入 VIM , 键盘输入 :help
按下Esc键，键盘输入:wq 退出文件并保存对文件的修改

VIM 有四个模式，：

**正常模式** (Normal-mode):正常模式一般用于浏览文件，也包括一些复制、粘贴、删除等操作。通过键盘在文本中快速移动光标，光标范围从小到大是字符、单词、行、句子、段落和屏幕。启动 VIM 后默认位于正常模式。不论是什么模式，按一下 Esc键 ( 有时可能需要按两下，插入模式按一下 Esc ，就会切换到正常模式，命令模式或者可视模式下执行完操作以后，就会自动进入正常模式，如果进入命令模式或者可视模式没有执行任何操作，按两下 Esc 即可 ）都会进入正常模式。

**插入模式** (Insert-mode):在正常模式中按i 键会进行插入模式。该模式启动以后，就会进入编辑状态，通过键盘输入内容。

**命令模式** (Command-mode):在正常模式中，按下：（冒号）键或者/ （斜杠），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。

**可视模式** (Visual-mode):在正常模式按下v, V, Ctrl+v，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。

## C#

### [中文正则表达式匹配-正则中文匹配](https://www.cnblogs.com/youyouyunduo/p/11706688.html)

若验证时出现如下错误，需要在page_load中加如下语句

![img](笔记.assets/clip_image002.jpg)

protected void Page_Load(object sender, EventArgs e)

  {

​      Page.UnobtrusiveValidationMode = System.Web.UI.UnobtrusiveValidationMode.None;

 }

### [C#获取当前时间](https://www.cnblogs.com/LCLBook/p/11233716.html)

```
//获取日期+时间
DateTime.Now.ToString();      ``// 2008-9-4 20:02:10
DateTime.Now.ToLocalTime().ToString();    ``// 2008-9-4 20:12:12
```

 

```
//获取日期
DateTime.Now.ToLongDateString().ToString();  ``// 2008年9月4日
DateTime.Now.ToShortDateString().ToString();  ``// 2008-9-4
DateTime.Now.ToString(``"yyyy-MM-dd"``);    ``// 2008-09-04
DateTime.Now.Date.ToString();      ``// 2008-9-4 0:00:00
```

 

```
//获取时间
DateTime.Now.ToLongTimeString().ToString();  ``// 20:16:16
DateTime.Now.ToShortTimeString().ToString();  ``// 20:16
DateTime.Now.ToString(``"hh:mm:ss"``);    ``// 08:05:57
DateTime.Now.TimeOfDay.ToString();    ``// 20:33:50.7187500
```

 

```
//其他
DateTime.ToFileTime().ToString();    ``// 128650040212500000
DateTime.Now.ToFileTimeUtc().ToString();  ``// 128650040772968750
DateTime.Now.ToOADate().ToString();    ``// 39695.8461709606
DateTime.Now.ToUniversalTime().ToString();  ``// 2008-9-4 12:19:14
```

 

```
DateTime.Now.Year.ToString();     获取年份 ``// 2008
DateTime.Now.Month.ToString();   获取月份  ``// 9
DateTime.Now.DayOfWeek.ToString(); 获取星期  ``// Thursday
DateTime.Now.DayOfYear.ToString(); 获取第几天  ``// 248
DateTime.Now.Hour.ToString();     获取小时  ``// 20
DateTime.Now.Minute.ToString();   获取分钟  ``// 31
DateTime.Now.Second.ToString();   获取秒数  ``// 45
```

 

```
//n为一个数,可以数整数,也可以事小数
dt.AddYears(n).ToString();  ``//时间加n年
dt.AddDays(n).ToString();  ``//加n天
dt.AddHours(n).ToString();  ``//加n小时
dt.AddMonths(n).ToString();  ``//加n个月
dt.AddSeconds(n).ToString();  ``//加n秒
dt.AddMinutes(n).ToString();  ``//加n分
```

### [C# Graphics类详解](https://www.cnblogs.com/vaevvaev/p/6925140.html)

```
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace DrawRectangle
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            Graphics dc = CreateGraphics();
            Show();
            Pen bluePen = new Pen(Color.Blue, 3);
            dc.DrawRectangle(bluePen, 0, 0, 50, 50);
            
        }
    }
}
```



### 创建项目

//路径跳转
cd


//新建项目
dotnet new console -o 路径  

//运行
dotnet run  

//用于发布exe
<RuntimeIdentifier>win10-x64</RuntimeIdentifier> 

 

//在项目根目录执行命令： 
运行程序 :
dotnet run -p ceshi002.csproj

发布exe :
dotnet publish ceshi002.csproj

 

然后在cmd中用命令指定到路径新建项目：

输入：

> dotnet new console -o D:\c#cmd测试\myceshi001


**new** 是初始化.NET项目

**console** 是模板

**-o** 是要放置生成的输出的位置。

后面跟路径 **D:\c#cmd测试\myceshi001**

**myceshi001**是项目的命名



输入 **d:** 跳转到d盘
输入 **cd 路径** 跳转到项目路径

输入 **dotnet run** 尝试运行



![1604823796094](笔记.assets/1604823796094.png)

 Console.ReadLine(); 会等待直到用户按下回车，一次读入一行
Console.ReadKey(); 则是等待用户按下任意键，一次读入一个字符。 

ReadLine方法以同步方式执行。 即，**被阻止，直至读取行或按下 Ctrl + Z 键盘组合。** In属性返回TextReader对象，它表示标准输入的流并具有这两个同步 TextReader.ReadLine方法和异步TextReader.ReadLineAsync方法。 但是，当用作控制台的标准输入流， TextReader.ReadLineAsync同步而不是以异步方式执行，并返回Task仅完成读取的操作后。

如果此方法将引发 OutOfMemoryException异常，而在基础读取器的位置 Stream对象高级的字符的方法是可以读取，但已读入内部的字符数ReadLine缓冲区将被丢弃。 由于不能更改流中读取器的位置，因此已读取的字符是不可恢复，并可以访问仅通过重新初始化 TextReader。 如果流中的初始位置是未知或流不支持查找，基础 Stream还需要重新初始化。 若要避免这种情况并生成可靠的代码，应使用 KeyAvailable属性和ReadKey只读方法和应用商店中预先分配的缓冲区的字符。

如果该方法是从控制台读取输入时按 `Ctrl + Z` 字符，该方法返回 `null`。 这使用户以防止进一步的键盘输入时ReadLine在循环中调用方法。

### [MSIL 反汇编程序 (Ildasm.exe)](https://www.cnblogs.com/jxnclyk/archive/2010/05/01/1725605.html)

MSIL是.NET Framework中最重要的概念之一。通过MSIL可以预知不同.NET语言的执行效率应该是接近的。通过MSIL汇编程序(ilasm.exe)和MSIL反汇编程序(dilasm.exe)可以观察.NET应用的内部构造，因此也可以用于.NET应用、组件的破解。
**ILDASM的使用方法**

步骤二：假设我们有一个控制台应用程序Test.exe。然后把Test.exe拷贝到步骤三：在命令提示窗口进行下面例子中的操作。例如：ildasm Test.exe 
ildasm Test.exe /output:Test.il 
ildasm Test.exe /text 
ildasm /item:Test::Print Test.exe /text将Test.exe中类Test中的方法Print进行反汇编

 

ildasm myHello.exe

默认的GUI为下图所示：

![img](笔记.assets/IL-GUI.JPG)

​        GUI中显示的IL代码

下面的命令对 `MyFile.exe` 文件进行反汇编，并将结果 MSIL 汇编程序文本存储在 `MyFile.il` 文件中。

```
ildasm MyFile.exe /output:MyFile.il
```

下面的命令对 `MyFile.exe` 文件进行反汇编，并将结果 MSIL 汇编程序文本显示到控制台窗口中。

ildasm MyFile.exe /text

如果文件 `MyApp.exe` 包含嵌入的托管和非托管资源，则下面的命令将产生以下 4 个文件：`MyApp.il`、`MyApp.res`、`Icons.resources, `和 `Message.resources`：

ildasm MyApp.exe /output:MyApp.il

下面的命令对 `MyFile.exe `的 `MyClass` 类中的 `MyMethod` 方法进行反汇编，并将输出显示到控制台窗口中。

ildasm /item:MyClass::MyMethod MyFile.exe /text

在上面的示例中，可能有几个具有不同签名的 `MyMethod` 方法。下面的命令对返回类型为**void** 且带有参数**int32** 和 **System.String** 的`MyMethod` 方法进行反汇编。

ildasm /item:"MyClass::MyMethod(void(int32,class System.String))" MyFile.exe /text



### 查看程序集内容

可使用 [Ildasm.exe（IL 反汇编程序）](https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ildasm-exe-il-disassembler)查看文件中的 Microsoft 中间语言 (MSIL) 信息。 如果要检查的文件是程序集，此信息可包括程序集的属性以及对其他模块和程序集的引用。 此信息有助于确定文件是程序集还是程序集的一部分，以及文件是否具有对其他模块或程序集的引用。

若要使用 Ildasm.exe 来显示程序集的内容，请在命令提示符下键入 ildasm <assembly name>。 例如，以下命令反汇编 Hello.exe 程序集。

cmd复制

```cmd
ildasm Hello.exe
```

若要查看程序集清单信息，请在“MSIL 反汇编程序”窗口中双击“清单”图标。

### 示例

下例以基本的“Hello World”程序开始。 编译该程序后，使用 Ildasm.exe 反汇编 Hello.exe 程序集，并查看程序集清单 。

C#复制

```csharp
using System;

class MainApp
{
    public static void Main()
    {
        Console.WriteLine("Hello World using C#!");
    }
}
```

在 Hello.exe 程序集上运行 ildasm.exe 命令，然后在“MSIL 反汇编程序”窗口中双击“清单”图标生成以下输出 ：

输出复制

```output
// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly Hello
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 )
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .hash algorithm 0x00008004
  .ver 0:0:0:0
}
.module Hello.exe
// MVID: {7C2770DB-1594-438D-BAE5-98764C39CCCA}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0003       // WINDOWS_CUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x00600000
```

下表描述了本例所使用 Hello.exe 程序集的程序集清单中的各项指令：

| 指令                  | 描述                                                         |
| :-------------------- | :----------------------------------------------------------- |
| **.assembly extern ** | 指定包含当前模块所引用项目的另一程序集（在此示例中为 `mscorlib`）。 |
| **.publickeytoken **  | 指定引用程序集的实际密钥的标记。                             |
| **.ver **             | 指定引用程序集的版本号。                                     |
| **.assembly **        | 指定程序集名称。                                             |
| **.hash algorithm **  | 指定使用的哈希算法。                                         |
| **.ver **             | 指定程序集的版本号。                                         |
| **.module **          | 指定组成程序集的模块名称。 在此示例中，程序集只包含一个文件。 |
| **.subsystem **       | 指定程序要求的应用程序环境。 在此示例中，值 3 表示该可执行文件从控制台运行。 |
| .corflags             | 当前是元数据中的一个保留字段。                               |

根据程序集的内容，程序集清单可包含许多不同的指令。 有关程序集清单中指令的详尽列表，请参阅 Ecma 文档，特别是“第 II 部分：Metadata Definition and Semantics”（第 2 部分：元数据定义和语义）和“Partition III:CIL 指令集”：

- [ECMA C# 和公共语言基础结构标准](https://docs.microsoft.com/zh-cn/dotnet/standard/components#applicable-standards)
- [标准 ECMA-335 - 公共语言基础结构 (CLI)](http://www.ecma-international.org/publications/standards/Ecma-335.htm)

**树视图图标**

[![image](笔记.assets/09171926-ccae166f22844ad0ba90cba3f30ed382.png)](https://images0.cnblogs.com/blog/117912/201304/09171925-249b0d39ce7f40de81458fbe2aed4ff9.png)

菱形为字段，菱形里加入s 则为静态字段；

红色正方为方法，红色正方形里面加s为静态方法。

.field 为字段

.method 方法

.ctor 貌似是构造函数

汇编语言中的 NOP 为空该指令，主要给外部设备或者指令间隙准备时间。

Ldarg 字段  将参数（由指定索引值引用）加载到堆栈上。 (汇编指令可以通过msdn查询)

Ldarg.0 :将参数 0 加载到堆栈上

castclass 尝试将引用的对象转换为指定的对象

stfld 用新值替换在对象引用或指针的字段中存储的值

Ldfld 字段 查找对象中其引用当前位于计算堆栈的字段的值。

Callvirt 对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。

## C语言

### 如何使用C语言实现copy拷贝的功能

```
#include
   
    
int main(void){
    char buf[100] = {};
    int size = 0;
    FILE *p_file = fopen("b.out","rb");
    FILE *p_dest = fopen("c.out","wb");
    if(!p_file){
        return 0;
    }
    p_dest = fopen("c.out","wb");
    if(!p_file){
        fclose(p_file);
        p_file = NULL;
        return 0;
    }
    while(size = fread(buf,sizeof(char),100,p_file)){
        fwrite(buf,sizeof(char),size,p_dest);
    }
    fclose(p_dest);
    p_dest = NULL;
    fclose(p_file);
    p_file = NULL;
    return 0;
}

/*
 * 文件名：fileCopy
 * 功能描述：实现文件的复制功能-linux平台下
 * 编写人：王廷云
 * 编写日期：2018-1-12
*/
#include <stdio.h>
#include <stdlib.h>

#define  BUFFSIZE  1024		// 缓冲区大小

/* 程序从主函数开始
 * 思路： 
 * -> 以读的方式打开源文件
 * -> 以写的方式打开目标文件，如果目标文件不存在则创建
 * -> 读取源文件内容，写入到目标文件上
 * -> 重复循环直到文件读写完成 
*/
int main(int arc, char *argv[])
{
	FILE *fin;	// 源文件
	FILE *fout; // 目标文件
	char *buff; // 缓冲区指针

	int ret;	// 用于检查函数是否操作成功

	/* 检查参数 */
	if (arc != 3)
	{
		printf("Usage: %s src_file dest_file\n", argv[0]);
		return -1;
	}

	/* 以读的方式打开源文件 */
	fin = fopen(argv[1], "r");
	if (NULL == fin) 	// 检查打开情况
	{
		perror(argv[1]);
		return -2;
	}

	/* 以写的方式打开目标文件 */
	fout = fopen(argv[2],"w");
	if (NULL == fout) 	// 检查打开情况
	{
		perror(argv[1]);
		goto err0;
	}
	
	/* 分配缓冲区内存空间 */
	buff = malloc(BUFFSIZE);
	if (NULL == buff)	// 检查分配空间是否成功
	{
		fprintf(stderr, "molloc failed\n");
		goto err1;
	}

	/* 循环读写文件 */
	while (1)
	{
		/* 从源文件中读取内容 */
		ret = fread(buff, 1, BUFFSIZE, fin);
		
		/* 把从源文件读取到的容写入到目标文件中 */
		if (ret != BUFFSIZE)
		{
			fwrite(buff, ret, 1, fout);
		}
		else
		{
			fwrite(buff, BUFFSIZE, 1, fout);
		}
		
		if (feof(fin))
			break;
	}

	/* 关闭打开的文件 */
	fclose(fin);
	fclose(fout);

	/* 释放动态分配的内存空间 */
	free(buff);
	
	return 0;
	
	/* 出错时的层次退出 */
err2:
	free(buff);
err1:
	fclose(fout);
err0:
	fclose(fin);

	return -3;
}
```



### 读字符串函数：getline():

 getline会生成一个包含一串从输入流读入的字符的字符串，直到以下情况发生会导致生成的此字符串结束：1）到文件结束，2）遇到函数的定界符，3）输入达到最大限度。 

成员函数getline()是从输入流中读取一行字符，读到终止符时会将'0'存入结果缓冲区中，作为输入的终止。终止符可以是默认的终止符，也可以是定义的终止符。函数的语法结构是：

getline(<字符数组chs>，<读取字符的个数n>，<终止符>) [1] 

在函数遇到和结束定界符相等的字符时函数结束，同时函数抽出定界符，此种情况下该定界符既不被放回输入流，也不被放入要生成的字符串。所以由此可以理解输入结束后的第一个回车是定界符，被确认后抛弃，而第二个才是程序执行运行时正常需要的.

C 有 fgets()，gets() 函数，gcc编译器扩展定义了getline()函数。

用于读取一行[字符](https://baike.baidu.com/item/字符)，包括换行符和字符串终止符。

#### 使用条件

linux标准C中使用条件：

\#if defined(_GNU_SOURCE) || _POSIX_C_SOURCE >= 200809L

\#include <stdio.h>

函数声明：

ssize_t getline(char **lineptr, size_t *n, FILE *stream);

#### 返回值

成功：返回读取的字节数。

失败：返回-1。

参数：

lineptr：指向存放该行字符的指针，如果是NULL，则有系统帮助malloc，请在使用完成后free释放。

n：如果是由系统malloc的指针，请填0

stream：文件描述符

get(char*array,int count,char delim)与getline(char*array,int count,char delim)的不同点：

[成员函数](https://baike.baidu.com/item/成员函数/2440706)get有三种版本：无[参数](https://baike.baidu.com/item/参数/5934974)的、带一个参数的带三个参数的。不带参数的get函数从指定的[输入流](https://baike.baidu.com/item/输入流/12712916)中提取（输入）一个字符（包括空白字符）并返回该字符；当遇到输入流中的文件结束符时，返回[EOF](https://baike.baidu.com/item/EOF/1017800)。为与 [ASCII](https://baike.baidu.com/item/ASCII/309296)字符值有所区别，EOF的值通常为-1（不同系统中的EOF值有可能是不一样的）。带一个字符型参数的get成员函数自动提取输入流中的下一个字符（包括空白字符）。当遇到文件结束符时,函数返回0（假），否则返回对 Istream对象的引用，并用该引用再次调用get函数。带有三个参数的get成员函数，其三个参数分别是接收字符的字符数组、字符数组的大小和终止字符（默认值为'\n'）。函数或者在读取比指定的最多字符数少一个字符后结束，或者在遇到终止字符时结束。为使字符数组（被程序用作缓冲区）中的输入字符串能够结束，空字符会被插入到字符数组中。函数不把终止字符放到字符数组中，但是终止字符仍然会保留在输入流中 [2] 。

成员函数 getline与带三个参数的get函数类似，它读取一行信息到[字符数组](https://baike.baidu.com/item/字符数组/2182126)中然后插入一个空字符。所不同的是，getline要去除输入流中的终止字符，但是不把它存放在字符数组中 [2] 。

当输入的字符数小于count时遇到字符delim，get函数不会读取delim这个字符，而getline函数将读取这个字符但是不存进array当中去，而是将其丢弃，当然，两者都会在读取的字符串后面自动加上'\0'(teminator character)

当输入的字符数大于count时，则get函数只读取count-1个字符，而其余的字符仍然保存在缓冲区中，还可再对其进行读取；但是函数getline则不然。

如果输入行包含的字符数比指定要读取的字符多，那么get()和getline()读取指定数目的字符后，将把余下的字符留在输入队列中。对get()而言，我们可以用另一条读取函数来读取留在输入队列中的数据，你也可以写一段代码将余下的字符清除。不同的是getline()会设置失效位(faibit)，并且关闭后面的输入，这个时候用ch=cin.get();是读取不到留在输入队列中的字符的。你可以用下面的命令来恢复输入：cin.clear()；因为clear()会重置失效位，打开输入。这个时候ch=cin.get();就可以读取留在输入队列中的字符。

getline()接收一个字符串，可以接收空格，需要包含#in⁃clude<string>，getline()和cin.getline()类似，但是后者属于istream流，而前者属于string流 [3] 。

### 二叉树

 前序顺序是ABC（根节点排最先，然后同级先左后右）；中序顺序是BAC(先左后根最后右）；后序顺序是BCA（先左后右最后根）。 

 ![img](笔记.assets/20180507105447745) 

### 数组指针问题

 声明了这样一个函数:   void matrix_mult(float **p); 
然后再主函数中 声明了 一个 二维数组float a[3][3];
进而在使用时这样：matrix_mult(a);
之后悲剧，编译器提示：cannot convert parameter 1 from 'float [3][3]' to 'float ** '
有错误。
改正方法：
matrix_mult(float (\*p)[N]);//N 为声明二维数组第二维的大小值，然后再进行传参：matrix_mult(a);OK了。
总结：这是一个老生常谈的问题：关于数组和指针
说明：
指针是一个变量名，而数组不是变量名，数组跟接近于一种结构体。
例子：
int \*p; int a[2]; p = a;
int n = sizeof(p);
int len = sizeof(a);
n 的值为4，而len的值为8；
int a\[10][20]; //真正的二维数组，
int \*b[10]; //定义分配了10个指针，没有初始化。换句话说，b是一个由10个整型（int）指针构成的指针数组。
int (\*p)[3];//指向数组的指针  行指针
int (*p)();//指向函数的指针
int *p();//p是一个函数，返回值是一个int型指针
float ** 这里的p不是二维数组的指针，而是指向指针的指针，即二级指针。
正确的二维数组的指针应该是：Int a[2] [2];Int (\*p)[2];//定义时无论数组维数，只可忽略第一维
二维数组其实只是一个指针，而二级指针是指向指针的指针，所以二者并不等价 

int** A11;

//making a 1 diminsional pointer based array.

A11 = new int *[newSize];

//making that 1 diminsional pointer based array , a 2D pointer based array

A11[i] = new int[newLength];

```
/*
in order to be able to create a matrix without any limitaion in c++,
one way is to create it using pointers.
as you see by using a pointer to pointer strategy we can make a multi-
dimensional Matrix of any size . The notation also makes us capable of
creating a matrix with VARIABLE size at runtime ,meaning we can resize
the size of our matrix at runtime , shrink it or increase it , your choice.
what we do is simple , first we make a pointer of pointer variable , this
means that our first pointer will point to another pointer which again
this pointer ,points to sth else(we can make it point to an array) .
int **A;
will declare the variable , we now need to expand it .
now make a pointer based array and allocate the memory dynamicly
A = new int *[desired_array_row];
this gives us a one diminsional pointer based array,now you want a 2D array?
big deal,lets make one.
we use for() to achieve this goal , remember when i said we are going to make
a variable which is a pointer of pointer ? which meant any location pointed to somewhere else
, we made a pointer based array , a one diminsional one , just up there ,
and you know this fatct that an array is consits of individual blocks right?
and the fact that each block can be used just like a solo variable.
so simply if we could write
A = new int *[any_size];
cant we do it to all of our indiviual array blocks which are just like the solo variable ?
so this means that if we could do it with A, and get an array , we can use the same method
to make different arrays for different block of the array we made in first place.
we use for() to iterate through all of the blocks of the previously made array, and
then for each block we create a single array .
for ( int i = 0; i < desired_array_row; i++)
A[i] = new int [desired_column_size];
after this for , we can enjoy our 2D array wich can be access like any ordinary array we know.
just use the conventional notation for accessing array blocks for either reading or writing.( A[i][j])
and remember to free the space we allocated for our 2D array at the end of the program .
we do such a thing this way:
for ( int i = 0; i < your_array_row; i++)
{
    delete [] A[i];
}
delete[] A;
.using this method you can make any N-diminsional array, you just need to use for with right iteration.
*/
```



### 输入缓冲：

 对于 %d，在缓冲区中，空格、回车、Tab 键都只是分隔符，不会被 scanf 当成数据取用。%d 遇到它们就跳过，取下一个数据。但是如果是 %c，那么空格、回车、Tab 键都会被当成数据输出给 scanf 取用 

 不管是数字还是字符都会被当成数据存进去。但只有按回车，scanf 才会进去取数据，所取数据的个数取决于 scanf 中“输入参数”的个数。 

#### getchar()

该函数的原型为：

\# include <stdio.h>
int getchar(void);

功能是从缓冲区中读取一个字符。这个函数非常简单，连参数都没有，非常好用。

 回答是“不需要”，仍然只需要一个 getchar()！前面说过，当 scanf 用 %d 取缓冲区数据的时候，如果遇到空格、回车或 Tab 键就跳过去。不仅如此，这些被跳过去的空白符都被释放了。所以假如前面有三个 scanf 给 int 型变量赋值，那么第一个 scanf 输入回车后把回车遗留在了缓冲区，而第二个 scanf 取值时会越过第一个 scanf 遗留在缓冲区中的回车，那么这个回车就会从缓冲区中释放。但第二个 scanf 取完值后也在缓冲区中留下了一个回车，而当第三个 scanf 到缓冲区中取值时会跳过第二个 scanf 遗留的回车，这个回车同样也会从缓冲区中释放，所以归根结底最后缓冲区中只有一个回车，也就是说，缓冲区中永远不可能遗留多个回车。 

 由此我们知道，当用 %d 获取输入流中的数据的时候，如果遇到字符（空格、回车、Tab 除外），则直接从输入流中退出来，什么都不取。但如果是用 %c 获取，那么任何数据都会被当作一个字符。所以如果你要从输入流中取一个字符，但在之前使用过 scanf，那么此时就必须要先用 getchar() 吸收回车。否则取到的将不是你想要的字符，而是 scanf 遗留在输入流中的回车。如果你要从输入流中取的不是字符，那就不需要用 getchar() 吸收回车了。

以上详细分析了什么时候需要吸收回车，什么时候不需要。但实际编程中，程序往往很长，我们很难预测到下一次到缓冲区中取数据的是 %d 还是 %c 或者是 gets()、fgets()。所以为了避免忘记吸收回车或耗费精力考虑回车的问题，习惯上 scanf 后面都加上 getchar()。 

#### fflush（stdin）

前面介绍了使用 getchar() 吸收回车的方法，除此之外还有一个更强大、更直接的方法，就是直接将输入缓冲区全部清空。
清空缓冲区只需加一句 fflush(stdin) 即可。fflush 是包含在文件 stdio.h 中的函数。stdin 是“标准输入”的意思。std 即 standard（标准），in 即 input（输入），合起来就是标准输入。

 fflush 一般用于清除用户前面遗留的垃圾数据，提高代码的健壮性。因为如果是自己编程的话，一般都会按要求输入。但对于用户而言，难免会有一些误操作，多输入了一些其他没有用的字符，如果程序中不对此进行处理的话可能会导致程序瘫痪。所以编程时一定要考虑到各种情况，提高代码的健壮性和容错性。使用 fflush 就可以将用户输入的垃圾数据全部清除。

但是 fflush 有一个问题，就是可移植性。并不是所有的编译器都支持 fflush，比如 gcc 就不支持。那么此时怎么办？还是用 getchar（）。 

#### getchar()的高级用法

while (getchar() != '\n');

这种用法其实在前面也使用过，它可以完全代替 fflush(stdion) 来清空缓冲区。不管用户输入多少个没用的字符，他最后都得按回车，而且只能按一次。只要他按回车那么回车之前的字符就都会被 getchar() 取出来。只要 getchar() 取出来的不是回车 ('\n') 那么就会一直取，直到将用户输入的垃圾字符全部取完为止。

### ASCII-1

**那么ASCII码中的-1表示什么含义呢？**
百度“ASCII码值-1什么含义”并没有答案，我发现这个字符出现的位置是文件结尾，我想到EOF字符，这次百度给出了答案，**在C标准库中，像getchar这样的数据读取函数返回一个与符号（宏）EOF相等的值来指明文件结束的情况发生，EOF的真实值与不同的平台有关（但通常是-1，比如在glibc中），并且不等于任何有效的字符代码。块读取函数返回读取的字节数，如果它小于要求读取的字节数，就会出现一个文件结束符。**

**我的理解是：ASCII码的值确实是非负的，但是在C/C++标准库中，宏定义#define EOF -1，用在读文件的时候（如fscanf、fgetc、fgets等），因为字符的值（ASCII码值）一定非负，C/C++语言采用这种方式标记文件的结尾。**

### 表达式必须是不可修改的左值：

什么是左值？

首先需要明白什么是表达式:

表达式由一个或多个操作数通过操作符组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。

什么是左值： 

不严谨的说法是，左值右值的区分在于位于等号的那一侧，左侧的是左值，通常是一个变量，右侧的是右值，可以是一个变量，或者是一个表达式。

C++ 中存在两种表达式：左值可以出现在赋值语句的左边或右边。右值只能出现在赋值的右边，不能出现在赋值语句的左边。 

a<b?a:b 是一个表达式，返回的是a的值或者b的值，并不是一个变量，常数不是变量（变量：一段连续内存空间的别名），所以10不能赋值给一个常数（常数是恒定不变的，一切常数、字符和字符串都是右值），没有存储结果的空间，也就不能赋值；

将代码修改一下：



＊( a < b ? &a : &b ) = 10;  这样表达式返回的是一个*(a的地址或者b的地址) 相当于*p；再通过*取地址，操作地址所指向的内存空间进行间接赋值

左值在编译时可知，左值表示存储结果的地方，所以简单理解，左值就是必须有存储结果的地方，有内存空间；至于C++可以运行成功是因为C++编译器已经优化过，表达事返回的并不是a的内容(b的内容) ，而是一个变量 ；

特别是操作符重载时，进行链式编程时：

### 指针

int* a;//a是指向整形的指针；
int* a[5];//一维指针数组（这里存放着5个指向整形的指针），a指向第一个元素的地址，a+1指向第二个......（a[5]是一个指针数组）；
int (*a)[5];//指向数组（这里每个一维数组含5个元素）的指针，a是第一个一维数组的首元素地址,a+1指向第二个一维数组的首元素地址......（a是数组指针）；
int (*a)();//a是指向函数的指针（函数指针）；
int *a();//函数的返回类型是int *,a只是一个函数名;

 头文件 #include<stdlib.h>

> 一、rand()
>
> rand()函数用来产生随机数，但是，rand()的内部实现是用线性同余法实现的，是**伪随机数**，由于周期较长，因此在一定范围内可以看成是随机的。
>
> rand()会返回一个范围在0到RAND_MAX（至少是32767）之间的伪随机数（整数）。
>
> 在调用rand()函数之前，可以使用srand()函数设置随机数种子，如果没有设置随机数种子，rand()函数在调用时，自动设计随机数种子为1。随机种子相同，每次产生的随机数也会相同。
>
> rand()函数需要的头文件是：<stdlib.h>
>
> rand()函数原型：int rand(void);
>
> 使用rand()函数产生1-100以内的随机整数：**int number1 = rand() % 100+1;**
>
> 二、srand()
>
> srand()函数需要的头文件仍然是：<stdlib.h>
>
> srand()函数原型：void srand (usigned int seed);
>
> srand()用来设置rand()产生随机数时的随机数种子。参数seed是整数，通常可以利用time(0)或geypid(0)的返回值作为seed。
>
> 使用rand()和srand()产生1-100以内的随机整数:
>
>   srand(time(0));
>
>   int number1 = rand() % 100+1;
>
> 三、使用rand()和srand()产生指定范围内的随机整数的方法
>
> “模除+加法”的方法
>
> 因为，对于任意数，0<=rand()%(n-m+1)<=n-m
>
> 因此，0+m<=rand()%(n-m+1)+m<=n-m+m
>
> 因此，如要产生[m,n]范围内的随机数num，可用：
>
> int num=rand()%(n-m+1)+m;
>
> 其中的rand()%(n-m+1)+m算是一个公式，记录一下方便以后查阅。
>
> 比如产生10~30的随机整数：
>
> srand(time(0));
>
> int a = rand() % (21)+10;

rand函数，C语言中用来产生一个随机数的函数。

rand函数界限：stdlib.h头文件中有宏\*\*#define RAND_MAX 0x7fff

​             rand产生一个0-0x7fff的随机数，即最大是32767的一个数


rand函数原型\**

#include \**

int rand(void);\**

rand函数调用\**

- rand()函数每次调用前都会查询是否调用过srand(seed)，是否给seed设定了一个值，如果有那么它会自动调用srand(seed)一次来初始化它的起始值\**
- 若之前没有调用srand（seed），那么系统会自动给seed赋初始值，即srand（1）自动调用它一次\**

srand函数\**

srand函数是随机数发生器的初始化函数，原型：
void srand(unsigned int seed);\**

- 这个函数需要提供一个种子，如srand（1），用1来初始化种子\**
- rand（）产生随机数时，如果用srand（seed）播下种子之后，一旦种子相同（下面的getpid方法），产生的随机数将是相同的。当然很多时候刻意让rand（）产生的随机数随机化，用时间作种子 srand（time（NULL）），这样每次运行程序的时间肯定是不相同的，产生的随机数肯定就不一样了。\**

- 我们常常使用系统时间来初始化，使用time函数来获取系统时间，得到的值是一个时间戳，即从1970年1月1日0点到现在时间的秒数，然后将得到的time_t类型数据转化为(unsigned int)的数，然后再传给srand函数，用法如下：\**
  - srand((unsigned int)time(NULL));//我们在使用rand和srand时，主要使用的就是这一种初始化方法！
  - 如果仍然觉得时间间隔太小，可以在(unsigned)time(0)或者(unsigned)time(NULL)后面乘上某个合适的整数。 例如,srand((unsigned)time(NULL)\*10)
  - time的参数传NULL表示不需要经过参数获得到的time_t数据，time函数原型如下

time_t time(time_t \*tloc);//time_t类型被定义为一个长整型

- 还有另外一种初始化种子的方式如下，用进程的pid作为种子值seed，在同一个程序中，这样的种子的值是相同的
  - srand((unsigned int)getpid())

rand函数的使用

- 如果想要表示一个数是从0开始到最大值的，比如说，想要产生一个0-99之间的随机数，那么用法如下

int num = rand() % 100；

- 如果想要产生一个数是从1开始到最大值的，比如说，想要产生一个1-100之间的随机数，那么用法如下

int num = rand() % 100 + 1;

- 需要注意最后+1和不+1的区别，+1的最小值是1，不+1的最小值是0

## C++

### 1.关于set

C++ STL 之所以得到广泛的赞誉，也被很多人使用，不只是提供了像vector, string, list等方便的容器，更重要的是STL封装了许多复杂的数据结构算法和大量常用数据结构操作。vector封装数组，list封装了链表，map和set封装了二叉树等，在封装这些数据结构的时候，STL按照程序员的使用习惯，以成员函数方式提供的常用操作，如：插入、排序、删除、查找等。让用户在STL使用过程中，并不会感到陌生。

关于set，必须说明的是set关联式容器。set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。应该注意的是set中数元素的值不能直接被改变。C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树，所以被STL选择作为了关联容器的内部结构。

 关于set有下面几个问题：

（1）为何map和set的插入删除效率比用其他序列容器高？

大部分人说，很简单，因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：


　 A
　 / \
　 B C
　/ \ / \
 D E F G

因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。

（2）为何每次insert之后，以前保存的iterator不会失效？

iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：**不要使用过期的iterator**。

（3）当数据元素增多时，set的插入和搜索速度变化如何？

如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。

### 2.set中常用的方法

### begin()

### end()

### clear()

### empty()

### max_size()

### size()

### rbegin()

### rend()


**begin()   　　 ,返回set容器的第一个元素**
**end() 　　　　 ,返回set容器的最后一个元素**
**clear()  　　   ,删除set容器中的所有的元素**
**empty() 　　　,判断set容器是否为空**
**max_size() 　 ,返回set容器可能包含的元素最大个数**
**size() 　　　　 ,返回当前set容器中的元素个数**
**rbegin　　　　 ,返回的值和end()相同**
**rend()　　　　 ,返回的值和rbegin()相同**

在C++中，setw(int n)用来控制输出间隔。
例如:
cout<<‘s’<<setw(8)<<‘a’<<endl;
则在屏幕显示
s a
//s与a之间有7个空格，setw()只对其后面紧跟的输出产生作用，如上例中，表示’a’共占8个位置，不足的用空格填充。若输入的内容超过setw()设置的长度，则按实际长度输出。
setw()默认填充的内容为空格，可以setfill()配合使用设置其他字符填充。
如
cout<<setfill(’*’)<<setw(5)<<‘a’<<endl;
则输出：
****a //4个*和字符a共占5个位置。

所谓域宽，就是输出的内容（数值或字符等等）需要占据多少个字符的位置，如果位置有空余则会自动补足。比如我们要设置域宽为2，那么当输出一位数1的时候输出的就是“ 1”，即在1前面加了一个空格。空格和数字1正好一共占用了两个字符的位置。

我 们在设置域宽和填充字符的时候要注意几点：①设置域宽的时候应该填入整数，设置填充字符的时候应该填入字符。②我们可以对一个要输出的内容同时设置域宽和 填充字符，但是设置好的属性仅对下一个输出的内容有效，之后的输出要再次设置。即 cout <<setw(2) <<a <<b;语句中域宽设置仅对a有效，对b无效。③setw和setfill 被称为输出控制符，使用时需要在程序开头写上#include “iomanip.h”，否则无法使用。

setw(n) 设域宽为n个字符 iomanip.h iomanip.h是I/O流控制头文件,就像C里面的格式化输出一样。

## 数学

斜边是指直角三角形中最长的那条边

## 正则

 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 

.”出现在字符组中时，就不是元字符了，就表示点号本身。在字符组中的“-”只有两边是合法的字符区间是，才表示一个字符序列，例如“a-z”这样。你这个表达式应该就是能匹配点号或减号，没别的特别。还有，正则表达式在不同的运行环境中有细微差别。“()”在大多数情况下是元字符，表示捕获匹配，但在vim中，两边括号都要转义，“\(\)”这样才表示捕获。在[]里面是没有元字符的，都代表本身的含义，例如[.]就表示匹配一个点.的意思。

 \+ 号代表前面的字符必须至少出现一次（1次或多次） 

 \* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）

 ? 问号代表前面的字符最多只可以出现一次（0次、或1次） 

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

| 字符   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| [ABC]  | 匹配 **[...]** 中的所有字符，例如 **[aeiou]** 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。![img](笔记.assets/E691DDE1-E5CB-4EA8-8D16-759BD0D2B09D.jpg) |
| [^ABC] | 匹配除了 **[...]** 中字符的所有字符，例如 **[^aeiou]** 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字母。![img](笔记.assets/ED971D92-30F4-4768-A2C7-02A84A3A9DEB.jpg) |
| [A-Z]  | [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。![img](笔记.assets/C5E357BD-65E3-4EB3-9D80-10D096F19287.jpg) |
| .      | 匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。![img](笔记.assets/0FD7E77D-38A7-43BC-B51A-7DBA23A77756.jpg) |
| [\s\S] | 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，包括换行。![img](笔记.assets/47CA6C59-64CF-433A-909E-1E342349A4E0.jpg) |
| \w     | 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]![img](笔记.assets/F35A5971-3519-4CAE-8BEC-9DE8F4A55257.jpg) |

------

### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n   | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r   | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t   | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v   | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |

------

\d 数字 \w下划线

### 特殊字符

所谓特殊字符，就是一些有特殊含义的字符，如上面说的 **runoo\*b** 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 **\**: **runo\*ob** 匹配 runo*ob。

许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符**\** 放在它们前面。下表列出了正则表达式中的特殊字符：

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *        | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。     |
| +        | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| .        | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。    |
| [        | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。            |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {        | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
| \|       | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

------

### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

正则表达式的限定符有：

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

以下正则表达式匹配一个正整数，**[1-9]**设置第一个数字不是 0，**[0-9]\*** 表示任意多个数字

 限定符出现在范围表达式之后。因此，它应用于整个范围表达式 

```
如果你想设置 0~99 的两位数，可以使用下面的表达式来至少指定一位但至多两位数字。
/[0-9]{1,2}/
上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。

改进下，匹配 1~99 的正整数表达式如下：
/[1-9][0-9]?/
或

/[1-9][0-9]{0,1}/
```

 *和 *+* 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配** 

**贪婪：**下面的表达式匹配从开始小于符号 (<) 到关闭 h1 标记的大于符号 (>) 之间的所有内容。

```
/<.*>/
```

### 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，**^** 和 **$** 分别指字符串的开始与结束，**\b** 描述单词的前或后边界，**\B** 表示非单词边界。

正则表达式的定位符有：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

**注意**：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。

若要匹配一行文本开始处的文本，请在正则表达式的开始使用 **^** 字符。不要将 **^** 的这种用法与中括号表达式内的用法混淆。

若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 **$** 字符。

## JAVA

接口不可以实例化。但是接口对象可以指向它的实现类对象。java8之后，default关键字定义的方法可以实现方法体；另外，被static修饰的方法也可以实现方法体，调用方式和类中的静态方法完全一样。
nextInt():它只读取int值，nextInt()将光标放在读取输入后的同一行。next():只读取输入，直到空格。它不能读两个由空格隔开的单词。同样，next()在读取输入后将光标放在相同的行中。nextLine():读取输入，包括单词之间的空格(也就是说，它读取到行\n的末尾)。读取输入后，nextLine()将光标置于下一行。
①包名所有字母一律小写，例如cn. itcast. testo

②类名和接口名每个单词的首字母都要大写，例如 ArrayList、 terator

③常量名所有字母都大写，单词之间用下划线连接，例如 DAY OF MONTH

④变量名和方法名的第一个单词首字母小写，从第二个单词开始每个单词首字母大写，例如 lineNumber、 getLineNumbero。

⑤在程序中，应该尽量使用有意义的英文单词来定义标识符，使得程序便于阅读。

例如使用 userName表示用户名， pass Word表示密码。

迭代，重复反馈过程的活动，目的通常是接近或达到所需目标，对每一次过程的重复

### 窗口

JFrame的关闭可bai以使用这个方法进行关闭：setDefaultCloseOperation(int operation);
其中operation有以下几du种zhi
DO_NOTHING_ON_CLOSE(在 WindowConstants 中定义):不执行任何操作;要求程序在已注册dao的 WindowListener 对象的 windowClosing 方法中处理该操作。
HIDE_ON_CLOSE(在 WindowConstants 中定义):调用任意已注册的 WindowListener 对象后自动隐藏该窗体。
DISPOSE_ON_CLOSE(在 WindowConstants 中定义):调用任意已注册 WindowListener 的对象后自动隐藏并释放该窗体。
EXIT_ON_CLOSE(在 JFrame 中定义):使用 System exit 方法退出应用程序。仅在应用程序中使用。
默认情况下，该值被设置为 HIDE_ON_CLOSE。更改此属性的值将导致激发属性更改事件，其属性名称为 "defaultCloseOperation"。

## 存储

1、Float：比特数为32，有效数字为6-7，数值范围为-3.4*10(-38)～3.4*10(38)；
2、Double：比特数为64，有效数字为15-16，数值范围为-1.7*10(-308)～1.7*10(308)；
3、long double：比特数为128，有效数字为18-19，数值范围为-1.2*10(-4932)～1.2*10(4932)。
float和double的范围是由指数的位数来决定的。 float的指数位有8位，而double的指数位有11位，分布如下： float： 1bit（符号位） 8bits（指数位） 23bits（尾数位） double： 1bit（符号位） 11bits（指数位） 52bits（尾数位） 于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。 其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。 float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。 

### 浮点数的表示

浮点数如何在计算机中表示  (2011-08-30 21:08:21)
转载
▼

标签： 浮点数 尾数 单精度 二进制数 小数点 
分类： 电脑相关 
    根据IEEE 754标准，浮点数的表示形式如下：

    其中，S为数的符号位，为0时表示正数，为1时表示负数；P为阶码，通常用移码表示；M为尾数，用原码表示。目前，计算机中主要使用三种形式的IEEE 754浮点数，如下表所示
    
    在IEEE 754标准中，约定小数点左边隐含有一位，通常这位数就是1，因此单精度浮点数尾数的有效位数为24位，即尾数为1.xx...x。
  下面利用IEEE 754标准将数176.0625表示为单精度浮点数：
第一步，将176.0625表示为二进制数，即(176.0625)10 = (10110000.0001)2
 1. 整数转化为二进制
      176/2=88...0（余数）
      88/2 =44...0
      44/2 =22...0
      22/2 =11...0
      11/2 =5 ...1
      5/2  =2 ...1
      2/2  =1 ...0
      1/2  =0 ...1
    将余数按从下往上的顺序书写就是：10110000
 2.小数部分转化为二进制
      0.0625*2=0.125...0（整数）
      0.125*2 =0.25 ...0
      0.25*2  =0.5  ...0
      0.5*2   =1.0  ...1
    将整数按从上往下的顺序书写就是：0001
第二步，对二进制数进行规格化处理，即10110000.0001 = 1*01100000001x2^7（*为小数点所在位置，在计算
        机中只取小数点后面的位存入尾数区）
第三步，将最高位去掉，并扩展为单精度浮点数所规定的23位尾数，得到尾数01100000001000000000000
第四步，求阶码，上述表示中指数为7（即第二步中的7），用移码表示为10000110（7+127=134，127为偏移量）
第五步，将符号位、阶码与尾数合并起来，最终得到176.0625的表示形式
         0 10000110 01100000001000000000000（其中空格是为了方

## PS快捷键

ufvwgphcwalybabc
回车  确定 
ctrl + z  小步退回
ctrl + alt + z  连续撤销 ctrl + shit +z 取消撤销
ctrl + t 自由变换 调节图像大小 （alt 按住 以中心点缩放）
蒙版   （只有黑白色）黑透白不透 黑遮白显黑 方便还原 换前景颜色可以还原
黑遮白显注：左右括号【】是调节画笔大小 也可以在图层中使用画笔的时候按下右键调整大小和硬度等信息
ctrl+ j 复制图层（也可以使用图层上右键选择）
ctrl + m 曲线（光暗对比度 上曲线调节亮 下曲线调节暗）
ctrl + b 色彩平衡
ctrl + g  专门针对一个图片 （alt 同时鼠标点击）
右下角点击校色按钮 方便还原
按住alt键 转化点工具  变换类型 （在钢笔工具中可以针对点 也可针对滑竿）
ctrl 键 直接选择工具   变换位置
剪影是一起按住ctrl alt 再鼠标左键移动图片
alt 修复画笔选定
ctrl + d 修补工具的选区相容覆盖（不会有非常生硬的边界）
按住字体前面的两个T按住鼠标左键不送一直向右拖可以放大字体

## 剪切板

​      单击“开始”，单击“运行”，然后键入 “clipbrd”命令即可启动“剪贴薄查看器”小工具。内容会随着用户执行的“复制”操作而即时更换。总之，它显示的总是当前系统剪切板中的内容。如果想清除当前剪切板中的内容，只要单击“编辑—删除”命令即可。当然，还可以通过菜单的“文件—另存为”将当前剪贴板中的内容以文件的形式保存到影片中，以便日后查看。
​      剪切板是指windows 操作系统提供的一个暂存数据，并且提供共享的一个模块。也称为数据中转站，剪切板在后台起作用，在内存里.，是操作系统设置的一段存储区域，是在硬盘里找不到的.你只要有文本输入的地方按CRTL+V或右键粘贴就出现了，.新的内容送到剪切板后，将覆盖旧内容。
六级通行证ID:E96D504434DA49DA924777BFC32B37F8 

## Linux

进入windows的微软商店下载的ubuntu系统在cmd界面输入：    wsl   即可

linux中查找文bai件位置的命du令有很多，常用的有zhifind，locate和whereis三个dao命令内，下面分别介绍它们容的用法：

1、find命令是linux中最强大的查找文件的命令，它的格式为”find <指定目录> <指定条件> <指定动作>“。比如使用find命令搜索在根目录下的所有interfaces文件所在位置，命令格式为”find / -name  'interfaces'”，输入后就会返回搜索的结果了：

[![img](笔记.assets/d52a2834349b033b5f8a8a471bce36d3d539bd28.png)](https://iknow-pic.cdn.bcebos.com/d52a2834349b033b5f8a8a471bce36d3d539bd28)

2、第二个命令是locate命令，使用locate也可以搜索到linux系统中的文件，同样的这里使用locate命令搜索interfaces文件，命令为”locate interfaces“，locate命令是比find命令快的，因为它查询的是locatedb数据库，该数据库包含本地所有的文件信息：

[![img](笔记.assets/d52a2834349b033bb2ae97471bce36d3d539bd0d.png)](https://iknow-pic.cdn.bcebos.com/d52a2834349b033bb2ae97471bce36d3d539bd0d)

3、最后一个是使用”whereis“命令搜索文件，但是只可以搜索linux系统中的可执行文件。这里用whereis搜索interfaces文件就不起作用了，所以使用whereis命令搜索grep的可执行文件，其命令为”whereis grep“。以上就是linux中查找文件的命令的用法介绍：

[![img](笔记.assets/63d0f703918fa0ecd9850190289759ee3c6ddbe9.png)](https://iknow-pic.cdn.bcebos.com/63d0f703918fa0ecd9850190289759ee3c6ddbe9)

## 汇编

在虚拟dos下编译文件  必须在masm  link 程序在的地方执行masm link指令否则找不到执行程序

操作某个文件夹下的文件可以用相对路径  如 masm huibian\1\ex1.asm   用斜杠\

8个8位的寄存器(AL、AH; BL、BH;CL,CH;DL、DH)来使用。

其中AX称为累加器,BX称为基址寄存器,CX称为计数寄存器,DX称为数据寄存器

cmd下    type 文件  查看文件内容

debug里   （-u  偏移地址  偏移地址|长度|省略默认反汇编128字节）来反汇编

cx 存放源程序长度  单位字节

cmd下  notepad 文件    来编辑文件   也可以debug自带的编辑器   exit  文件  alt  tab 键来切换菜单  alt加enter保存  加x退出

masm  文件.asm；（用;结束表示不想生成中间文件）

link   文件.obj；

可以写在批处理文件里来一次执行此流程

asm文件里   内存单元立即数写在文件里 如：

mov  ax,[0]

反汇编时就是 mov ax,0

但是在debug里写反汇编后正常

解决：加段前缀或者寄存机间接寻址来解决

### masm报错

out of memory:

 一般是你的程序越界或者溢出了
请用EDIT打开那个文件，看是否其中有非ASCII的字符（分号后的除外），很多时候是将分号写成了中文下的分号了，改成英文下的分号就可以了，再看看程序。
一般这是声明指针类型的变量,使用完后没有关闭,或者有死循环什么的.原因很多,但仔细review一下你自己的source,应该能发现里面的逻辑问题.   甚至于编码不一致时多一个空格都不行  edit 编辑可看出来  其他编辑器很难

debug程序win10没有win7 的32位机(masm可能在环境变量里可以直接执行)才有所以开启debug程序以masm为虚拟盘  这个虚拟的系统里masm不在环境变量里  masm时要再masm的文件夹同目录下执行  masm 文件的url(路径分隔符用\)生成的文件也在masm.exe的同路径下

test.asm(46): error A2105: Expected: instruction ordirective

说明：通常是指令助记符输入错误。

修改：检查指令助记符。

1.  mov ax,ds:[0]

2. mov  dx,0;

   mov   ax,[dx];

   ;.....相当于注释

### 汇编时发现有些内存单元改写后数值不同

 用g命令直接调试的结果 

 ![img](笔记.assets/]{I20EDKC}9{OSZ9GXIY1.jpg) 

 既有屏幕滚动刷新的原因，也有单步调试本身中断机制的处理原因。
深究起来，可能还是和屏幕显示区域对应的缓存区域使用处理方式有关联 
改一下汇编程序就行
把数值存到界面下面几行对应的字节
只要大于输入g命令后控制台多出来的行数   dosbox调用不了集显，得开独显才行。 

 由b800:0 开始是所谓文字模式的 [显存地址] 当你输入 e b810:0 1 2 3 2 1 实际上是在显存上放资料,大约在第一列 输入完按一下 [回车], 屏幕 [上卷] 一列,完来的资料已经被下一列(第2列上卷到第1)覆盖了. 要避免上卷,可以不按回车,把所有输入预先存成一个文件,就像下面三句,用记事本储存成纯文字档b800.txt 然后键入 debug < b800.txt debug会读入b800.txt, 按照上面的资料运行,这样就可以不用上卷而看到修改的资料

如图. -- b800.txt的三行资料 --------- e b800:0 31 06 32 07 41 02 d b800:0 f q  

![1604069167068](笔记.assets/1604069167068.png)

利用栈的特性，综合使用loop，push实现（限定仅使用8086中已学过指令实现），编

写源程序  实现向内存写数据

- 编写汇编源程序：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
;ex41.asm
assume cs:code
code segment
　　mov ax,0020h
　　mov ss,ax
　　mov sp,0040h
　　mov ax,3f00h
　　mov cx,64
s: 　push ax
　　inc sp
　　dec ah
　　loop s
　　mov ax,4c00h
　　int 21h
code ends
end
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

- 灵活使用debug的t命令、g命令、p命令调试。用d命令查看

  0:200~0:23F，确认是否将0~3F传送至此段内存区域。

![img](笔记.assets/2175481-20201103232000581-575599395.png)

![img](笔记.assets/2175481-20201103232747967-20469575.png)

　　（1）、注意事项：

　　　　　　通过文本编辑器编写程序，程序中的十六进制数需要带上h，否则再执行过程中会被当成十进制数。

　　　　　　通过文本编辑器编写程序，需要使用内存单元时不能直接使用“[偏移量]“的形式，需要通过寄存器来传递偏移量：[寄存器]

　　　　　　编译、连接、调试文件后缀名问题：编译和连接时可以不带文件的后缀名，但是在使用debug命令调试时需要带上文件后缀名，*否则执行报错*

​    （2）、可将程序分为两部分：伪指令和可执行代码段

　　　　assume cs : 段名   　　　　　　　（伪指令：将作用代码段和CUP中的段地址寄存器cs联系起来【如实验中使用的code只是一个标号】）

　　　　　　段名 segment　　　　　　　　（伪指令：段开始【和code ends 成对使用】）

　　　　　　　　可执行代码段***......***

　　　　　　段名 ends　　　　　　　　　（伪指令：段结束

　　　　end　　　　　　　　　　　　　　（伪指令：汇编程序结束的标记）

　　　　可执行代码段中包括程序的返回：mov ax, 4c00H   int 21H (由这两条指令实现程序的返回功能)

### debug

1.debug简介
（1）功能
（2）三种模式
	实模式
	保护模式
	虚拟8086模式
2.debug环境说明
（1）默认16进制
（2）不区分大小写
3.操作演示
（1）启动和退出
	32位win7及以前版本
	64位win7及以上版本/mac os/linux
（2）常用debug命令演示
	查看、修改寄存器  r命令
	查看内存单元 d命令
	修改内存单元 e命令
	编写汇编指令 a命令
	调试汇编指令 t   p  g  命令
	反汇编  u命令
	帮助   ?
教材实验1、2提示和说明



-cls 清屏  cl
-q退出
-mount f d:/masm命令 把文件映射为虚拟盘符
-debug 进行调试  查看修改 寄存器（r） 内存单元 (d e) dump e修改  编写a调试t p g汇编指令 -u反汇编
alt+回车  全屏
-r 查看修改寄存器  什么都不带 查看所有寄存器值
    cs  ip ss sp寄存器 ds，cs，ss都是汇编中的段寄存器而ip状态与控制寄存器，sp为索引寄存器，cs与ip搭配使用，ss与sp搭配使用：
    ds (Data Segment) 数据段寄存器  注：不能直接把数据送入到ds寄存器，因此需要先把数据送入一个通用寄存器再送入数据段寄存器
    cs（代码段寄存器）与ip（指令指针寄存器）cs(Code Segment)是用于存放我们指令所在的段地址
ip (Instruction Pointer)寄存器是用于存放指令所在的地址的偏移地址    因为8086CPU是16位的，但是物理地址是20位的，它内存的寄存器只能表现16位的地址，因此使用了ip寄存器来存放偏移地址
    ss（栈寄存器）与sp（栈指针寄存器）ss (Stack Segment)：用于存放栈顶的段地址
sp(Stack Pointer)：用于栈顶的偏移地址  入栈与出栈都是按一个寄存器即一个字（两个字节）来入栈或出栈的（8086是16位的结构）
    最后面标志寄存器其中的八个比特位

**不特别指定段地址  u、g、e偏移地址都是默认段地址为cs     内存操作[]默认段地址为ds---- 两者可以特别指定**cx里存放程序的总长度(字节)  

-r cs 等 修改寄存器
073F：0100 0000  （ADD的机器码）  ADD 。。。
-d查看内存单元  不指定 以当前cs ip地址为起始地址默认显示128个字节 8行  一行16字节
指定范围0:200  0203  指定长度 0:200 L5  右边显示ascii码值  不可显示显示...
-e 0:200  31 32 ‘a’'b’“cd”  16进制（H） 
31ascii是1  ‘a’是61  “cd”写两个字节的数据  连续修改若干个  -e  0:200 b8 20 4e 05 16 14 写入机器指令
-e 0:200  依次修改
0000:0200  31._（输入修改的字符）32._  不改则回车
-a 不带地址  默认当前cs ip地址开始写指令  -a 0:200 指定逻辑地址开始写汇编指令代码 不能直接用t命令
-t单步执行trace单步跟踪  默认从当前cs ip 开始执行  要么指定t执行地址  **t=0:200**指定地址开始单步跟踪 要么修改cs ip

<img src="笔记.assets/debug t a-1602669785737.png" alt="debug t a" style="zoom: 80%;" />



 ![img](笔记.assets/2175412-20201011183336105-794403817.png) 

-p单步执行（-t）把中断子程序当成一个指令执行 相当于不进入函数执行
-g g  0106从当前cs ip 地址开始执行 一直到0106偏移地址之前的指令不包括自己
-u -e  0:200 b8 20 4e 05 16 14 写入机器指令  -u 0:200 （到021f可能不显示021f 因为021e占两个字节可能）

-u 要指定反汇编的起始位置  默认显示32个字节显示汇编代码  0:200 L6 长度  0:200 205 范围   -u  默认cs ip 为起始地址连续反汇编32个字节
如果访问到内存   最后会显示例如：前面涉及[0000]        最后有DS:0000=0000 字长  为要访问的内存单元的内容

*1. 用t命令执行指令前需要注意CS:IP是否指向了之后需要执行的命令的地址。*

2.8086采用小端存储模式，高地址存储高位,低地址存储低位。

3.不同的计算机系统的内存地址空间的分配情况是不同的，以8086PC机内存地址空间分配为例，A0000~BFFFF为显存地址空间CPU向内存单元地址写入数据，这个数据就会通过显卡显示到屏幕上。

4.debug程序中默认的进制是16进制，所以输入数据不需要加H，我们发现自己的程序不能出现想要的结果时可以看看是不是自己进制没有加以转换。

 ![img](笔记.assets/2175600-20201014174556296-1249926609.png) 

 ![img](笔记.assets/2175600-20201014174605328-206077781.png) 

```
mov ax,2000：将数据2000写入寄存器ax中
mov ss,ax：设置栈的段地址
mov sp,10：设置栈顶的偏移地址，SP=0010H
```

指令mov sp,10表示初始化栈指针寄存器。SS:SP（2000:0010）记录栈顶元素。

初始时栈顶为2000：0010；栈底为2000：000F；  栈顶不设置为0000默认数据入栈后sp-2 为fffe

设置栈顶位置后栈会存储cs,ip和ax等的内容。通过搜索得知，与中断机制有关。mov ss,ax执行后，mov sp,10立即执行，然后靠近栈顶的16个字节发生变化，对部分环境变量，如ss,ip,cs进行暂存,以保护现场。

![IMG_0821](笔记.assets/IMG_0821.JPG)

![IMG_0822](笔记.assets/IMG_0822.JPG)

![IMG_0823](笔记.assets/IMG_0823.JPG)

![IMG_0824](笔记.assets/IMG_0824.JPG)

 ① 物理地址20000H单元存放的字数据，占据两个字节。Intel采用小端法，所以是存放在地址编号为20000H和20001H两个字节。② 查看某个内存单元，debug中使用d命令。③ 物理地址20000H要表示成「段地址：偏移地址」的形式，只要满足「段地址」×16 +「偏移地址」=「物理地址」即可。答案选项中三种逻辑地址表示均符合这个条件。④ 这道练习是在教材实验1中P40图2.39练习的基础上，变换了一个物理单元地址。综合考核了以下知识点: 多字节数据在内存中的存放，物理地址与逻辑地址的表示和对应关系，debug工具中d命令的用法。 

 Q2. 在计算机中，多字节数据（例如，字数据，双字数据等）在内存中存放时采用端序法。其中，intel系列采用小端法（little-endian)来存放多字节数据。 

 Q3. 针对8086，设在debug中，使用e命令执行了如下操作： -e 0:210 10 20 30 40 50 60 然后使用a命令写了如下汇编指令： mov ax, 0 mov ds, ax mov ax, [212] 则，三条指令顺序执行完后，寄存器ax的值时是多少？   Q3. 针对8086，设在debug中，使用e命令执行了如下操作： -e 0:210 10 20 30 40 50 60 然后使用a命令写了如下汇编指令： mov ax, 0 mov ds, ax mov ax, [212] 则，三条指令顺序执行完后，寄存器ax的值时是多少？  4030H
答案说明：e命令的操作将10h,20h,30h,40h, 50h, 60h（debug中默认是十六进制）写入从0:200开始的连续6个字节单元。
前两条命令执行后，段地址0被送到了数据段寄存器ds中；第3条指令，表示将数据段中偏移地址为212单元中的字数据取出来送到寄存器ax中。由于8086采用的是小端法，因此，从偏移地址为212单元取出的字数据占据的单元是00212H和00213H两个字节，按照小端法，所以，字数据是4030H。这道练习考核了以下知识点：多字节数据的小端序存放；寄存器ds用法；debug工具中e命令和a命令用法；汇编指令mov用法。 

答案说明：当一段内存空间用作「栈」空间时，数据入栈和出栈这两个基础操作只能通过栈顶。程序员使用汇编语言编程时，通过入栈和出栈指令（如8086中是通过push和pop）访问的是栈顶，而在mov、add等指令中也可以通过偏移地址访问栈中其它单元。想提前了解，请查阅第8章中寄存器BP的用法。（对应地，在32位汇编中是寄存器EBP，在64位汇编中是寄存器RBP） 

当程序员指定一段内存空间用作「栈」时，入栈和出栈只能从栈顶操作。
栈空间中，固定不动的一端称为「栈底」。
栈空间中，「栈顶」会随着数据的入栈和出栈而动态变化。 

 Q5. 关于8086中「栈」空间用法
8086dos汇编中约定「栈」空间的入栈和出栈均以字为单位，而其它有些汇编指令则支持以字节、字、双字等作为入栈和出栈操作的单位。
SS,全称Stack Segment Register,栈段寄存器，用来存放栈段的段地址。
SP,全称Stack Pointer Register,栈指针寄存器，用来存放栈顶的偏移地址。
「SS:SP」构成了栈顶的逻辑地址，据此，通过「(SS)×16+(SP)」可以计算出栈顶的物理地址。 

 设将00200H~002FFH这段内存当作栈来使用，初始栈为空。 以下选项中，正确设置了初始栈顶的是？ （多选，3分）
正确答案：A, B
答案说明：把00200H~002FFH空间用作栈，并且初始栈为空，如画出示意图，可直观看到，初始栈顶应该是地址编号00300H对应的内存单元。
00300H表示成逻辑地址时，「0:300」和「20:100」都是正确的逻辑地址表示形式。因为：
按照「段地址×16+偏移地址=物理地址」的计算约定，二者都满足。
由这道练习也可以看出，从程序员的视角，内存空间的使用是非常灵活的，它依赖于内存空间使用的约定以及程序员的使用设计。（这道练习是基于教材实验2中P72(3)实践内容，变换了数字。考察的是对这个实验内容的理解) 

 答案说明：将内存单元00200H和00201H中的字节数据相加，保存到内存单元00202H。
在写成逻辑地址表示的时候，有很多种写法，选项中，「0:200」 「0:201」 「0:202」是以一种写法，「20:0」 「20:1」 「20:2」是另一种写法。都满足「段地址×16+偏移地址=物理地址」的形式。剩下的，就是对mov和add指令的正确和灵活使用了。 

 Q1. 关于转移指令，以下描述中正确的有？ （多选，5分）
A
转移指令可以控制cpu执行流程，使其执行内存中特定位置的代码。
B
「jmp 标号」是一个转移指令。其跳转原理是，指令的机器码中给出了跳转的位移量。根据位移转移的好处在于，方便程序的浮动装配。链接器在进行重定位时，只需要确定基础地址，其它就可以根据位移量快速实现重定位。从内存空间分配的角度看，这种方式使得内存空间的分配和使用更加灵活。
C
「jmp dword ptr [内存单元]」是一个转移指令。其跳转原理是，指令的机器码中给出了存放有跳转后绝对地址的内存单元的地址。寻址到内存单元，就可以获得跳转后的目标地址。在这种方式下，如果工作在实模式，在多任务系统中，如果不同程序中存在跳转到同一个绝对目标地址的代码，就有可能发生内存空间访问冲突问题。
D
以下代码片段中，如果只是想要实现跳转到标号s处的功能，把line3替换成call s，可以实现同样的目的。





我的回答：A, B, C, D
正确答案：A, B, C, D
答案说明：jmp s和call s都是转移指令，都是跳转到标号s处执行，区别在于，使用call在跳转到标号s之前，会把其后的下一条指令的地址（这里是jmp s的偏移地址）保存到栈中。在这个练习中，如果仅仅是要实现跳转到标号s处执行，那么，二者都可以实现这个要求。
Q2. 已知8086汇编源代码t1.asm如下。以下表述中正确的有？ （多选，5分）

![IMG_1068(笔记.assets/IMG_1068(20201204-141832)-1607267274048.JPG)](../../盘F/消息记录/1361354967/FileRecv/MobileFile/IMG_1068(20201204-141832).JPG)

A
这个程序实现的功能是，把data段定义的字母串中，小写字母转换为大写。
B
代码第12-13行，可以合并写成mov cx, [si]。
C
第15行的功能是，把数据段中通过寄存器si寻址的字节单元中存放的字符转换为大写。
D
第15行可以替换为sub byte ptr [si], 32。
E
第15行可以替换为and byte ptr [si], 0dfh
我的回答：A, C, D, E
正确答案：A, C, E
答案说明：写成mov cx, [si]后，每次从si寻址的内存单元取到的是字数据（两个字节），在意义上不能等同代码line12-13。
由于数据段字母串中，除了小写字母外，也有大写字母，因此，这个示例中，把line15替换成sub byte ptr [si], 32无法实现同等效果。
Q3. 对t1.asm得到的可执行程序t1.exe反汇编截图如下。以下描述中正确的有？ （多选，5分）

![IMG_1069(笔记.assets/IMG_1069(20201204-141838)-1607267286207.JPG)](../../盘F/消息记录/1361354967/FileRecv/MobileFile/IMG_1069(20201204-141838).JPG)

A
反汇编后后，查看(CX)=0029H，说明生成的可执行文件一共占用29H个字节。而使用u命令精确反汇编写成u 0 18，即反汇编19H个字节，是因为，数据段data中的数据占用了另外的16个字节，即10H。
B
指令jcxz在跳转时，是根据相对位移量跳转的。debug截图中，指令jcxz over对应的机器码E306中，06H是跳转的位移，也就是十进制的6。
C
指令jmp change是根据相对位移量跳转的。debug截图中，指令jmp change对应的机器码EBF4中，F4H是跳转的相对位移，也就是十进制的244。
D
从cpu的视角，指令jcxz真正跳转的目标地址是这样计算出来的：指令jcxz over的下一条指令对应的偏移地址000EH，加上指令机器码中给出的位移量06。
E
从cpu的视角，指令jmp change真正跳转的目标地址是这样计算出来的：指令jmp change的下一条指令对应的偏移地址0014H，加上位移量F4。
我的回答：A, C, D, E
正确答案：A, B, D
答案说明：debug截图中，指令jmp change对应的机器码EBF4中，F4H是跳转的位移，位移在机器码中是以补码形式表示的，经过从补码-》源码-》十进制的计算，对应的位移量应当是十进制的-12。据此，jmp change真正跳转的目标地址是这样计算出来的：指令jmp change的下一条指令对应的偏移地址0014H，也就是十进制的20，加上位移量-12，得到8。也就是jmp change执行后最终跳转的目标偏移地址。 

## Python

Anaconda prompt报错

在命令行模式下有时会提示cp65001异常，很显然是命令行编码和python环境编码不匹配。

> 解决

1. 切换命令行编码
   unknown encoding: cp65001异常
   python安装后进入命令行交互模式，输入任何代码都报unknown encoding: cp65001异常

   需要将编码(UTF-8)修改为 简体中文(GBK)
   在CMD窗口执行　chcp 936

2. 切换python默认编码
   LookupError: unknown encoding: cp65001

解决方法：cmd设置 python 的环境变量 PYTHONIOENCODING即可
set PYTHONIOENCODING=utf-8

Anaconda的安装和镜像完成之后，主要有两个任务：

（1）如何配置新的环境。

（2）如何添加第三方库。

**1、设置pip安装镜像源为国内，使用的命令**

阿里云 https://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
豆瓣(douban) http://pypi.douban.com/simple/
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/
中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/

```
pip install 包名 -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
```

**2、conda虚拟环境配置相关命令**

(1) 查看虚拟环境

```
conda env list 或 conda info -e
```

(2) 更新conda：

```
conda update conda
```

(3) 创建python虚拟环境

```
conda create -n your_env_name python=X.X(2.7、3.6等)
```

(4) 激活虚拟环境

```
Linux:  source activate your_env_name(虚拟环境名称)Windows: activate your_env_name(虚拟环境名称)
```

(5) 虚拟环境中安装外包

```
conda install -n your_env_name [package]
```

(6) 关闭虚拟环境

```
Linux: source deactivateWindows: deactivate
```

(7) 删除虚拟环境

```
conda remove -n your_env_name --all
```

(8) 删除环境中的某个包

```
conda remove --name your_env_name package_name
```

(9) conda虚拟环境克隆

```
conda create -n your_new_env_name --clone your_env_name
```

(10) 下载包到指定目录

```
pip download psycopg2 -d D:\MyDownload\ -i https://mirrors.aliyun.com/pypi/simple/psycopg2包名，-d指定路径，-i指定源
```

(11) anaconda查找包，并安装

```
ananconda search -t conda conda包名  #查找安装的包
```

![img](笔记.assets/20200706225834698.png)

```
anaconda show 网名/包名  #show的时候会在最后显示安装的命令
```

![img](笔记.assets/20200706230254950.png)

```
conda install --channel https://conda.anaconda.org/menpo cyvlfeat #安装包
```

1、配置新的环境

conda create -n envs_name python=3.5

上面的句子，envs_name 是自己设定的。执行这个命令可以将其python配置为3.5版本。

完成安装之后，激活：conda activate envs_name。就可以进入这个环境了。

退出环境：conda deactivate。

2、添加第三方库

2.1 临时使用pypi镜像下载第三方库：

```
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package
```

some-package是要安装的包。

2.2 永久修改pip的镜像源（推荐）：

先升级pip再配置：

```
pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
```

如果您到 pip 默认源的网络连接较差，先使用临时镜像来升级 pip：

```
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip --upgrade pip
```

永久修改默认镜像之后，再安装自己的第三方库，只需要：pip install some-package，some-package即要安装的库。

 换源吧：
  阿里云 http://mirrors.aliyun.com/pypi/simple/ 
  中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 
  豆瓣(douban) http://pypi.douban.com/simple/ 
  清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 
  中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 

Anaconda prompt下输入Python，就可以写Python代码啦。

多个环境的创建：这里注意一下，一定要退出Python编辑环境，才能运行下面的代码。

```
conda create -- name xxx python = 2 # xxx为环境名称，创建了python版本为2的环境
conda create -- name xxx python = 3 # 创建了python版本为3的环境
conda create -- name xxx python = 3 anaconda # 创建了python版本为3的环境,并具有anaconda的所有包conda info -- envs # 查看环境
activate xxx # 激活环境
deactivate xxx # 退出环境
conda remove -- name xxx -- all # 删除一个已有的环境
```

包的安装和卸载：

```
conda install xxx # xxx为包名称
conda remove xxx # 卸载包
pip install xxx
pip uninstall xxx
```

## [vscode创建python编译环境（launch.json和setting.json）](https://www.cnblogs.com/lizi122/p/13065762.html)

a. .vscode下launch.json文件

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
{
    "version": "0.2.0",
    "configurations": [
        {
            //配置名称，将会在启动配置的下拉菜单中显示
            "name": "Python",
            //配置类型
            "type": "python",
            //请求配置类型，可以为launch（启动）或attach（附加）
            //launch: VSCode 会打开这个程序然后进入调试
            //attach:你已经打开了程序，然后接通内部调试协议进行调试
            "request": "launch",
            "stopOnEntry": false,
            "pythonPath": "C:\\Users\\Liz\\AppData\\Local\\Programs\\Python\\Python38\\python.exe",
            //将要进行调试的程序的路径
            "program": "${file}",
            //调试程序时的工作目录，一般为${workspaceRoot}即代码所在目录
            "cwd": "${workspaceRoot}",
            "env": {},
            "envFile": "${workspaceRoot}/.env",
            "debugOptions": [
                "WaitOnAbnormalExit",
                "WaitOnNormalExit",
                "RedirectOutput"
            ]
        }
    ]
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

预定义变量

${workspaceFolder} - 当前工作目录(根目录)

${workspaceFolderBasename} - 当前文件的父目录

${file} - 当前打开的文件名(完整路径)

${relativeFile} - 当前根目录到当前打开文件的相对路径(包括文件名)

${relativeFileDirname} - 当前根目录到当前打开文件的相对路径(不包括文件名)

${fileBasename} - 当前打开的文件名(包括扩展名)

${fileBasenameNoExtension} - 当前打开的文件名(不包括扩展名)

${fileDirname} - 当前打开文件的目录

${fileExtname} - 当前打开文件的扩展名

${cwd} - 启动时task工作的目录

${lineNumber} - 当前激活文件所选行

${selectedText} - 当前激活文件中所选择的文本

${execPath} - vscode执行文件所在的目录

${defaultBuildTask} - 默认编译任务(build task)的名字

b. .vscode下setting.json文件

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
// 将设置放入此文件中以覆盖默认值和用户设置。
{
　　"python.pythonPath": "C:\\...\\python.exe",
　　"python.linting.pylintEnabled": false,
　　"python.linting.pep8Enabled": true,
　　"python.linting.lintOnSave": true,
　　"python.formatting.provider": "yapf"
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 计算机网络

 以太网数据是以广播方式发送的，意即局域网内的每台主机都在监听网内传输的数据。以太网硬件将监听到的数据帧所包含的MAC地址与自己的MAC地址比较，如果相同，则接受该帧，否则忽略他，这个是以太网的过滤规则。但是，如果把以太网的硬件设置为“混杂模式”，那么它就可以接收网内的所有数据帧。WinPcap相当于是一个库为抓包工具提供相关的支持。嗅探器就是依据这种原理来监测网络中流动着的数据。 

## 灵感代码

### 排序

c语言里的地址传递是系统先建造int型指针a，然后将实参x的地址传给了指针a
c++里函数参数的值传递和地址传递（如果你没有用&引用，那么主函数调用的时候传入的参数是会被复制一遍的，子函数得到的参数是复制过后的，不是原始的那个了，你对它new之类的操作对主函数之中的变量都没有影响了，（注意delete掉）
如果你用的是&引用，那么函数调用的时候传入的参数是传址，意味着可以对传入参数直接进行修改，这会影响到主函数中的变量的值。（PS：像矩阵之类的若传值则需先复制开销很大，一般就用&引用传址了））
冒泡排序 指定位置以后排序
	for(i=0;i<n-1;i++)
		{
			for(j=i+1;j<n;j++)
			{
				if(a[i]>a[j])
				{
					p = a[i];
					a[i] = a[j];
					a[j] = p;
				}
			}
		}
		for(k=0;k<n-1;k++)
		{
			a[k+1] = a[k]*a[k+1] + 1;
			for(i=k+1;i<n-1;i++)
			{
				for(j=i+1;j<n;j++)
				{
					if(a[i]>a[j])
					{
						p = a[i];
						a[i] = a[j];
						a[j] = p;
					}
				}
			}
		}
 幂运算和进位处理
  for(i=0;i<n;i++){
            car=0;
            for(j=0;j<dig;j++){//以mof为底数计算
                res=mof*a[j]+car;
                a[j]=res%10;
                car=res/10;
            }
            while(car){//进位处理
                a[dig++]=car%10;
                car/=10;
            }
        }
        k=len-k-1;k=k*n;//计算'.'在数中的位置

### 大整数除法

#include<bits/stdc++.h>
#define MAX_LEN 200
using namespace std;
char szLine1[MAX_LEN + 10];
char szLine2[MAX_LEN + 10];
int an1[MAX_LEN + 10];//被除数, an1[0]对应于个位
int an2[MAX_LEN + 10];//除数, an2[0]对应于个位
int aResult[MAX_LEN + 10]; //存放商， aResult[0]对应于个位
/*Substract函数：
长度为 nLen1 的大整数 p1 减去长度为 nLen2 的大整数 p2
减的结果放在 p1 里，返回值代表结果的长度
如不够减返回-1，正好减完返回 0
p1[0]、 p2[0] 是个位 */
int Substract(int *p1,int *p2,int nLen1,int nLen2)
{
	int i;
	if(nLen1 < nLen2)
	{
		return -1;
	}
	//下面判断 p1 是否比 p2 大，如果不是，返回-1
	bool bLarger = false;
	if(nLen1 == nLen2)
	{
		for(i = nLen1 - 1;i >= 0;i--){
			if(p1[i] > p2[i]){
				bLarger = true;
			}
			if(p1[i] < p2[i]){
				if(!bLarger)
					return -1;
			}
		}
	}
	for(i=0;i<nLen1;i++)
	{//做减法
		p1[i] -= p2[i];//要求调用本函数时给的参数能确保当 i>=nLen2 时， p2[i] ＝ 0
		if(p1[i] < 0){
			p1[i] += 10;
			p1[i+1]--;
		}
	}
	for(i=nLen1-1;i >= 0;i--)
	{
		if(p1[i]){
			return i+1;
		}
	}
	return 0;
}
int main(void)
{
	int n;
	char szBlank[20];
	while(cin>>n)
	{
		while(n--)
		{
	 	cin >> szLine1;
	 	cin >> szLine2;
	 	int i,j;
	 	int nLen1 = strlen(szLine1);
	 	int nLen2 = strlen(szLine2);
	 	memset(an1,0,sizeof(an1));
	 	memset(an2,0,sizeof(an2));
	 	memset(aResult,0,sizeof(aResult));
	 	j = 0;
	 	for(i=nLen1-1;i>=0;i--){
	 		an1[j++]=szLine1[i] - '0';
	 	}
	 	j = 0;
	 	for(i=nLen2-1;i>=0;i--){
	 		an2[j++]=szLine2[i] - '0';
	 	}
	 	if(nLen1 < nLen2) {
	 		cout<<"0"<<endl;
	 		continue;
	 	}
	 	nLen1 = Substract(an1,an2,nLen1,nLen2);
	 	if(nLen1 == -1){
	 		cout<<"0"<<endl;
	 		continue;
	 	}else if(nLen1 == 0){
	 		cout<<"1"<<endl;
	 		continue;
	 	}
	 	aResult[0]++;//减掉一次了，商加 1
	 	int nTimes = nLen1 - nLen2;
		if(nTimes < 0){//减一次后就不能再减了
 			goto OutputResult;
 		}else if(nTimes > 0){
 			//将 an2 乘以 10 的某次幂，使得结果长度和 an1 相同
		 	for(i=nLen1-1;i>=0;i--){
	 			if(i >= nTimes){
			 		an2[i]=an2[i-nTimes];
			 	}else{
	 				an2[i]=0;
	 			}
	 		}
	 	}
	 	nLen2 = nLen1;
	 	for(j=0;j<=nTimes;j++){
	 		int nTemp;
	 		//一直减到不够减为止
	 		//先减去若干个 an2×(10 的 nTimes 次方)，
	 		//不够减了，再减去若干个 an2×(10 的 nTimes-1 次方)， ......
	 		while((nTemp=Substract(an1,an2+j,nLen1,nLen2-j)) >= 0){
		 		nLen1 = nTemp;
		 		aResult[nTimes-j]++;//每成功减一次，则将商的相应位加 1
		 	}
	 	}
OutputResult:
		//下面的循环统一处理进位问题
		for(i=0;i<MAX_LEN;i++){
			if(aResult[i]>=10){
				aResult[i+1] += aResult[i] / 10;
				aResult[i] %= 10;
			}
		}
		//下面输出结果
		bool bStartOutput = false;
		for(i=MAX_LEN;i>=0;i--){
			if(bStartOutput){
				cout<<aResult[i];
			}else if(aResult[i]){
				cout<<aResult[i];
				bStartOutput = true;
			}
		}
		if(!bStartOutput){
			cout<<"0";
		}
		cout<<endl;
	 }
	}
	return 0;
}

http://blog.csdn.net/pipisorry)






